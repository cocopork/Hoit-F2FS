
byte_nvm.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <init_byte_nvm_dax>:
 * super
 ********************************************************************************/
/**
 * 进行dax所必要的初始化，初始化流程参考nova
*/
int init_byte_nvm_dax(struct f2fs_sb_info *sbi, struct nvm_super_block **byte_nsb) {
   0:	f3 0f 1e fa          	endbr64 
   4:	e8 00 00 00 00       	callq  9 <init_byte_nvm_dax+0x9>
   9:	55                   	push   %rbp
   a:	48 89 e5             	mov    %rsp,%rbp
   d:	41 56                	push   %r14
   f:	41 55                	push   %r13
  11:	49 89 f5             	mov    %rsi,%r13
  14:	41 54                	push   %r12
  16:	49 89 fc             	mov    %rdi,%r12
  19:	53                   	push   %rbx
  1a:	48 83 ec 18          	sub    $0x18,%rsp
	struct nvm_sb_info *byte_nsbi = sbi->byte_nsbi;
  1e:	48 8b 9f 50 07 00 00 	mov    0x750(%rdi),%rbx
int init_byte_nvm_dax(struct f2fs_sb_info *sbi, struct nvm_super_block **byte_nsb) {
  25:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
  2c:	00 00 
  2e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  32:	31 c0                	xor    %eax,%eax
	int ret;
	long dax_blk_nums = 0;
	void *virt_addr = NULL;
	pfn_t __pfn_t;

	*byte_nsb = NULL;
  34:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
int bdev_dax_pgoff(struct block_device *, sector_t, size_t, pgoff_t *pgoff);
#if IS_ENABLED(CONFIG_FS_DAX)
bool __bdev_dax_supported(struct block_device *bdev, int blocksize);
static inline bool bdev_dax_supported(struct block_device *bdev, int blocksize)
{
	return __bdev_dax_supported(bdev, blocksize);
  3b:	be 00 10 00 00       	mov    $0x1000,%esi
  40:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
	void *virt_addr = NULL;
  44:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  4b:	00 
  4c:	e8 00 00 00 00       	callq  51 <init_byte_nvm_dax+0x51>
	/* ZN：获取DAX设备信息 */
	ret = bdev_dax_supported(byte_nsbi->nbdev, PAGE_SIZE);
	if (!ret) {
  51:	84 c0                	test   %al,%al
  53:	0f 84 e0 00 00 00    	je     139 <init_byte_nvm_dax+0x139>
		nvm_debug(NVM_ERR, "device does not support DAX\n");
		return -EINVAL;
	}

	dax_dev = fs_dax_get_by_host(byte_nsbi->nbdev->bd_disk->disk_name);
  59:	48 8b 43 08          	mov    0x8(%rbx),%rax
  5d:	48 8b b8 80 00 00 00 	mov    0x80(%rax),%rdi
  64:	48 83 c7 0c          	add    $0xc,%rdi
}

static inline struct dax_device *fs_dax_get_by_host(const char *host)
{
	return dax_get_by_host(host);
  68:	e8 00 00 00 00       	callq  6d <init_byte_nvm_dax+0x6d>
  6d:	49 89 c6             	mov    %rax,%r14
	if (!dax_dev) {
  70:	48 85 c0             	test   %rax,%rax
  73:	0f 84 c0 00 00 00    	je     139 <init_byte_nvm_dax+0x139>
			unsigned int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
  79:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 80 <init_byte_nvm_dax+0x80>
  80:	ba 30 00 00 00       	mov    $0x30,%edx
  85:	be c0 80 60 00       	mov    $0x6080c0,%esi
  8a:	e8 00 00 00 00       	callq  8f <init_byte_nvm_dax+0x8f>
		nvm_debug(NVM_ERR, "Couldn't retrieve DAX device.\n");
		return -EINVAL;
	}
	/* 分配并填写byte nvm私有数据 */
	byte_nsbi->byte_private = kzalloc(sizeof(struct byte_nvm_private), GFP_KERNEL);
  8f:	48 89 83 08 01 00 00 	mov    %rax,0x108(%rbx)
	if(!byte_nsbi->byte_private){
  96:	48 85 c0             	test   %rax,%rax
  99:	0f 84 a2 00 00 00    	je     141 <init_byte_nvm_dax+0x141>
		return -ENOMEM;
	}
		
	byte_nsbi->byte_private->dax_dev = dax_dev;
  9f:	4c 89 30             	mov    %r14,(%rax)
	/* 获取dax映射虚拟地址 */
	dax_blk_nums = dax_direct_access(byte_nsbi->byte_private->dax_dev, 0, LONG_MAX/PAGE_SIZE, 
  a2:	48 8b 83 08 01 00 00 	mov    0x108(%rbx),%rax
  a9:	31 f6                	xor    %esi,%esi
  ab:	4c 8d 45 d0          	lea    -0x30(%rbp),%r8
  af:	48 ba ff ff ff ff ff 	movabs $0x7ffffffffffff,%rdx
  b6:	ff 07 00 
  b9:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  bd:	48 8b 38             	mov    (%rax),%rdi
  c0:	e8 00 00 00 00       	callq  c5 <init_byte_nvm_dax+0xc5>
									&virt_addr, &__pfn_t);

	if (dax_blk_nums <= 0) {
  c5:	48 85 c0             	test   %rax,%rax
  c8:	7e 6f                	jle    139 <init_byte_nvm_dax+0x139>

	//ZN: 查看是否可访问块数量一致（是一致的
	// printk(KERN_INFO"ZN trap: dax accessable block :%d",dax_blk_nums);
	// printk(KERN_INFO"ZN trap: device accessable block :%d",SECTOR_TO_BLOCK(byte_nsbi->nbdev->bd_part->nr_sects));

	byte_nsbi->byte_private->virt_addr = virt_addr;
  ca:	48 8b 93 08 01 00 00 	mov    0x108(%rbx),%rdx
  d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  d5:	48 89 42 10          	mov    %rax,0x10(%rdx)
	if (!byte_nsbi->byte_private->virt_addr) {
  d9:	48 8b 93 08 01 00 00 	mov    0x108(%rbx),%rdx
  e0:	48 83 7a 10 00       	cmpq   $0x0,0x10(%rdx)
  e5:	74 52                	je     139 <init_byte_nvm_dax+0x139>
		nvm_debug(NVM_ERR, "ioremap failed\n");
		return -EINVAL;
	}
	/* 如果是第一次挂载， byte_nsb 保存在第一块 */
	*byte_nsb = (struct nvm_super_block*)virt_addr;
  e7:	49 89 45 00          	mov    %rax,0x0(%r13)

	if(!(sbi->byte_nsbi->nvm_flag & NVM_FIRST_MOUNR)){
  eb:	49 8b 94 24 50 07 00 	mov    0x750(%r12),%rdx
  f2:	00 
		}
		/* version为1则在第1块 */
		if (sbi->ckpt->ckpt_flags & CP_NSB_VER_FLAG)
			*byte_nsb += 1;
	}
	return 0;
  f3:	45 31 c0             	xor    %r8d,%r8d
	if(!(sbi->byte_nsbi->nvm_flag & NVM_FIRST_MOUNR)){
  f6:	f6 42 10 02          	testb  $0x2,0x10(%rdx)
  fa:	75 1e                	jne    11a <init_byte_nvm_dax+0x11a>
		if(!sbi->ckpt) {
  fc:	49 8b 94 24 78 01 00 	mov    0x178(%r12),%rdx
 103:	00 
 104:	48 85 d2             	test   %rdx,%rdx
 107:	74 30                	je     139 <init_byte_nvm_dax+0x139>
		if (sbi->ckpt->ckpt_flags & CP_NSB_VER_FLAG)
 109:	f6 82 85 00 00 00 10 	testb  $0x10,0x85(%rdx)
 110:	74 08                	je     11a <init_byte_nvm_dax+0x11a>
			*byte_nsb += 1;
 112:	48 83 c0 40          	add    $0x40,%rax
 116:	49 89 45 00          	mov    %rax,0x0(%r13)
}
 11a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 11e:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
 125:	00 00 
 127:	75 20                	jne    149 <init_byte_nvm_dax+0x149>
 129:	48 83 c4 18          	add    $0x18,%rsp
 12d:	44 89 c0             	mov    %r8d,%eax
 130:	5b                   	pop    %rbx
 131:	41 5c                	pop    %r12
 133:	41 5d                	pop    %r13
 135:	41 5e                	pop    %r14
 137:	5d                   	pop    %rbp
 138:	c3                   	retq   
		return -EINVAL;
 139:	41 b8 ea ff ff ff    	mov    $0xffffffea,%r8d
 13f:	eb d9                	jmp    11a <init_byte_nvm_dax+0x11a>
		return -ENOMEM;
 141:	41 b8 f4 ff ff ff    	mov    $0xfffffff4,%r8d
 147:	eb d1                	jmp    11a <init_byte_nvm_dax+0x11a>
}
 149:	e8 00 00 00 00       	callq  14e <init_byte_nvm_dax+0x14e>
 14e:	66 90                	xchg   %ax,%ax

0000000000000150 <init_byte_nvm_private_info>:
 * 
 * @param sbi 文件系统超级快数据
 * @return int 成功时返回0
 */
int init_byte_nvm_private_info(struct f2fs_sb_info *sbi)
{
 150:	f3 0f 1e fa          	endbr64 
 154:	e8 00 00 00 00       	callq  159 <init_byte_nvm_private_info+0x9>
    return sbi->byte_nsbi;
}

static inline struct byte_nvm_private *F2FS_BYTE_NVM_PRIVATE(struct f2fs_sb_info *sbi) 
{
    return sbi->byte_nsbi->byte_private;
 159:	48 8b 97 50 07 00 00 	mov    0x750(%rdi),%rdx
	struct f2fs_super_block * sb = sbi->raw_super;
 160:	48 8b 47 10          	mov    0x10(%rdi),%rax
{
 164:	55                   	push   %rbp
 165:	48 8b 8a 08 01 00 00 	mov    0x108(%rdx),%rcx
 16c:	48 89 e5             	mov    %rsp,%rbp
	struct byte_nvm_private * byte_nsb_private = F2FS_BYTE_NVM_PRIVATE(sbi);
	if (!sb)
 16f:	48 85 c0             	test   %rax,%rax
 172:	74 44                	je     1b8 <init_byte_nvm_private_info+0x68>
	}
	/**
	 * 物理上nvm第一个segment归属于超级块，segment0从第二块开始数起
	 * 但是block0还是从nvm超级块所在位置开始算起
	 */
	byte_nsb_private->super_blkaddr		= 0;
 174:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%rcx)
	byte_nsb_private->segment0_blkaddr 	= 1 * sbi->blocks_per_seg;
 17b:	8b 97 24 04 00 00    	mov    0x424(%rdi),%edx
 181:	89 51 1c             	mov    %edx,0x1c(%rcx)
	byte_nsb_private->cp_blkaddr		= le32_to_cpu(sb->segment0_blkaddr);
 184:	8b 50 48             	mov    0x48(%rax),%edx
 187:	89 51 20             	mov    %edx,0x20(%rcx)
	byte_nsb_private->sit_blkaddr		= le32_to_cpu(sb->sit_blkaddr) 
											- le32_to_cpu(sb->cp_blkaddr) 
											+ byte_nsb_private->cp_blkaddr;
 18a:	8b 70 50             	mov    0x50(%rax),%esi
 18d:	01 d6                	add    %edx,%esi
 18f:	2b 70 4c             	sub    0x4c(%rax),%esi
	byte_nsb_private->sit_blkaddr		= le32_to_cpu(sb->sit_blkaddr) 
 192:	89 71 24             	mov    %esi,0x24(%rcx)
	byte_nsb_private->nat_blkaddr		= le32_to_cpu(sb->nat_blkaddr) 
											- le32_to_cpu(sb->cp_blkaddr) 
											+ byte_nsb_private->cp_blkaddr;
 195:	8b 70 54             	mov    0x54(%rax),%esi
 198:	01 d6                	add    %edx,%esi
 19a:	2b 70 4c             	sub    0x4c(%rax),%esi
	byte_nsb_private->nat_blkaddr		= le32_to_cpu(sb->nat_blkaddr) 
 19d:	89 71 28             	mov    %esi,0x28(%rcx)
	byte_nsb_private->ssa_blkaddr		= le32_to_cpu(sb->ssa_blkaddr) 
											- le32_to_cpu(sb->cp_blkaddr) 
											+ byte_nsb_private->cp_blkaddr;
 1a0:	03 50 58             	add    0x58(%rax),%edx
 1a3:	2b 50 4c             	sub    0x4c(%rax),%edx
	byte_nsb_private->ssa_blkaddr		= le32_to_cpu(sb->ssa_blkaddr) 
 1a6:	89 51 2c             	mov    %edx,0x2c(%rcx)
	// byte_nsb_private->s_flag |= BNVM_PRIVATE_READY;
	sbi->byte_nsbi->nvm_flag |= NVM_BYTE_PRIVATE_READY;
 1a9:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
 1b0:	80 48 10 08          	orb    $0x8,0x10(%rax)
	return 0;
 1b4:	31 c0                	xor    %eax,%eax
}
 1b6:	5d                   	pop    %rbp
 1b7:	c3                   	retq   
		return -EINVAL;
 1b8:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
 1bd:	5d                   	pop    %rbp
 1be:	c3                   	retq   
 1bf:	90                   	nop

00000000000001c0 <init_byte_nvm_sb_info>:
//依据byte nsb设置nsbi的相关字段
//与块设备相比添加DAX信息
int init_byte_nvm_sb_info(struct f2fs_sb_info *sbi, struct nvm_super_block *byte_nsb) {
 1c0:	f3 0f 1e fa          	endbr64 
 1c4:	e8 00 00 00 00       	callq  1c9 <init_byte_nvm_sb_info+0x9>
 1c9:	55                   	push   %rbp
#endif

extern void *kvmalloc_node(size_t size, gfp_t flags, int node);
static inline void *kvmalloc(size_t size, gfp_t flags)
{
	return kvmalloc_node(size, flags, NUMA_NO_NODE);
 1ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 1cf:	48 89 e5             	mov    %rsp,%rbp
 1d2:	41 57                	push   %r15
 1d4:	41 56                	push   %r14
 1d6:	41 55                	push   %r13
 1d8:	41 54                	push   %r12
 1da:	49 89 fc             	mov    %rdi,%r12
 1dd:	53                   	push   %rbx
 1de:	48 89 f3             	mov    %rsi,%rbx
 1e1:	48 83 ec 10          	sub    $0x10,%rsp
	struct nvm_sb_info *byte_nsbi = sbi->byte_nsbi;
 1e5:	4c 8b af 50 07 00 00 	mov    0x750(%rdi),%r13
	int i = 0;
	int j = 0;
	int ret = 0;
	unsigned int segment_count_main = le32_to_cpu(sbi->raw_super->segment_count_main);
 1ec:	48 8b 47 10          	mov    0x10(%rdi),%rax
 1f0:	44 8b 70 44          	mov    0x44(%rax),%r14d
	byte_nsbi->nsb = byte_nsb;
 1f4:	49 89 75 00          	mov    %rsi,0x0(%r13)

	/* ZN:内存中保存各种区域的位图，version_map和dirty_map应该是论文MPT里的后面两位标志 */
	/* 1、为MPT版本位图申请空间,单位：字节 */
	byte_nsbi->mpt_ver_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(byte_nsb->mpt_ver_map_bits), GFP_KERNEL);
 1f8:	8b 7e 34             	mov    0x34(%rsi),%edi
 1fb:	be c0 80 60 00       	mov    $0x6080c0,%esi
 200:	48 83 c7 3f          	add    $0x3f,%rdi
 204:	48 c1 ef 06          	shr    $0x6,%rdi
 208:	48 c1 e7 03          	shl    $0x3,%rdi
 20c:	e8 00 00 00 00       	callq  211 <init_byte_nvm_sb_info+0x51>
 211:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 216:	be c0 80 60 00       	mov    $0x6080c0,%esi
 21b:	49 89 45 68          	mov    %rax,0x68(%r13)
	/* 2、为main区域segment位图申请空间 */
	byte_nsbi->segment_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(byte_nsb->main_segment_nums), GFP_KERNEL);
 21f:	8b 7b 2c             	mov    0x2c(%rbx),%edi
 222:	48 83 c7 3f          	add    $0x3f,%rdi
 226:	48 c1 ef 06          	shr    $0x6,%rdi
 22a:	48 c1 e7 03          	shl    $0x3,%rdi
 22e:	e8 00 00 00 00       	callq  233 <init_byte_nvm_sb_info+0x73>
 233:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 238:	be c0 80 60 00       	mov    $0x6080c0,%esi
 23d:	49 89 45 78          	mov    %rax,0x78(%r13)
	byte_nsbi->ckpt_segment_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(byte_nsb->main_segment_nums), GFP_KERNEL);
 241:	8b 7b 2c             	mov    0x2c(%rbx),%edi
 244:	48 83 c7 3f          	add    $0x3f,%rdi
 248:	48 c1 ef 06          	shr    $0x6,%rdi
 24c:	48 c1 e7 03          	shl    $0x3,%rdi
 250:	e8 00 00 00 00       	callq  255 <init_byte_nvm_sb_info+0x95>
 255:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 25a:	be c0 80 60 00       	mov    $0x6080c0,%esi
 25f:	49 89 85 80 00 00 00 	mov    %rax,0x80(%r13)
	/* 3、为MPT表脏页位图申请空间 */
	/* MPT脏页位图大小 和 MPT版本位图大小 相同 */
	byte_nsbi->mpt_dirty_map_bits = byte_nsb->mpt_ver_map_bits;
 266:	8b 7b 34             	mov    0x34(%rbx),%edi
 269:	41 89 7d 60          	mov    %edi,0x60(%r13)
	byte_nsbi->mpt_dirty_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(byte_nsbi->mpt_dirty_map_bits), GFP_KERNEL);
 26d:	48 83 c7 3f          	add    $0x3f,%rdi
 271:	48 c1 ef 06          	shr    $0x6,%rdi
 275:	48 c1 e7 03          	shl    $0x3,%rdi
 279:	e8 00 00 00 00       	callq  27e <init_byte_nvm_sb_info+0xbe>

	if (!(byte_nsbi->mpt_ver_map && byte_nsbi->segment_map && byte_nsbi->mpt_dirty_map)) {
 27e:	49 83 7d 68 00       	cmpq   $0x0,0x68(%r13)
	byte_nsbi->mpt_dirty_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(byte_nsbi->mpt_dirty_map_bits), GFP_KERNEL);
 283:	49 89 45 58          	mov    %rax,0x58(%r13)
	if (!(byte_nsbi->mpt_ver_map && byte_nsbi->segment_map && byte_nsbi->mpt_dirty_map)) {
 287:	0f 84 96 01 00 00    	je     423 <init_byte_nvm_sb_info+0x263>
 28d:	49 83 7d 78 00       	cmpq   $0x0,0x78(%r13)
 292:	0f 84 8b 01 00 00    	je     423 <init_byte_nvm_sb_info+0x263>
 298:	48 85 c0             	test   %rax,%rax
 29b:	0f 84 82 01 00 00    	je     423 <init_byte_nvm_sb_info+0x263>
		return -ENOMEM;
	}

	mutex_init(&byte_nsbi->nvmgc_mutex);
 2a1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
 2a8:	49 8d 7d 30          	lea    0x30(%r13),%rdi
 2ac:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
 2b3:	e8 00 00 00 00       	callq  2b8 <init_byte_nvm_sb_info+0xf8>

	// printk(KERN_INFO"ZN trap: byte mpt_entries nmus = %d", byte_nsb->mpt_entries);
	
	/* 不分配mpt cache ，mpt地址直接指向dax映射区域 */
	byte_nsbi->mpt = (unsigned int)byte_nsbi->byte_private->virt_addr 
										+ byte_nsbi->nsb->mpt_blkaddr * PAGE_SIZE / sizeof(unsigned int);
 2b8:	49 8b 45 00          	mov    0x0(%r13),%rax
	byte_nsbi->mpt = (unsigned int)byte_nsbi->byte_private->virt_addr 
 2bc:	49 8b 95 08 01 00 00 	mov    0x108(%r13),%rdx
	spin_lock_init(&byte_nsbi->mpt_ver_map_lock);
 2c3:	41 c7 45 70 00 00 00 	movl   $0x0,0x70(%r13)
 2ca:	00 
	spin_lock_init(&byte_nsbi->mpt_lock);
 2cb:	41 c7 45 64 00 00 00 	movl   $0x0,0x64(%r13)
 2d2:	00 
 2d3:	4d 8d bd 98 00 00 00 	lea    0x98(%r13),%r15
	spin_lock_init(&byte_nsbi->segment_map_lock);
 2da:	41 c7 85 88 00 00 00 	movl   $0x0,0x88(%r13)
 2e1:	00 00 00 00 
	spin_lock_init(&byte_nsbi->lfu_half_lock);
 2e5:	41 c7 85 b8 00 00 00 	movl   $0x0,0xb8(%r13)
 2ec:	00 00 00 00 
	spin_lock_init(&byte_nsbi->aqusz_lock);
 2f0:	41 c7 85 00 01 00 00 	movl   $0x0,0x100(%r13)
 2f7:	00 00 00 00 
										+ byte_nsbi->nsb->mpt_blkaddr * PAGE_SIZE / sizeof(unsigned int);
 2fb:	8b 40 10             	mov    0x10(%rax),%eax
	byte_nsbi->mpt = (unsigned int)byte_nsbi->byte_private->virt_addr 
 2fe:	8b 52 10             	mov    0x10(%rdx),%edx
										+ byte_nsbi->nsb->mpt_blkaddr * PAGE_SIZE / sizeof(unsigned int);
 301:	48 c1 e0 0a          	shl    $0xa,%rax
 305:	48 01 d0             	add    %rdx,%rax
 308:	49 89 45 50          	mov    %rax,0x50(%r13)
	// 						  GFP_KERNEL);
	
	/* 4.为lfu_count cache分配内存空间，为了对NVM段进行访问计数，方便对NVM段进行垃圾回收[最后多一个空间用于记录访问总数] */
	for (i = 0; i < LFU_LEVELS; i++) {
		byte_nsbi->lfu_count[i] = f2fs_kvzalloc(sbi,
										   (((segment_count_main + 1) * sizeof(atomic_t) - 1) /
 30c:	41 8d 46 01          	lea    0x1(%r14),%eax
 310:	48 8d 04 85 ff ff ff 	lea    -0x1(,%rax,4),%rax
 317:	ff 
											PAGE_SIZE + 1) * PAGE_SIZE, GFP_KERNEL);
 318:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
		byte_nsbi->lfu_count[i] = f2fs_kvzalloc(sbi,
 31e:	48 8d 98 00 10 00 00 	lea    0x1000(%rax),%rbx
		//初始化值为-1
		for (j = 0; j < segment_count_main; j++) {
			atomic_set(&byte_nsbi->lfu_count[i][j], -1);
		}
		//初始化总计数为0
		atomic_set(&byte_nsbi->lfu_count[i][segment_count_main], 0);
 325:	44 89 f0             	mov    %r14d,%eax
 328:	48 c1 e0 02          	shl    $0x2,%rax
 32c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 330:	49 8d 85 b8 00 00 00 	lea    0xb8(%r13),%rax
 337:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 33b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 340:	be c0 80 60 00       	mov    $0x6080c0,%esi
 345:	48 89 df             	mov    %rbx,%rdi
 348:	e8 00 00 00 00       	callq  34d <init_byte_nvm_sb_info+0x18d>
		byte_nsbi->lfu_count[i] = f2fs_kvzalloc(sbi,
 34d:	49 89 07             	mov    %rax,(%r15)
		for (j = 0; j < segment_count_main; j++) {
 350:	45 85 f6             	test   %r14d,%r14d
 353:	74 1a                	je     36f <init_byte_nvm_sb_info+0x1af>
 355:	31 d2                	xor    %edx,%edx
			atomic_set(&byte_nsbi->lfu_count[i][j], -1);
 357:	48 63 f2             	movslq %edx,%rsi
		for (j = 0; j < segment_count_main; j++) {
 35a:	83 c2 01             	add    $0x1,%edx
			atomic_set(&byte_nsbi->lfu_count[i][j], -1);
 35d:	48 8d 04 b0          	lea    (%rax,%rsi,4),%rax
static __always_inline void __write_once_size(volatile void *p, void *res, int size)
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
 361:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%rax)
		for (j = 0; j < segment_count_main; j++) {
 367:	49 8b 07             	mov    (%r15),%rax
 36a:	41 39 d6             	cmp    %edx,%r14d
 36d:	75 e8                	jne    357 <init_byte_nvm_sb_info+0x197>
		atomic_set(&byte_nsbi->lfu_count[i][segment_count_main], 0);
 36f:	48 03 45 c8          	add    -0x38(%rbp),%rax
 373:	49 83 c7 08          	add    $0x8,%r15
 377:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	for (i = 0; i < LFU_LEVELS; i++) {
 37d:	4c 39 7d d0          	cmp    %r15,-0x30(%rbp)
 381:	75 b8                	jne    33b <init_byte_nvm_sb_info+0x17b>
	}
	byte_nsbi->now_lfu_counter = 0;//初始化当前计数器为第一个计数器
 383:	41 c7 85 90 00 00 00 	movl   $0x0,0x90(%r13)
 38a:	00 00 00 00 
	byte_nsbi->mh = init_max_heap(sbi, NVM_TO_SSD);
 38e:	be 32 00 00 00       	mov    $0x32,%esi
 393:	4c 89 e7             	mov    %r12,%rdi
 396:	e8 00 00 00 00       	callq  39b <init_byte_nvm_sb_info+0x1db>
	byte_nsbi->minh = init_min_heap(sbi, SSD_TO_NVM);
 39b:	be 14 00 00 00       	mov    $0x14,%esi
 3a0:	4c 89 e7             	mov    %r12,%rdi
	byte_nsbi->mh = init_max_heap(sbi, NVM_TO_SSD);
 3a3:	49 89 85 c0 00 00 00 	mov    %rax,0xc0(%r13)
	byte_nsbi->minh = init_min_heap(sbi, SSD_TO_NVM);
 3aa:	e8 00 00 00 00       	callq  3af <init_byte_nvm_sb_info+0x1ef>
extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
	return alloc_pages_current(gfp_mask, order);
 3af:	bf c0 00 60 00       	mov    $0x6000c0,%edi
 3b4:	49 89 85 c8 00 00 00 	mov    %rax,0xc8(%r13)
 3bb:	41 8b b4 24 20 04 00 	mov    0x420(%r12),%esi
 3c2:	00 
 3c3:	e8 00 00 00 00       	callq  3c8 <init_byte_nvm_sb_info+0x208>
 3c8:	bf c0 00 60 00       	mov    $0x6000c0,%edi
	byte_nsbi->nvm_gc_start_page = alloc_pages(GFP_KERNEL, sbi->log_blocks_per_seg);// 分配用于NVM-GC段迁移的连续物理内存页
 3cd:	49 89 85 d0 00 00 00 	mov    %rax,0xd0(%r13)
 3d4:	41 8b b4 24 20 04 00 	mov    0x420(%r12),%esi
 3db:	00 
 3dc:	e8 00 00 00 00       	callq  3e1 <init_byte_nvm_sb_info+0x221>
	byte_nsbi->ssd_to_nvm_start_page = alloc_pages(GFP_KERNEL, sbi->log_blocks_per_seg);// 分配用于NVM-GC段迁移的连续物理内存页
	nvm_assert(byte_nsbi->nvm_gc_start_page);
 3e1:	49 83 bd d0 00 00 00 	cmpq   $0x0,0xd0(%r13)
 3e8:	00 
	byte_nsbi->ssd_to_nvm_start_page = alloc_pages(GFP_KERNEL, sbi->log_blocks_per_seg);// 分配用于NVM-GC段迁移的连续物理内存页
 3e9:	49 89 85 d8 00 00 00 	mov    %rax,0xd8(%r13)
	nvm_assert(byte_nsbi->nvm_gc_start_page);
 3f0:	74 2d                	je     41f <init_byte_nvm_sb_info+0x25f>
	nvm_assert(byte_nsbi->ssd_to_nvm_start_page);
 3f2:	48 85 c0             	test   %rax,%rax
 3f5:	74 2a                	je     421 <init_byte_nvm_sb_info+0x261>

	if (!byte_nsbi->lfu_count[0] || !byte_nsbi->mpt)
 3f7:	49 83 bd 98 00 00 00 	cmpq   $0x0,0x98(%r13)
 3fe:	00 
 3ff:	74 22                	je     423 <init_byte_nvm_sb_info+0x263>
 401:	49 83 7d 50 00       	cmpq   $0x0,0x50(%r13)
 406:	74 1b                	je     423 <init_byte_nvm_sb_info+0x263>
		return -ENOMEM;

	ret = init_byte_nvm_private_info(sbi);
 408:	4c 89 e7             	mov    %r12,%rdi
 40b:	e8 00 00 00 00       	callq  410 <init_byte_nvm_sb_info+0x250>
	return ret;
}
 410:	48 83 c4 10          	add    $0x10,%rsp
 414:	5b                   	pop    %rbx
 415:	41 5c                	pop    %r12
 417:	41 5d                	pop    %r13
 419:	41 5e                	pop    %r14
 41b:	41 5f                	pop    %r15
 41d:	5d                   	pop    %rbp
 41e:	c3                   	retq   
	nvm_assert(byte_nsbi->nvm_gc_start_page);
 41f:	0f 0b                	ud2    
	nvm_assert(byte_nsbi->ssd_to_nvm_start_page);
 421:	0f 0b                	ud2    
		return -ENOMEM;
 423:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 428:	eb e6                	jmp    410 <init_byte_nvm_sb_info+0x250>
 42a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000430 <byte_nvm_flush_mpt_pages>:
 * 将mpt cache拷贝回byte nvm mapping区域
 * TODO：真的要按页刷回吗，直接在nvm中更新更好一些，但是dax如何确保数据刷回到nvm中呢
 * 暂时保留这个函数
 * @param sbi
 */
void byte_nvm_flush_mpt_pages(struct f2fs_sb_info *sbi, int flush_all){
 430:	f3 0f 1e fa          	endbr64 
 434:	e8 00 00 00 00       	callq  439 <byte_nvm_flush_mpt_pages+0x9>
 439:	55                   	push   %rbp
 43a:	48 89 e5             	mov    %rsp,%rbp
 43d:	41 54                	push   %r12
 43f:	41 89 f4             	mov    %esi,%r12d
 442:	53                   	push   %rbx
	struct nvm_sb_info *byte_nsbi = sbi->byte_nsbi;
 443:	48 8b 9f 50 07 00 00 	mov    0x750(%rdi),%rbx
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
 44a:	48 8d 7b 64          	lea    0x64(%rbx),%rdi
 44e:	e8 00 00 00 00       	callq  453 <byte_nvm_flush_mpt_pages+0x23>
	int mpt_pgoff = 0;//找到的脏页偏移
	int dirty = 0;//是否有脏位
	void *dst_addr;//byte nvm 在内存中的dax地址
	void *src_addr;//mpt cache中开始拷贝的地址
	spin_lock(&byte_nsbi->mpt_lock);
	if(flush_all){
 453:	31 c0                	xor    %eax,%eax
 455:	31 d2                	xor    %edx,%edx
 457:	45 85 e4             	test   %r12d,%r12d
 45a:	0f 84 93 00 00 00    	je     4f3 <byte_nvm_flush_mpt_pages+0xc3>
		mpt_pgoff = 0;
	} else {/* ZN：从0位置开始找比特位为1的位置，如果没有，则返回map的比特数（mpt_dirty_map_bits） */
		mpt_pgoff = find_next_bit(byte_nsbi->mpt_dirty_map, byte_nsbi->mpt_dirty_map_bits, 0);
	}

	while(mpt_pgoff != byte_nsbi->mpt_dirty_map_bits) {
 460:	39 43 60             	cmp    %eax,0x60(%rbx)
 463:	74 6a                	je     4cf <byte_nvm_flush_mpt_pages+0x9f>
		///设置NVM是否为脏标志位
		if (!dirty) {
			nvm_debug(NVM_DEBUG, "flush mpt");
			dirty = 1;
			//设置标志位：nvm映射表为脏
			byte_nsbi->nvm_flag |= NVM_NSB_DIRTY;
 465:	80 4b 10 01          	orb    $0x1,0x10(%rbx)
		}	
		//计算mpt cache中开始拷贝的地址
		src_addr = byte_nsbi->mpt + (PAGE_SIZE * mpt_pgoff / sizeof(unsigned int));
		dst_addr = byte_nsbi->byte_private->virt_addr + byte_nsbi->nsb->ra_blkaddr + mpt_pgoff;
 469:	48 8b 0b             	mov    (%rbx),%rcx
 46c:	48 8b b3 08 01 00 00 	mov    0x108(%rbx),%rsi
		src_addr = byte_nsbi->mpt + (PAGE_SIZE * mpt_pgoff / sizeof(unsigned int));
 473:	48 63 c2             	movslq %edx,%rax
		dst_addr = byte_nsbi->byte_private->virt_addr + byte_nsbi->nsb->ra_blkaddr + mpt_pgoff;
 476:	8b 49 14             	mov    0x14(%rcx),%ecx
 479:	48 01 c1             	add    %rax,%rcx
 47c:	48 03 4e 10          	add    0x10(%rsi),%rcx
		src_addr = byte_nsbi->mpt + (PAGE_SIZE * mpt_pgoff / sizeof(unsigned int));
 480:	48 89 c6             	mov    %rax,%rsi
 483:	48 c1 e6 0c          	shl    $0xc,%rsi
 487:	48 03 73 50          	add    0x50(%rbx),%rsi
		if (q_size < size)
			__read_overflow2();
	}
	if (p_size < size || q_size < size)
		fortify_panic(__func__);
	return __builtin_memcpy(p, q, size);
 48b:	48 8b 3e             	mov    (%rsi),%rdi
 48e:	48 89 39             	mov    %rdi,(%rcx)
 491:	48 8b be f8 0f 00 00 	mov    0xff8(%rsi),%rdi
 498:	48 89 b9 f8 0f 00 00 	mov    %rdi,0xff8(%rcx)
 49f:	48 8d 79 08          	lea    0x8(%rcx),%rdi
 4a3:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
 4a7:	48 29 f9             	sub    %rdi,%rcx
 4aa:	48 29 ce             	sub    %rcx,%rsi
 4ad:	81 c1 00 10 00 00    	add    $0x1000,%ecx
 4b3:	c1 e9 03             	shr    $0x3,%ecx
 4b6:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		memcpy(dst_addr, src_addr, PAGE_SIZE);
		//处理完清除脏位
		clear_bit(mpt_pgoff, byte_nsbi->mpt_dirty_map);
 4b9:	48 8b 4b 58          	mov    0x58(%rbx),%rcx
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
			: "iq" ((u8)~CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
 4bd:	f0 48 0f b3 01       	lock btr %rax,(%rcx)
		//处理下一个
		if (flush_all) {
 4c2:	83 c2 01             	add    $0x1,%edx
 4c5:	45 85 e4             	test   %r12d,%r12d
 4c8:	74 0a                	je     4d4 <byte_nvm_flush_mpt_pages+0xa4>
	while(mpt_pgoff != byte_nsbi->mpt_dirty_map_bits) {
 4ca:	3b 53 60             	cmp    0x60(%rbx),%edx
 4cd:	75 9a                	jne    469 <byte_nvm_flush_mpt_pages+0x39>
			mpt_pgoff = find_next_bit(byte_nsbi->mpt_dirty_map, byte_nsbi->mpt_dirty_map_bits, ++mpt_pgoff);
		}		

	}

}
 4cf:	5b                   	pop    %rbx
 4d0:	41 5c                	pop    %r12
 4d2:	5d                   	pop    %rbp
 4d3:	c3                   	retq   
			mpt_pgoff = find_next_bit(byte_nsbi->mpt_dirty_map, byte_nsbi->mpt_dirty_map_bits, ++mpt_pgoff);
 4d4:	8b 73 60             	mov    0x60(%rbx),%esi
 4d7:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
 4db:	48 63 d2             	movslq %edx,%rdx
 4de:	e8 00 00 00 00       	callq  4e3 <byte_nvm_flush_mpt_pages+0xb3>
 4e3:	89 c2                	mov    %eax,%edx
	while(mpt_pgoff != byte_nsbi->mpt_dirty_map_bits) {
 4e5:	39 43 60             	cmp    %eax,0x60(%rbx)
 4e8:	0f 85 7b ff ff ff    	jne    469 <byte_nvm_flush_mpt_pages+0x39>
}
 4ee:	5b                   	pop    %rbx
 4ef:	41 5c                	pop    %r12
 4f1:	5d                   	pop    %rbp
 4f2:	c3                   	retq   
		mpt_pgoff = find_next_bit(byte_nsbi->mpt_dirty_map, byte_nsbi->mpt_dirty_map_bits, 0);
 4f3:	8b 73 60             	mov    0x60(%rbx),%esi
 4f6:	48 8b 7b 58          	mov    0x58(%rbx),%rdi
 4fa:	31 d2                	xor    %edx,%edx
 4fc:	e8 00 00 00 00       	callq  501 <byte_nvm_flush_mpt_pages+0xd1>
 501:	89 c2                	mov    %eax,%edx
 503:	e9 58 ff ff ff       	jmpq   460 <byte_nvm_flush_mpt_pages+0x30>
 508:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
 50f:	00 

0000000000000510 <f2fs_move_cp_to_bnvm>:
 ********************************************************************************/
/**
 * 将内存中的sbi->ckpt转移至bnvm上，调用之前确保ckpt已经在内存中
*/
int f2fs_move_cp_to_bnvm(struct f2fs_sb_info *sbi)
{
 510:	f3 0f 1e fa          	endbr64 
 514:	e8 00 00 00 00       	callq  519 <f2fs_move_cp_to_bnvm+0x9>
 519:	55                   	push   %rbp
	struct nvm_sb_info *byte_nsbi  = F2FS_BYTE_NSB_I(sbi);
	struct f2fs_checkpoint *pre_ckpt = sbi->ckpt;
	struct f2fs_checkpoint *new_ckpt;
	unsigned char src,dst;
	if (!pre_ckpt)
		return -EINVAL;
 51a:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
 51f:	48 89 e5             	mov    %rsp,%rbp
 522:	41 56                	push   %r14
 524:	41 55                	push   %r13
 526:	41 54                	push   %r12
 528:	53                   	push   %rbx
	struct f2fs_checkpoint *pre_ckpt = sbi->ckpt;
 529:	4c 8b a7 78 01 00 00 	mov    0x178(%rdi),%r12
	if (!pre_ckpt)
 530:	4d 85 e4             	test   %r12,%r12
 533:	74 14                	je     549 <f2fs_move_cp_to_bnvm+0x39>
    return sbi->byte_nsbi;
 535:	48 8b 97 50 07 00 00 	mov    0x750(%rdi),%rdx
	if (sbi->byte_nsbi->nvm_flag & NVM_BYTE_PRIVATE_READY)
 53c:	48 89 fb             	mov    %rdi,%rbx
 53f:	f6 42 10 08          	testb  $0x8,0x10(%rdx)
 543:	0f 85 00 00 00 00    	jne    549 <f2fs_move_cp_to_bnvm+0x39>
	printk(KERN_INFO"ZN trap: 3");
	memcpy(dst, src, cp_blks * sbi->blocksize);
	kfree(src);
	sbi->ckpt = new_ckpt;
	return 0;
}
 549:	5b                   	pop    %rbx
 54a:	41 5c                	pop    %r12
 54c:	41 5d                	pop    %r13
 54e:	41 5e                	pop    %r14
 550:	5d                   	pop    %rbp
 551:	c3                   	retq   
 552:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
 559:	00 00 00 00 
 55d:	0f 1f 00             	nopl   (%rax)

0000000000000560 <bnvm_read_compacted_summaries>:
 * 获取bnvm上的compacted_summaries，
 * 参考 read_compacted_summaries
*/
//TODO：是否需要加锁？
void bnvm_read_compacted_summaries(struct f2fs_sb_info *sbi)
{
 560:	f3 0f 1e fa          	endbr64 
 564:	e8 00 00 00 00       	callq  569 <bnvm_read_compacted_summaries+0x9>
 569:	55                   	push   %rbp
 56a:	48 89 e5             	mov    %rsp,%rbp
 56d:	41 57                	push   %r15
 56f:	41 56                	push   %r14
 571:	49 89 fe             	mov    %rdi,%r14
 574:	41 55                	push   %r13
 576:	41 54                	push   %r12
 578:	53                   	push   %rbx
 579:	48 83 ec 10          	sub    $0x10,%rsp
    return sbi->byte_nsbi->byte_private;
 57d:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
}

static inline block_t f2fs_bnvm_get_valid_cp_addr(struct f2fs_sb_info *sbi)
{
    block_t sum_blk = F2FS_BYTE_NVM_PRIVATE(sbi)->cp_blkaddr;
    if (sbi->cur_cp_pack == 2)
 584:	83 bf 80 01 00 00 02 	cmpl   $0x2,0x180(%rdi)
	return (struct f2fs_super_block *)(sbi->raw_super);
}

static inline struct f2fs_checkpoint *F2FS_CKPT(struct f2fs_sb_info *sbi)
{
	return (struct f2fs_checkpoint *)(sbi->ckpt);
 58b:	4c 8b bf 78 01 00 00 	mov    0x178(%rdi),%r15
    return sbi->byte_nsbi->byte_private;
 592:	48 8b 90 08 01 00 00 	mov    0x108(%rax),%rdx
    block_t sum_blk = F2FS_BYTE_NVM_PRIVATE(sbi)->cp_blkaddr;
 599:	8b 42 20             	mov    0x20(%rdx),%eax
    if (sbi->cur_cp_pack == 2)
 59c:	75 06                	jne    5a4 <bnvm_read_compacted_summaries+0x44>
		sum_blk += sbi->blocks_per_seg;
 59e:	03 87 24 04 00 00    	add    0x424(%rdi),%eax
}

static inline block_t f2fs_bnvm_get_cp_ptr_sum(struct f2fs_sb_info *sbi)
{/* 获取nvm有效cp pack中的第一个summary blk块号 */
    block_t sum_blk = f2fs_bnvm_get_valid_cp_addr(sbi);
    sum_blk += le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_start_sum);
 5a4:	41 03 87 8c 00 00 00 	add    0x8c(%r15),%eax
 5ab:	45 31 c0             	xor    %r8d,%r8d
	memcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);

	/* 复制 sit journal，和nat journal 都在一个block上 */
	seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);
	memcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);
	offset = 2 * SUM_JOURNAL_SIZE;
 5ae:	41 bc f6 03 00 00    	mov    $0x3f6,%r12d
	kaddr = F2FS_BYTE_NVM_ADDR(sbi) + start * sbi->blocksize;
 5b4:	41 0f af 86 10 04 00 	imul   0x410(%r14),%eax
 5bb:	00 
 5bc:	48 03 42 10          	add    0x10(%rdx),%rax
 5c0:	48 89 c3             	mov    %rax,%rbx
/*
 * inline functions
 */
static inline struct curseg_info *CURSEG_I(struct f2fs_sb_info *sbi, int type)
{
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
 5c3:	49 8b 46 68          	mov    0x68(%r14),%rax
 5c7:	48 8b 13             	mov    (%rbx),%rdx
 5ca:	48 89 de             	mov    %rbx,%rsi
	memcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);
 5cd:	48 8b 40 18          	mov    0x18(%rax),%rax
 5d1:	48 8b 40 50          	mov    0x50(%rax),%rax
 5d5:	48 89 10             	mov    %rdx,(%rax)
 5d8:	48 8d 78 08          	lea    0x8(%rax),%rdi
 5dc:	48 8b 8b f3 01 00 00 	mov    0x1f3(%rbx),%rcx
 5e3:	48 8d 93 fb 01 00 00 	lea    0x1fb(%rbx),%rdx
 5ea:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
 5ee:	48 89 88 f3 01 00 00 	mov    %rcx,0x1f3(%rax)
 5f5:	48 29 f8             	sub    %rdi,%rax
 5f8:	48 29 c6             	sub    %rax,%rsi
 5fb:	05 fb 01 00 00       	add    $0x1fb,%eax
 600:	c1 e8 03             	shr    $0x3,%eax
 603:	89 c1                	mov    %eax,%ecx
 605:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
 608:	48 89 d6             	mov    %rdx,%rsi
 60b:	49 8b 46 68          	mov    0x68(%r14),%rax
 60f:	48 8b 8b fb 01 00 00 	mov    0x1fb(%rbx),%rcx
	memcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);
 616:	48 8b 40 18          	mov    0x18(%rax),%rax
 61a:	48 8b 80 30 01 00 00 	mov    0x130(%rax),%rax
 621:	48 89 08             	mov    %rcx,(%rax)
 624:	48 8d 78 08          	lea    0x8(%rax),%rdi
 628:	48 8b 8b ee 03 00 00 	mov    0x3ee(%rbx),%rcx
 62f:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
 633:	48 89 88 f3 01 00 00 	mov    %rcx,0x1f3(%rax)
 63a:	48 29 f8             	sub    %rdi,%rax
 63d:	48 29 c6             	sub    %rax,%rsi
 640:	05 fb 01 00 00       	add    $0x1fb,%eax
 645:	c1 e8 03             	shr    $0x3,%eax
 648:	89 c1                	mov    %eax,%ecx
 64a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
 64d:	49 8b 46 68          	mov    0x68(%r14),%rax
	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
		unsigned short blk_off;
		unsigned int segno;

		seg_i = CURSEG_I(sbi, i);
		segno = le32_to_cpu(ckpt->cur_data_segno[i]);
 651:	43 8b 54 87 54       	mov    0x54(%r15,%r8,4),%edx
		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
		seg_i->next_segno = segno;	

		reset_curseg(sbi, i, 0);
 656:	44 89 c6             	mov    %r8d,%esi
 659:	4c 89 f7             	mov    %r14,%rdi
 65c:	4e 8d 2c c5 00 00 00 	lea    0x0(,%r8,8),%r13
 663:	00 
 664:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
 668:	4d 29 c5             	sub    %r8,%r13
 66b:	49 c1 e5 04          	shl    $0x4,%r13
 66f:	4c 03 68 18          	add    0x18(%rax),%r13
		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
 673:	43 0f b7 44 47 74    	movzwl 0x74(%r15,%r8,2),%eax
		seg_i->next_segno = segno;	
 679:	41 89 55 68          	mov    %edx,0x68(%r13)
		reset_curseg(sbi, i, 0);
 67d:	31 d2                	xor    %edx,%edx
		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);
 67f:	89 45 cc             	mov    %eax,-0x34(%rbp)
		reset_curseg(sbi, i, 0);
 682:	e8 00 00 00 00       	callq  687 <bnvm_read_compacted_summaries+0x127>
		seg_i->alloc_type = ckpt->alloc_type[i];
 687:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
		seg_i->next_blkoff = blk_off;
 68b:	8b 45 cc             	mov    -0x34(%rbp),%eax
		seg_i->alloc_type = ckpt->alloc_type[i];
 68e:	43 0f b6 94 07 b0 00 	movzbl 0xb0(%r15,%r8,1),%edx
 695:	00 00 
		seg_i->next_blkoff = blk_off;
 697:	66 41 89 45 60       	mov    %ax,0x60(%r13)
		seg_i->alloc_type = ckpt->alloc_type[i];
 69c:	41 88 55 58          	mov    %dl,0x58(%r13)
		if (seg_i->alloc_type == SSR)
 6a0:	80 fa 01             	cmp    $0x1,%dl
 6a3:	75 08                	jne    6ad <bnvm_read_compacted_summaries+0x14d>
			blk_off = sbi->blocks_per_seg;
 6a5:	41 0f b7 86 24 04 00 	movzwl 0x424(%r14),%eax
 6ac:	00 

		for ( j = 0; j < blk_off; j++)
 6ad:	0f b7 f0             	movzwl %ax,%esi
 6b0:	85 f6                	test   %esi,%esi
 6b2:	74 51                	je     705 <bnvm_read_compacted_summaries+0x1a5>
 6b4:	31 d2                	xor    %edx,%edx
		{
			struct f2fs_summary *s;
			s = (struct f2fs_summary *)(kaddr + offset);
			seg_i->sum_blk->entries[j] = *s;
 6b6:	48 63 ca             	movslq %edx,%rcx
 6b9:	48 8d 04 cd 00 00 00 	lea    0x0(,%rcx,8),%rax
 6c0:	00 
 6c1:	48 29 c8             	sub    %rcx,%rax
			s = (struct f2fs_summary *)(kaddr + offset);
 6c4:	49 63 cc             	movslq %r12d,%rcx
			seg_i->sum_blk->entries[j] = *s;
 6c7:	49 03 45 20          	add    0x20(%r13),%rax
 6cb:	8b 3c 0b             	mov    (%rbx,%rcx,1),%edi
 6ce:	89 38                	mov    %edi,(%rax)
 6d0:	0f b7 7c 0b 04       	movzwl 0x4(%rbx,%rcx,1),%edi
 6d5:	66 89 78 04          	mov    %di,0x4(%rax)
 6d9:	0f b6 4c 0b 06       	movzbl 0x6(%rbx,%rcx,1),%ecx
 6de:	88 48 06             	mov    %cl,0x6(%rax)
			offset += SUMMARY_SIZE;
			if (offset + SUMMARY_SIZE <= PAGE_SIZE -
 6e1:	41 8d 44 24 0e       	lea    0xe(%r12),%eax
			offset += SUMMARY_SIZE;
 6e6:	41 83 c4 07          	add    $0x7,%r12d
			if (offset + SUMMARY_SIZE <= PAGE_SIZE -
 6ea:	3d fb 0f 00 00       	cmp    $0xffb,%eax
 6ef:	76 0d                	jbe    6fe <bnvm_read_compacted_summaries+0x19e>
						SUM_FOOTER_SIZE)
				continue;
			kaddr += sbi->blocksize;
 6f1:	41 8b 86 10 04 00 00 	mov    0x410(%r14),%eax
			offset = 0;
 6f8:	45 31 e4             	xor    %r12d,%r12d
			kaddr += sbi->blocksize;
 6fb:	48 01 c3             	add    %rax,%rbx
		for ( j = 0; j < blk_off; j++)
 6fe:	83 c2 01             	add    $0x1,%edx
 701:	39 d6                	cmp    %edx,%esi
 703:	75 b1                	jne    6b6 <bnvm_read_compacted_summaries+0x156>
	for (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {
 705:	49 83 c0 01          	add    $0x1,%r8
 709:	49 83 f8 03          	cmp    $0x3,%r8
 70d:	0f 85 3a ff ff ff    	jne    64d <bnvm_read_compacted_summaries+0xed>
		}
	}
}
 713:	48 83 c4 10          	add    $0x10,%rsp
 717:	5b                   	pop    %rbx
 718:	41 5c                	pop    %r12
 71a:	41 5d                	pop    %r13
 71c:	41 5e                	pop    %r14
 71e:	41 5f                	pop    %r15
 720:	5d                   	pop    %rbp
 721:	c3                   	retq   
 722:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
 729:	00 00 00 00 
 72d:	0f 1f 00             	nopl   (%rax)

0000000000000730 <bnvm_read_normal_summaries>:
/**
 * 获取bnvm上的 normal summaries
 * 参考 read_normal_summaries
*/
int bnvm_read_normal_summaries(struct f2fs_sb_info *sbi, int type)
{
 730:	f3 0f 1e fa          	endbr64 
 734:	e8 00 00 00 00       	callq  739 <bnvm_read_normal_summaries+0x9>
 739:	55                   	push   %rbp
 73a:	48 89 e5             	mov    %rsp,%rbp
 73d:	41 57                	push   %r15
 73f:	41 89 f7             	mov    %esi,%r15d
 742:	41 56                	push   %r14
 744:	41 55                	push   %r13
 746:	49 89 fd             	mov    %rdi,%r13
 749:	41 54                	push   %r12
 74b:	53                   	push   %rbx
 74c:	48 83 ec 28          	sub    $0x28,%rsp
 750:	48 8b 87 78 01 00 00 	mov    0x178(%rdi),%rax
	struct f2fs_summary_block *sum;
	struct curseg_info *curseg;
	unsigned short blk_off;
	unsigned int segno = 0;
	block_t blk_addr = 0;
	if (IS_DATASEG(type)) {
 757:	48 8b 8f 50 07 00 00 	mov    0x750(%rdi),%rcx
 75e:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
 764:	48 8b b1 08 01 00 00 	mov    0x108(%rcx),%rsi
 76b:	83 e2 21             	and    $0x21,%edx
 76e:	48 8b 7e 10          	mov    0x10(%rsi),%rdi
 772:	41 83 ff 02          	cmp    $0x2,%r15d
 776:	0f 8f e5 01 00 00    	jg     961 <bnvm_read_normal_summaries+0x231>
		segno = le32_to_cpu(ckpt->cur_data_segno[type]);
 77c:	4d 63 c7             	movslq %r15d,%r8
 77f:	44 8b 76 20          	mov    0x20(%rsi),%r14d
		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -
 783:	42 0f b7 4c 40 74    	movzwl 0x74(%rax,%r8,2),%ecx
		segno = le32_to_cpu(ckpt->cur_data_segno[type]);
 789:	42 8b 5c 80 54       	mov    0x54(%rax,%r8,4),%ebx
		blk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -
 78e:	66 89 4d d6          	mov    %cx,-0x2a(%rbp)

static inline bool __is_set_ckpt_flags(struct f2fs_checkpoint *cp, unsigned int f)
{
	unsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);

	return ckpt_flags & f;
 792:	41 8b 8d 80 01 00 00 	mov    0x180(%r13),%ecx
	return (reason & (CP_UMOUNT | CP_FASTBOOT));
}

static inline bool __exist_node_summaries(struct f2fs_sb_info *sbi)
{
	return (is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG) ||
 799:	85 d2                	test   %edx,%edx
 79b:	0f 84 91 01 00 00    	je     932 <bnvm_read_normal_summaries+0x202>
    if (sbi->cur_cp_pack == 2)
 7a1:	83 f9 02             	cmp    $0x2,%ecx
 7a4:	0f 84 08 02 00 00    	je     9b2 <bnvm_read_normal_summaries+0x282>
 */
static inline block_t f2fs_bnvm_get_sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)
{
    return f2fs_bnvm_get_valid_cp_addr(sbi) +
            le32_to_cpu(F2FS_CKPT(sbi)->cp_pack_total_block_count)
                    - (base + 1) + type;/* 这个1是cp pack尾部的cp super block */
 7aa:	8b 88 88 00 00 00    	mov    0x88(%rax),%ecx
 7b0:	41 8d 4c 0f f9       	lea    -0x7(%r15,%rcx,1),%ecx
 7b5:	41 01 ce             	add    %ecx,%r14d
		else
			//TODO：2022年3月5日 SSA还没搬运上来，这里假设搬运上来了
			/* blk_addr = 0，表示直接从ssa区域获取数据 */
			blk_addr = 0;		
	}
	if (blk_addr)/* 从CP中获取 */
 7b8:	45 85 f6             	test   %r14d,%r14d
 7bb:	0f 84 8d 01 00 00    	je     94e <bnvm_read_normal_summaries+0x21e>
    return sbi->byte_nsbi->byte_private->virt_addr + blk_addr * sbi->blocksize;
 7c1:	45 0f af b5 10 04 00 	imul   0x410(%r13),%r14d
 7c8:	00 
 7c9:	49 01 fe             	add    %rdi,%r14
		sum = (struct f2fs_summary_block *)F2FS_BYTE_NVM_BLK_TO_ADDR(sbi, blk_addr);
	else/* 从SSA获取 */
		sum = f2fs_bnvm_get_sum_blk(sbi, segno);
	
	if (IS_NODESEG(type)){
 7cc:	41 83 ff 02          	cmp    $0x2,%r15d
 7d0:	7e 32                	jle    804 <bnvm_read_normal_summaries+0xd4>
 7d2:	85 d2                	test   %edx,%edx
 7d4:	0f 84 e4 01 00 00    	je     9be <bnvm_read_normal_summaries+0x28e>
		if (__exist_node_summaries(sbi)) {// 如果没有宕机的情况下，将每一个ns重新置为0
			struct f2fs_summary *ns = &sum->entries[0];
			int i;
			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
 7da:	41 8b b5 24 04 00 00 	mov    0x424(%r13),%esi
			struct f2fs_summary *ns = &sum->entries[0];
 7e1:	4c 89 f2             	mov    %r14,%rdx
			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
 7e4:	31 c9                	xor    %ecx,%ecx
 7e6:	85 f6                	test   %esi,%esi
 7e8:	74 1a                	je     804 <bnvm_read_normal_summaries+0xd4>
				ns->version = 0;
				ns->ofs_in_node = 0;
 7ea:	31 ff                	xor    %edi,%edi
				ns->version = 0;
 7ec:	c6 42 04 00          	movb   $0x0,0x4(%rdx)
			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
 7f0:	83 c1 01             	add    $0x1,%ecx
 7f3:	48 83 c2 07          	add    $0x7,%rdx
				ns->ofs_in_node = 0;
 7f7:	66 89 7a fe          	mov    %di,-0x2(%rdx)
			for (i = 0; i < sbi->blocks_per_seg; i++, ns++) {
 7fb:	41 39 8d 24 04 00 00 	cmp    %ecx,0x424(%r13)
 802:	77 e6                	ja     7ea <bnvm_read_normal_summaries+0xba>
 804:	4e 8d 24 c5 00 00 00 	lea    0x0(,%r8,8),%r12
 80b:	00 
 80c:	49 8b 55 68          	mov    0x68(%r13),%rdx
 810:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 814:	4d 29 c4             	sub    %r8,%r12
 817:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
 81b:	49 c1 e4 04          	shl    $0x4,%r12
 81f:	4c 03 62 18          	add    0x18(%rdx),%r12
		}
	}
	/* 剩下的步骤就是复制summary block数据到curseg */
	/* set uncompleted segment to curseg */
	curseg = CURSEG_I(sbi, type);
	mutex_lock(&curseg->curseg_mutex);
 823:	4c 89 e7             	mov    %r12,%rdi
 826:	e8 00 00 00 00       	callq  82b <bnvm_read_normal_summaries+0xfb>

	/* update journal info */
	down_write(&curseg->journal_rwsem);
 82b:	4d 8d 54 24 28       	lea    0x28(%r12),%r10
 830:	4c 89 d7             	mov    %r10,%rdi
 833:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
 837:	e8 00 00 00 00       	callq  83c <bnvm_read_normal_summaries+0x10c>
 83c:	49 8b 4c 24 50       	mov    0x50(%r12),%rcx
 841:	49 8b 96 00 0e 00 00 	mov    0xe00(%r14),%rdx
 848:	49 8d b6 00 0e 00 00 	lea    0xe00(%r14),%rsi
 84f:	48 89 11             	mov    %rdx,(%rcx)
 852:	49 8d 96 fb 0f 00 00 	lea    0xffb(%r14),%rdx
 859:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
 85d:	49 8b be f3 0f 00 00 	mov    0xff3(%r14),%rdi
 864:	48 89 b9 f3 01 00 00 	mov    %rdi,0x1f3(%rcx)
 86b:	48 8d 79 08          	lea    0x8(%rcx),%rdi
 86f:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
 873:	48 29 f9             	sub    %rdi,%rcx
 876:	48 29 ce             	sub    %rcx,%rsi
 879:	81 c1 fb 01 00 00    	add    $0x1fb,%ecx
 87f:	c1 e9 03             	shr    $0x3,%ecx
 882:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	memcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);
	up_write(&curseg->journal_rwsem);
 885:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
 889:	4c 89 d7             	mov    %r10,%rdi
 88c:	e8 00 00 00 00       	callq  891 <bnvm_read_normal_summaries+0x161>
 891:	49 8b 4c 24 20       	mov    0x20(%r12),%rcx
 896:	49 8b 36             	mov    (%r14),%rsi
 899:	48 8d 79 08          	lea    0x8(%rcx),%rdi
 89d:	48 89 31             	mov    %rsi,(%rcx)
 8a0:	49 8b b6 f8 0d 00 00 	mov    0xdf8(%r14),%rsi
 8a7:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
 8ab:	48 89 b1 f8 0d 00 00 	mov    %rsi,0xdf8(%rcx)
 8b2:	48 29 f9             	sub    %rdi,%rcx
 8b5:	4c 89 f6             	mov    %r14,%rsi
 8b8:	48 29 ce             	sub    %rcx,%rsi
 8bb:	81 c1 00 0e 00 00    	add    $0xe00,%ecx
 8c1:	c1 e9 03             	shr    $0x3,%ecx
 8c4:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)

	memcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);
	memcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 0);
 8c7:	4c 89 ef             	mov    %r13,%rdi
 8ca:	41 8b b6 fb 0f 00 00 	mov    0xffb(%r14),%esi
 8d1:	49 8b 4c 24 20       	mov    0x20(%r12),%rcx
 8d6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 8da:	89 b1 fb 0f 00 00    	mov    %esi,0xffb(%rcx)
 8e0:	44 89 fe             	mov    %r15d,%esi
 8e3:	0f b6 52 04          	movzbl 0x4(%rdx),%edx
 8e7:	88 91 ff 0f 00 00    	mov    %dl,0xfff(%rcx)
 8ed:	31 d2                	xor    %edx,%edx
	curseg->next_segno = segno;
 8ef:	41 89 5c 24 68       	mov    %ebx,0x68(%r12)
	reset_curseg(sbi, type, 0);
 8f4:	e8 00 00 00 00       	callq  8f9 <bnvm_read_normal_summaries+0x1c9>
	curseg->alloc_type = ckpt->alloc_type[type];/* LFS或SSR */
 8f9:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
 8fd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	curseg->next_blkoff = blk_off;
	mutex_unlock(&curseg->curseg_mutex);
 901:	4c 89 e7             	mov    %r12,%rdi
	curseg->alloc_type = ckpt->alloc_type[type];/* LFS或SSR */
 904:	42 0f b6 84 00 b0 00 	movzbl 0xb0(%rax,%r8,1),%eax
 90b:	00 00 
 90d:	41 88 44 24 58       	mov    %al,0x58(%r12)
	curseg->next_blkoff = blk_off;
 912:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
 916:	66 41 89 44 24 60    	mov    %ax,0x60(%r12)
	mutex_unlock(&curseg->curseg_mutex);
 91c:	e8 00 00 00 00       	callq  921 <bnvm_read_normal_summaries+0x1f1>

	return 0;
}
 921:	31 c0                	xor    %eax,%eax
 923:	48 83 c4 28          	add    $0x28,%rsp
 927:	5b                   	pop    %rbx
 928:	41 5c                	pop    %r12
 92a:	41 5d                	pop    %r13
 92c:	41 5e                	pop    %r14
 92e:	41 5f                	pop    %r15
 930:	5d                   	pop    %rbp
 931:	c3                   	retq   
    if (sbi->cur_cp_pack == 2)
 932:	83 f9 02             	cmp    $0x2,%ecx
 935:	74 72                	je     9a9 <bnvm_read_normal_summaries+0x279>
                    - (base + 1) + type;/* 这个1是cp pack尾部的cp super block */
 937:	8b 88 88 00 00 00    	mov    0x88(%rax),%ecx
 93d:	41 8d 4c 0f fc       	lea    -0x4(%r15,%rcx,1),%ecx
 942:	41 01 ce             	add    %ecx,%r14d
	if (blk_addr)/* 从CP中获取 */
 945:	45 85 f6             	test   %r14d,%r14d
 948:	0f 85 73 fe ff ff    	jne    7c1 <bnvm_read_normal_summaries+0x91>
}

inline struct f2fs_summary_block * f2fs_bnvm_get_sum_blk(struct f2fs_sb_info *sbi, 
										unsigned int segno)
{
	unsigned int block_addr = F2FS_BYTE_NVM_PRIVATE(sbi)->ssa_blkaddr + segno;
 94e:	44 8b 76 2c          	mov    0x2c(%rsi),%r14d
 952:	41 01 de             	add    %ebx,%r14d
	return (struct f2fs_summary_block *)(F2FS_BYTE_NVM_ADDR(sbi)
									+ block_addr * F2FS_BLKSIZE);
 955:	41 c1 e6 0c          	shl    $0xc,%r14d
	return (struct f2fs_summary_block *)(F2FS_BYTE_NVM_ADDR(sbi)
 959:	49 01 fe             	add    %rdi,%r14
 95c:	e9 6b fe ff ff       	jmpq   7cc <bnvm_read_normal_summaries+0x9c>
		segno = le32_to_cpu(ckpt->cur_node_segno[type -
 961:	41 8d 4f fd          	lea    -0x3(%r15),%ecx
 965:	4d 63 c7             	movslq %r15d,%r8
 968:	48 63 c9             	movslq %ecx,%rcx
 96b:	8b 5c 88 24          	mov    0x24(%rax,%rcx,4),%ebx
		blk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -
 96f:	0f b7 4c 48 44       	movzwl 0x44(%rax,%rcx,2),%ecx
 974:	66 89 4d d6          	mov    %cx,-0x2a(%rbp)
 978:	85 d2                	test   %edx,%edx
 97a:	74 d2                	je     94e <bnvm_read_normal_summaries+0x21e>
    if (sbi->cur_cp_pack == 2)
 97c:	41 83 bd 80 01 00 00 	cmpl   $0x2,0x180(%r13)
 983:	02 
    block_t sum_blk = F2FS_BYTE_NVM_PRIVATE(sbi)->cp_blkaddr;
 984:	44 8b 76 20          	mov    0x20(%rsi),%r14d
    if (sbi->cur_cp_pack == 2)
 988:	74 16                	je     9a0 <bnvm_read_normal_summaries+0x270>
                    - (base + 1) + type;/* 这个1是cp pack尾部的cp super block */
 98a:	8b 88 88 00 00 00    	mov    0x88(%rax),%ecx
 990:	4d 63 c7             	movslq %r15d,%r8
 993:	41 8d 4c 0f f9       	lea    -0x7(%r15,%rcx,1),%ecx
 998:	41 01 ce             	add    %ecx,%r14d
 99b:	e9 18 fe ff ff       	jmpq   7b8 <bnvm_read_normal_summaries+0x88>
		sum_blk += sbi->blocks_per_seg;
 9a0:	45 03 b5 24 04 00 00 	add    0x424(%r13),%r14d
 9a7:	eb e1                	jmp    98a <bnvm_read_normal_summaries+0x25a>
 9a9:	45 03 b5 24 04 00 00 	add    0x424(%r13),%r14d
 9b0:	eb 85                	jmp    937 <bnvm_read_normal_summaries+0x207>
 9b2:	45 03 b5 24 04 00 00 	add    0x424(%r13),%r14d
 9b9:	e9 ec fd ff ff       	jmpq   7aa <bnvm_read_normal_summaries+0x7a>
			f2fs_restore_node_summary(sbi, segno, sum);
 9be:	4c 89 f2             	mov    %r14,%rdx
 9c1:	89 de                	mov    %ebx,%esi
 9c3:	4c 89 ef             	mov    %r13,%rdi
 9c6:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
 9ca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 9ce:	e8 00 00 00 00       	callq  9d3 <bnvm_read_normal_summaries+0x2a3>
 9d3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 9d7:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
 9db:	e9 24 fe ff ff       	jmpq   804 <bnvm_read_normal_summaries+0xd4>

00000000000009e0 <f2fs_bnvm_move_nat>:
{
 9e0:	f3 0f 1e fa          	endbr64 
 9e4:	e8 00 00 00 00       	callq  9e9 <f2fs_bnvm_move_nat+0x9>
 9e9:	55                   	push   %rbp
}
 9ea:	31 c0                	xor    %eax,%eax
{
 9ec:	48 89 e5             	mov    %rsp,%rbp
}
 9ef:	5d                   	pop    %rbp
 9f0:	c3                   	retq   
 9f1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
 9f8:	00 00 00 00 
 9fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000000a00 <f2fs_bnvm_get_raw_super>:
{
 a00:	f3 0f 1e fa          	endbr64 
    return sbi->byte_nsbi->byte_private->virt_addr;
 a04:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
 a0b:	48 8b 90 08 01 00 00 	mov    0x108(%rax),%rdx
									* F2FS_BLKSIZE);
 a12:	8b 42 18             	mov    0x18(%rdx),%eax
 a15:	c1 e0 0c             	shl    $0xc,%eax
	return (struct nvm_super_block *)(F2FS_BYTE_NVM_ADDR(sbi) 
 a18:	48 03 42 10          	add    0x10(%rdx),%rax
}
 a1c:	c3                   	retq   
 a1d:	0f 1f 00             	nopl   (%rax)

0000000000000a20 <f2fs_bnvm_get_nat_entry>:
{	/* ZN：原理看 current_nat_addr ()函数，另外nid是全局的node号 */
 a20:	f3 0f 1e fa          	endbr64 
	pgoff_t block_off= NAT_BLOCK_OFFSET(nid);
 a24:	89 f2                	mov    %esi,%edx
		(block_off & (sbi->blocks_per_seg - 1)));//ZN：减去多乘的段内偏移
 a26:	44 8b 8f 24 04 00 00 	mov    0x424(%rdi),%r9d
	pgoff_t block_off= NAT_BLOCK_OFFSET(nid);
 a2d:	48 69 d2 21 01 12 20 	imul   $0x20120121,%rdx,%rdx
 a34:	48 89 d0             	mov    %rdx,%rax
 a37:	89 f2                	mov    %esi,%edx
 a39:	48 c1 e8 20          	shr    $0x20,%rax
 a3d:	29 c2                	sub    %eax,%edx
 a3f:	d1 ea                	shr    %edx
 a41:	01 c2                	add    %eax,%edx
    return sbi->byte_nsbi->byte_private;
 a43:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
	if (f2fs_test_bit(block_off, nm_i->nat_bitmap))
 a4a:	48 8b 7f 58          	mov    0x58(%rdi),%rdi
	pgoff_t block_off= NAT_BLOCK_OFFSET(nid);
 a4e:	41 89 d0             	mov    %edx,%r8d

static inline int f2fs_test_bit(unsigned int nr, char *addr)
{
	int mask;

	addr += (nr >> 3);
 a51:	c1 ea 0b             	shr    $0xb,%edx
 a54:	4c 8b 90 08 01 00 00 	mov    0x108(%rax),%r10
 a5b:	41 c1 e8 08          	shr    $0x8,%r8d
 a5f:	44 89 c1             	mov    %r8d,%ecx
	block_addr = (pgoff_t)(F2FS_BYTE_NVM_PRIVATE(sbi)->nat_blkaddr +
 a62:	41 8b 42 28          	mov    0x28(%r10),%eax
 a66:	48 8d 04 48          	lea    (%rax,%rcx,2),%rax
		(block_off & (sbi->blocks_per_seg - 1)));//ZN：减去多乘的段内偏移
 a6a:	41 8d 49 ff          	lea    -0x1(%r9),%ecx
 a6e:	44 21 c1             	and    %r8d,%ecx
	block_addr = (pgoff_t)(F2FS_BYTE_NVM_PRIVATE(sbi)->nat_blkaddr +
 a71:	48 29 c8             	sub    %rcx,%rax
 a74:	89 d1                	mov    %edx,%ecx
	mask = 1 << (7 - (nr & 0x07));
	return mask & *addr;
 a76:	48 8b 97 f0 00 00 00 	mov    0xf0(%rdi),%rdx
 a7d:	0f be 3c 0a          	movsbl (%rdx,%rcx,1),%edi
	mask = 1 << (7 - (nr & 0x07));
 a81:	44 89 c1             	mov    %r8d,%ecx
 a84:	ba 01 00 00 00       	mov    $0x1,%edx
 a89:	f7 d1                	not    %ecx
 a8b:	83 e1 07             	and    $0x7,%ecx
 a8e:	d3 e2                	shl    %cl,%edx
		block_addr += sbi->blocks_per_seg;//ZN：检查bit_map如果在副本段上，则又要加上一段的偏移
 a90:	44 89 c9             	mov    %r9d,%ecx
 a93:	48 01 c1             	add    %rax,%rcx
 a96:	85 d7                	test   %edx,%edi
 a98:	48 0f 45 c1          	cmovne %rcx,%rax
	return &nat_blk->entries[nid % NAT_ENTRY_PER_BLOCK];
 a9c:	41 69 d0 c7 01 00 00 	imul   $0x1c7,%r8d,%edx
									+ block_addr * F2FS_BLKSIZE);
 aa3:	48 c1 e0 0c          	shl    $0xc,%rax
	return &nat_blk->entries[nid % NAT_ENTRY_PER_BLOCK];
 aa7:	29 d6                	sub    %edx,%esi
 aa9:	48 8d 14 f6          	lea    (%rsi,%rsi,8),%rdx
 aad:	48 01 d0             	add    %rdx,%rax
 ab0:	49 03 42 10          	add    0x10(%r10),%rax
}
 ab4:	c3                   	retq   
 ab5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
 abc:	00 00 00 00 

0000000000000ac0 <f2fs_bnvm_get_sit_entry>:
{   /* ZN：原理看 current_sit_addr ()函数，另外start是全局的segment号 */
 ac0:	f3 0f 1e fa          	endbr64 
	return (struct sit_info *)(SM_I(sbi)->sit_info);
 ac4:	48 8b 47 68          	mov    0x68(%rdi),%rax
    unsigned int block_off = SIT_BLOCK_OFFSET(segno);
 ac8:	89 f2                	mov    %esi,%edx
 aca:	4c 8b 08             	mov    (%rax),%r9
 acd:	48 69 c2 9f 12 e4 29 	imul   $0x29e4129f,%rdx,%rax
	return mask & *addr;
 ad4:	4d 8b 51 18          	mov    0x18(%r9),%r10
 ad8:	48 c1 e8 20          	shr    $0x20,%rax
 adc:	48 89 c1             	mov    %rax,%rcx
 adf:	89 f0                	mov    %esi,%eax
 ae1:	29 c8                	sub    %ecx,%eax
 ae3:	d1 e8                	shr    %eax
 ae5:	01 c8                	add    %ecx,%eax
 ae7:	48 8b 8f 50 07 00 00 	mov    0x750(%rdi),%rcx
 aee:	41 89 c0             	mov    %eax,%r8d
	addr += (nr >> 3);
 af1:	c1 e8 08             	shr    $0x8,%eax
 af4:	48 8b b9 08 01 00 00 	mov    0x108(%rcx),%rdi
 afb:	41 c1 e8 05          	shr    $0x5,%r8d
	return mask & *addr;
 aff:	41 0f be 04 02       	movsbl (%r10,%rax,1),%eax
    unsigned int block_addr = F2FS_BYTE_NVM_PRIVATE(sbi)->sit_blkaddr 
 b04:	8b 4f 24             	mov    0x24(%rdi),%ecx
 b07:	44 01 c1             	add    %r8d,%ecx
	mask = 1 << (7 - (nr & 0x07));
 b0a:	41 f7 d0             	not    %r8d
 b0d:	41 83 e0 07          	and    $0x7,%r8d
	if (f2fs_test_bit(block_off, sit_i->sit_bitmap))
 b11:	44 0f a3 c0          	bt     %r8d,%eax
 b15:	73 04                	jae    b1b <f2fs_bnvm_get_sit_entry+0x5b>
		block_addr += sit_i->sit_blocks;   
 b17:	41 03 49 0c          	add    0xc(%r9),%ecx
    return &sit_blk->entries[segno % SIT_ENTRY_PER_BLOCK];
 b1b:	48 69 c2 9f 12 e4 29 	imul   $0x29e4129f,%rdx,%rax
                                    + block_addr * F2FS_BLKSIZE);
 b22:	c1 e1 0c             	shl    $0xc,%ecx
    return &sit_blk->entries[segno % SIT_ENTRY_PER_BLOCK];
 b25:	48 c1 e8 20          	shr    $0x20,%rax
 b29:	48 89 c2             	mov    %rax,%rdx
 b2c:	89 f0                	mov    %esi,%eax
 b2e:	29 d0                	sub    %edx,%eax
 b30:	d1 e8                	shr    %eax
 b32:	01 d0                	add    %edx,%eax
 b34:	c1 e8 05             	shr    $0x5,%eax
 b37:	6b c0 37             	imul   $0x37,%eax,%eax
 b3a:	29 c6                	sub    %eax,%esi
 b3c:	48 8d 04 f6          	lea    (%rsi,%rsi,8),%rax
 b40:	48 8d 04 86          	lea    (%rsi,%rax,4),%rax
 b44:	48 8d 04 41          	lea    (%rcx,%rax,2),%rax
 b48:	48 03 47 10          	add    0x10(%rdi),%rax
}
 b4c:	c3                   	retq   
 b4d:	0f 1f 00             	nopl   (%rax)

0000000000000b50 <f2fs_bnvm_get_sum_blk>:
{
 b50:	f3 0f 1e fa          	endbr64 
 b54:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
 b5b:	48 8b 90 08 01 00 00 	mov    0x108(%rax),%rdx
	unsigned int block_addr = F2FS_BYTE_NVM_PRIVATE(sbi)->ssa_blkaddr + segno;
 b62:	8b 42 2c             	mov    0x2c(%rdx),%eax
 b65:	01 f0                	add    %esi,%eax
									+ block_addr * F2FS_BLKSIZE);
 b67:	c1 e0 0c             	shl    $0xc,%eax
	return (struct f2fs_summary_block *)(F2FS_BYTE_NVM_ADDR(sbi)
 b6a:	48 03 42 10          	add    0x10(%rdx),%rax
}
 b6e:	c3                   	retq   

Disassembly of section .text.unlikely:

0000000000000000 <f2fs_move_cp_to_bnvm.cold>:
		new_ckpt = f2fs_bnvm_get_cp_ptr(sbi, sbi->cur_cp_pack);
   0:	8b 87 80 01 00 00    	mov    0x180(%rdi),%eax
    if (cp_pack_no == 1)
   6:	83 f8 01             	cmp    $0x1,%eax
   9:	75 5b                	jne    66 <f2fs_move_cp_to_bnvm.cold+0x66>
    return sbi->byte_nsbi->byte_private->virt_addr;
   b:	48 8b 82 08 01 00 00 	mov    0x108(%rdx),%rax
                                     + F2FS_BYTE_NVM_PRIVATE(sbi)->cp_blkaddr * F2FS_BLKSIZE);
  12:	44 8b 68 20          	mov    0x20(%rax),%r13d
  16:	41 c1 e5 0c          	shl    $0xc,%r13d
        return (struct f2fs_checkpoint *)(F2FS_BYTE_NVM_ADDR(sbi)
  1a:	4c 03 68 10          	add    0x10(%rax),%r13
	return le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);
  1e:	48 8b 43 10          	mov    0x10(%rbx),%rax
	printk(KERN_INFO"ZN trap: 3");
  22:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	memcpy(dst, src, cp_blks * sbi->blocksize);
  29:	45 0f b6 e4          	movzbl %r12b,%r12d
  2d:	44 8b b0 80 06 00 00 	mov    0x680(%rax),%r14d
	printk(KERN_INFO"ZN trap: 3");
  34:	e8 00 00 00 00       	callq  39 <f2fs_move_cp_to_bnvm.cold+0x39>
	memcpy(dst, src, cp_blks * sbi->blocksize);
  39:	41 0f b6 fd          	movzbl %r13b,%edi
  3d:	4c 89 e6             	mov    %r12,%rsi
	unsigned int cp_blks = 1 + __cp_payload(sbi);
  40:	41 8d 56 01          	lea    0x1(%r14),%edx
	memcpy(dst, src, cp_blks * sbi->blocksize);
  44:	0f af 93 10 04 00 00 	imul   0x410(%rbx),%edx
  4b:	e8 00 00 00 00       	callq  50 <f2fs_move_cp_to_bnvm.cold+0x50>
	kfree(src);
  50:	4c 89 e7             	mov    %r12,%rdi
  53:	e8 00 00 00 00       	callq  58 <f2fs_move_cp_to_bnvm.cold+0x58>
	sbi->ckpt = new_ckpt;
  58:	4c 89 ab 78 01 00 00 	mov    %r13,0x178(%rbx)
	return 0;
  5f:	31 c0                	xor    %eax,%eax
  61:	e9 00 00 00 00       	jmpq   66 <f2fs_move_cp_to_bnvm.cold+0x66>
    else if (cp_pack_no == 2)
  66:	83 f8 02             	cmp    $0x2,%eax
  69:	75 1c                	jne    87 <f2fs_move_cp_to_bnvm.cold+0x87>
    return sbi->byte_nsbi->byte_private->virt_addr;
  6b:	48 8b 82 08 01 00 00 	mov    0x108(%rdx),%rax
                                    + (F2FS_BYTE_NVM_PRIVATE(sbi)->cp_blkaddr + sbi->blocks_per_seg) 
  72:	44 8b af 24 04 00 00 	mov    0x424(%rdi),%r13d
  79:	44 03 68 20          	add    0x20(%rax),%r13d
                                    * F2FS_BLKSIZE);  
  7d:	41 c1 e5 0c          	shl    $0xc,%r13d
        return (struct f2fs_checkpoint *)(F2FS_BYTE_NVM_ADDR(sbi)
  81:	4c 03 68 10          	add    0x10(%rax),%r13
  85:	eb 97                	jmp    1e <f2fs_move_cp_to_bnvm.cold+0x1e>
        return NULL;      
  87:	45 31 ed             	xor    %r13d,%r13d
  8a:	eb 92                	jmp    1e <f2fs_move_cp_to_bnvm.cold+0x1e>

000000000000008c <print_byte_nvm_mount_parameter>:

/* 
 * 测试函数
 */
void print_byte_nvm_mount_parameter(struct f2fs_sb_info *sbi){
  8c:	f3 0f 1e fa          	endbr64 
  90:	e8 00 00 00 00       	callq  95 <print_byte_nvm_mount_parameter+0x9>
  95:	55                   	push   %rbp
  96:	48 89 e5             	mov    %rsp,%rbp
  99:	53                   	push   %rbx
	struct nvm_sb_info *byte_nsbi = F2FS_BYTE_NSB_I(sbi);
	struct nvm_super_block *byte_nsb = byte_nsbi->nsb;
  9a:	48 8b 87 50 07 00 00 	mov    0x750(%rdi),%rax
	printk(KERN_INFO"ZN trap: =================================");
  a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	struct nvm_super_block *byte_nsb = byte_nsbi->nsb;
  a8:	48 8b 18             	mov    (%rax),%rbx
	printk(KERN_INFO"ZN trap: =================================");
  ab:	e8 00 00 00 00       	callq  b0 <print_byte_nvm_mount_parameter+0x24>
	printk(KERN_INFO"ZN trap:      byte nvm mount parameter    ");
  b0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  b7:	e8 00 00 00 00       	callq  bc <print_byte_nvm_mount_parameter+0x30>
	printk(KERN_INFO"ZN trap: mpt_blkaddr 		%d",byte_nsb->mpt_blkaddr);
  bc:	8b 73 10             	mov    0x10(%rbx),%esi
  bf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  c6:	e8 00 00 00 00       	callq  cb <print_byte_nvm_mount_parameter+0x3f>
	printk(KERN_INFO"ZN trap: ra_blkaddr 		%d",byte_nsb->ra_blkaddr);
  cb:	8b 73 14             	mov    0x14(%rbx),%esi
  ce:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  d5:	e8 00 00 00 00       	callq  da <print_byte_nvm_mount_parameter+0x4e>
	printk(KERN_INFO"ZN trap: main_blkaddr		%d",byte_nsb->main_blkaddr);
  da:	8b 73 18             	mov    0x18(%rbx),%esi
  dd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  e4:	e8 00 00 00 00       	callq  e9 <print_byte_nvm_mount_parameter+0x5d>
	printk(KERN_INFO"ZN trap: ra_blk_nums		%d",byte_nsb->ra_blk_nums);
  e9:	8b 73 24             	mov    0x24(%rbx),%esi
  ec:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  f3:	e8 00 00 00 00       	callq  f8 <print_byte_nvm_mount_parameter+0x6c>
	printk(KERN_INFO"ZN trap: main_first_segno	%d",byte_nsb->main_first_segno);
  f8:	8b 73 28             	mov    0x28(%rbx),%esi
  fb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 102:	e8 00 00 00 00       	callq  107 <print_byte_nvm_mount_parameter+0x7b>
	printk(KERN_INFO"ZN trap: main_segment_nums	%d",byte_nsb->main_segment_nums);
 107:	8b 73 2c             	mov    0x2c(%rbx),%esi
 10a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 111:	e8 00 00 00 00       	callq  116 <print_byte_nvm_mount_parameter+0x8a>
	printk(KERN_INFO"ZN trap: mpt_ver_map_bits	%d",byte_nsb->mpt_ver_map_bits);
 116:	8b 73 34             	mov    0x34(%rbx),%esi
 119:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 120:	e8 00 00 00 00       	callq  125 <print_byte_nvm_mount_parameter+0x99>
	printk(KERN_INFO"ZN trap: mpt_entries		%d",byte_nsb->mpt_entries);
 125:	8b 73 38             	mov    0x38(%rbx),%esi
 128:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 12f:	e8 00 00 00 00       	callq  134 <print_byte_nvm_mount_parameter+0xa8>
	printk(KERN_INFO"ZN trap: =================================");
 134:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 13b:	e8 00 00 00 00       	callq  140 <print_byte_nvm_mount_parameter+0xb4>
}
 140:	5b                   	pop    %rbx
 141:	5d                   	pop    %rbp
 142:	c3                   	retq   

0000000000000143 <print_raw_info>:

void print_raw_info(struct f2fs_sb_info *sbi) {
 143:	f3 0f 1e fa          	endbr64 
 147:	e8 00 00 00 00       	callq  14c <print_raw_info+0x9>
 14c:	55                   	push   %rbp
 14d:	48 89 e5             	mov    %rsp,%rbp
 150:	53                   	push   %rbx
 151:	48 89 fb             	mov    %rdi,%rbx
	printk(KERN_INFO"ZN trap: =================================");
 154:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 15b:	e8 00 00 00 00       	callq  160 <print_raw_info+0x1d>
	printk(KERN_INFO"ZN trap:      meta area parameter    ");
 160:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 167:	e8 00 00 00 00       	callq  16c <print_raw_info+0x29>
	printk(KERN_INFO"ZN trap: segment0_blkaddr		%d",sbi->raw_super->segment0_blkaddr);
 16c:	48 8b 43 10          	mov    0x10(%rbx),%rax
 170:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 177:	8b 70 48             	mov    0x48(%rax),%esi
 17a:	e8 00 00 00 00       	callq  17f <print_raw_info+0x3c>
	printk(KERN_INFO"ZN trap: cp_blkaddr			%d",sbi->raw_super->cp_blkaddr);
 17f:	48 8b 43 10          	mov    0x10(%rbx),%rax
 183:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 18a:	8b 70 4c             	mov    0x4c(%rax),%esi
 18d:	e8 00 00 00 00       	callq  192 <print_raw_info+0x4f>
	printk(KERN_INFO"ZN trap: segment_count_ckpt	%d",sbi->raw_super->segment_count_ckpt);
 192:	48 8b 43 10          	mov    0x10(%rbx),%rax
 196:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 19d:	8b 70 34             	mov    0x34(%rax),%esi
 1a0:	e8 00 00 00 00       	callq  1a5 <print_raw_info+0x62>
	printk(KERN_INFO"ZN trap: nat_blkaddr			%d",sbi->raw_super->nat_blkaddr);
 1a5:	48 8b 43 10          	mov    0x10(%rbx),%rax
 1a9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1b0:	8b 70 54             	mov    0x54(%rax),%esi
 1b3:	e8 00 00 00 00       	callq  1b8 <print_raw_info+0x75>
	printk(KERN_INFO"ZN trap: segment_count_nat		%d",sbi->raw_super->segment_count_nat);
 1b8:	48 8b 43 10          	mov    0x10(%rbx),%rax
 1bc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1c3:	8b 70 3c             	mov    0x3c(%rax),%esi
 1c6:	e8 00 00 00 00       	callq  1cb <print_raw_info+0x88>
	printk(KERN_INFO"ZN trap: sit_blkaddr			%d",sbi->raw_super->sit_blkaddr);
 1cb:	48 8b 43 10          	mov    0x10(%rbx),%rax
 1cf:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1d6:	8b 70 50             	mov    0x50(%rax),%esi
 1d9:	e8 00 00 00 00       	callq  1de <print_raw_info+0x9b>
	printk(KERN_INFO"ZN trap: segment_count_sit		%d",sbi->raw_super->segment_count_sit);
 1de:	48 8b 43 10          	mov    0x10(%rbx),%rax
 1e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1e9:	8b 70 38             	mov    0x38(%rax),%esi
 1ec:	e8 00 00 00 00       	callq  1f1 <print_raw_info+0xae>
	printk(KERN_INFO"ZN trap: ssa_blkaddr			%d",sbi->raw_super->ssa_blkaddr);
 1f1:	48 8b 43 10          	mov    0x10(%rbx),%rax
 1f5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1fc:	8b 70 58             	mov    0x58(%rax),%esi
 1ff:	e8 00 00 00 00       	callq  204 <print_raw_info+0xc1>
	printk(KERN_INFO"ZN trap: segment_count_ssa		%d",sbi->raw_super->segment_count_ssa);
 204:	48 8b 43 10          	mov    0x10(%rbx),%rax
 208:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 20f:	8b 70 40             	mov    0x40(%rax),%esi
 212:	e8 00 00 00 00       	callq  217 <print_raw_info+0xd4>
	printk(KERN_INFO"ZN trap: =================================");
 217:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 21e:	e8 00 00 00 00       	callq  223 <print_raw_info+0xe0>
}
 223:	5b                   	pop    %rbx
 224:	5d                   	pop    %rbp
 225:	c3                   	retq   

0000000000000226 <print_ckpt_info>:

void print_ckpt_info(struct f2fs_sb_info *sbi) {
 226:	f3 0f 1e fa          	endbr64 
 22a:	e8 00 00 00 00       	callq  22f <print_ckpt_info+0x9>
 22f:	55                   	push   %rbp
 230:	48 89 e5             	mov    %rsp,%rbp
 233:	41 54                	push   %r12
 235:	53                   	push   %rbx
	return (struct f2fs_checkpoint *)(sbi->ckpt);
 236:	48 8b 9f 78 01 00 00 	mov    0x178(%rdi),%rbx
	struct f2fs_checkpoint *cp = F2FS_CKPT(sbi);
	if(!sbi->ckpt){
 23d:	48 85 db             	test   %rbx,%rbx
 240:	75 11                	jne    253 <print_ckpt_info+0x2d>
		printk(KERN_INFO"ZN trap: checkpoint is not ready");
 242:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 249:	e8 00 00 00 00       	callq  24e <print_ckpt_info+0x28>
		return ;
 24e:	e9 d1 00 00 00       	jmpq   324 <print_ckpt_info+0xfe>
 253:	49 89 fc             	mov    %rdi,%r12
	}
	printk(KERN_INFO"ZN trap: =================================");
 256:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 25d:	e8 00 00 00 00       	callq  262 <print_ckpt_info+0x3c>
	printk(KERN_INFO"ZN trap:      checkpoint information    ");
 262:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 269:	e8 00 00 00 00       	callq  26e <print_ckpt_info+0x48>
	return le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);
 26e:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	printk(KERN_INFO"ZN trap: cp_blks						%d",1 + __cp_payload(sbi));
 273:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 27a:	8b b0 80 06 00 00    	mov    0x680(%rax),%esi
 280:	ff c6                	inc    %esi
 282:	e8 00 00 00 00       	callq  287 <print_ckpt_info+0x61>
 287:	49 8b 44 24 10       	mov    0x10(%r12),%rax
	printk(KERN_INFO"ZN trap: cp_pay_load 					%d",__cp_payload(sbi));/* ZN：cp super block的附加块数量 */
 28c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 293:	8b b0 80 06 00 00    	mov    0x680(%rax),%esi
 299:	e8 00 00 00 00       	callq  29e <print_ckpt_info+0x78>
	printk(KERN_INFO"ZN trap: cur_cp_pack					%d",sbi->cur_cp_pack);
 29e:	41 8b b4 24 80 01 00 	mov    0x180(%r12),%esi
 2a5:	00 
 2a6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2ad:	e8 00 00 00 00       	callq  2b2 <print_ckpt_info+0x8c>
	printk(KERN_INFO"ZN trap: user_block_count				%d",cp->user_block_count);
 2b2:	48 8b 73 08          	mov    0x8(%rbx),%rsi
 2b6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2bd:	e8 00 00 00 00       	callq  2c2 <print_ckpt_info+0x9c>
	printk(KERN_INFO"ZN trap: valid_block_count				%d",cp->valid_block_count);
 2c2:	48 8b 73 10          	mov    0x10(%rbx),%rsi
 2c6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2cd:	e8 00 00 00 00       	callq  2d2 <print_ckpt_info+0xac>
	printk(KERN_INFO"ZN trap: free_segment_count			%d",cp->free_segment_count);
 2d2:	8b 73 20             	mov    0x20(%rbx),%esi
 2d5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2dc:	e8 00 00 00 00       	callq  2e1 <print_ckpt_info+0xbb>
	printk(KERN_INFO"ZN trap: cp_pack_total_block_count		%d",cp->cp_pack_total_block_count);
 2e1:	8b b3 88 00 00 00    	mov    0x88(%rbx),%esi
 2e7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2ee:	e8 00 00 00 00       	callq  2f3 <print_ckpt_info+0xcd>
	printk(KERN_INFO"ZN trap: cp_pack_start_sum				%d",cp->cp_pack_start_sum);
 2f3:	8b b3 8c 00 00 00    	mov    0x8c(%rbx),%esi
 2f9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 300:	e8 00 00 00 00       	callq  305 <print_ckpt_info+0xdf>
	printk(KERN_INFO"ZN trap: alloc_type[CURSEG_HOT_DATA]	%d",cp->alloc_type[CURSEG_HOT_DATA]);
 305:	0f b6 b3 b0 00 00 00 	movzbl 0xb0(%rbx),%esi
 30c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 313:	e8 00 00 00 00       	callq  318 <print_ckpt_info+0xf2>
	printk(KERN_INFO"ZN trap: =================================");		
 318:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 31f:	e8 00 00 00 00       	callq  324 <print_ckpt_info+0xfe>
 324:	5b                   	pop    %rbx
 325:	41 5c                	pop    %r12
 327:	5d                   	pop    %rbp
 328:	c3                   	retq   
