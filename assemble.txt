
nvm.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <read_line.constprop.0>:
	//提交读操作
	submit_bio_wait(read_bio);
	bio_put(read_bio);
}

static char *read_line(char *buf, int buf_len, struct file *fp) {
       0:	e8 00 00 00 00       	callq  5 <read_line.constprop.0+0x5>
       5:	55                   	push   %rbp
       6:	48 89 e5             	mov    %rsp,%rbp
       9:	41 56                	push   %r14
       b:	41 55                	push   %r13
       d:	49 89 fd             	mov    %rdi,%r13
      10:	41 54                	push   %r12
      12:	49 89 f4             	mov    %rsi,%r12
      15:	53                   	push   %rbx

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
      16:	65 48 8b 1c 25 00 00 	mov    %gs:0x0,%rbx
      1d:	00 00 
	int ret;
	int i = 0;
	mm_segment_t fs;

	fs = get_fs();
      1f:	4c 8b b3 18 13 00 00 	mov    0x1318(%rbx),%r14

#define get_ds()	(KERNEL_DS)
#define get_fs()	(current->thread.addr_limit)
static inline void set_fs(mm_segment_t fs)
{
	current->thread.addr_limit = fs;
      26:	48 c7 83 18 13 00 00 	movq   $0xffffffffffffffff,0x1318(%rbx)
      2d:	ff ff ff ff 
 */
static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
      31:	f0 80 4b 03 80       	lock orb $0x80,0x3(%rbx)
	set_fs(KERNEL_DS);
	ret = fp->f_op->read(fp, buf, buf_len, &(fp->f_pos));
      36:	48 8b 46 28          	mov    0x28(%rsi),%rax
      3a:	48 8d 4e 68          	lea    0x68(%rsi),%rcx
      3e:	ba 00 01 00 00       	mov    $0x100,%edx
      43:	48 89 fe             	mov    %rdi,%rsi
      46:	4c 89 e7             	mov    %r12,%rdi
      49:	48 8b 40 10          	mov    0x10(%rax),%rax
      4d:	e8 00 00 00 00       	callq  52 <read_line.constprop.0+0x52>
      52:	4c 89 b3 18 13 00 00 	mov    %r14,0x1318(%rbx)
      59:	f0 80 4b 03 80       	lock orb $0x80,0x3(%rbx)
	set_fs(fs);

	if (ret <= 0)
      5e:	85 c0                	test   %eax,%eax
      60:	7e 4f                	jle    b1 <read_line.constprop.0+0xb1>
      62:	41 89 c0             	mov    %eax,%r8d
      65:	4c 89 e9             	mov    %r13,%rcx
	int i = 0;
      68:	31 d2                	xor    %edx,%edx
		return NULL;

	while (buf[i++] != '\n' && i < ret);
      6a:	83 c2 01             	add    $0x1,%edx
      6d:	80 39 0a             	cmpb   $0xa,(%rcx)
      70:	40 0f 95 c7          	setne  %dil
      74:	41 39 d0             	cmp    %edx,%r8d
      77:	40 0f 9f c6          	setg   %sil
      7b:	48 83 c1 01          	add    $0x1,%rcx
      7f:	40 84 f7             	test   %sil,%dil
      82:	75 e6                	jne    6a <read_line.constprop.0+0x6a>

	if (i < ret) {
      84:	39 d0                	cmp    %edx,%eax
      86:	7e 0c                	jle    94 <read_line.constprop.0+0x94>
		fp->f_pos += i - ret;
      88:	89 d3                	mov    %edx,%ebx
      8a:	29 c3                	sub    %eax,%ebx
      8c:	48 63 c3             	movslq %ebx,%rax
      8f:	49 01 44 24 68       	add    %rax,0x68(%r12)
	}

	if (i < buf_len) {
      94:	81 fa ff 00 00 00    	cmp    $0xff,%edx
      9a:	7f 09                	jg     a5 <read_line.constprop.0+0xa5>
		buf[i] = 0;
      9c:	48 63 d2             	movslq %edx,%rdx
      9f:	41 c6 44 15 00 00    	movb   $0x0,0x0(%r13,%rdx,1)
	}
	return buf;
}
      a5:	5b                   	pop    %rbx
      a6:	4c 89 e8             	mov    %r13,%rax
      a9:	41 5c                	pop    %r12
      ab:	41 5d                	pop    %r13
      ad:	41 5e                	pop    %r14
      af:	5d                   	pop    %rbp
      b0:	c3                   	retq   
		return NULL;
      b1:	45 31 ed             	xor    %r13d,%r13d
}
      b4:	5b                   	pop    %rbx
      b5:	41 5c                	pop    %r12
      b7:	4c 89 e8             	mov    %r13,%rax
      ba:	41 5d                	pop    %r13
      bc:	41 5e                	pop    %r14
      be:	5d                   	pop    %rbp
      bf:	c3                   	retq   

00000000000000c0 <update_aqu_sz>:
unsigned int write_ratio;
unsigned int pre_tot_ticks_nvm, pre_tot_ticks_ssd;
unsigned int util_nvm, util_ssd;

//定期调用
int update_aqu_sz(void *data) {
      c0:	f3 0f 1e fa          	endbr64 
      c4:	e8 00 00 00 00       	callq  c9 <update_aqu_sz+0x9>
      c9:	55                   	push   %rbp
      ca:	48 89 e5             	mov    %rsp,%rbp
      cd:	41 57                	push   %r15
      cf:	49 89 ff             	mov    %rdi,%r15
      d2:	41 56                	push   %r14
      d4:	41 55                	push   %r13
      d6:	41 54                	push   %r12
      d8:	53                   	push   %rbx
      d9:	48 81 ec b0 01 00 00 	sub    $0x1b0,%rsp
      e0:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
      e7:	00 00 
      e9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      ed:	31 c0                	xor    %eax,%eax
	unsigned long wr_merges, rd_sec_or_wr_ios, wr_sec;
	unsigned long dc_ios, dc_merges, dc_sec, dc_ticks;
	unsigned int major, minor;
	unsigned int ssd_rq_ticks = 0, nvm_rq_ticks = 0;
	struct f2fs_sb_info *sbi = (struct f2fs_sb_info *) data;
	struct block_device *ssd_bdev = sbi->sb->s_bdev;
      ef:	48 8b 07             	mov    (%rdi),%rax
	unsigned int ssd_rq_ticks = 0, nvm_rq_ticks = 0;
      f2:	c7 85 30 fe ff ff 00 	movl   $0x0,-0x1d0(%rbp)
      f9:	00 00 00 
      fc:	c7 85 34 fe ff ff 00 	movl   $0x0,-0x1cc(%rbp)
     103:	00 00 00 
	struct block_device *ssd_bdev = sbi->sb->s_bdev;
     106:	4c 8b b0 d0 00 00 00 	mov    0xd0(%rax),%r14
	struct block_device *nvm_bdev = sbi->nsbi->nbdev;
     10d:	48 8b 87 48 07 00 00 	mov    0x748(%rdi),%rax
     114:	48 8b 40 08          	mov    0x8(%rax),%rax
     118:	48 89 85 28 fe ff ff 	mov    %rax,-0x1d8(%rbp)
	//当间隔时间内没有读写数据时，认为读写各占50%
	unsigned int now_wr = 0, now_rd = 0;
	unsigned int delt = 0;
	static int util_count = 0;

	while (!kthread_should_stop()) {
     11f:	e8 00 00 00 00       	callq  124 <update_aqu_sz+0x64>
     124:	84 c0                	test   %al,%al
     126:	75 32                	jne    15a <update_aqu_sz+0x9a>
	raw_spin_lock_bh(&lock->rlock);
}

static __always_inline int spin_trylock(spinlock_t *lock)
{
	return raw_spin_trylock(&lock->rlock);
     128:	49 8b 87 48 07 00 00 	mov    0x748(%r15),%rax
     12f:	48 8d b8 00 01 00 00 	lea    0x100(%rax),%rdi
     136:	e8 00 00 00 00       	callq  13b <update_aqu_sz+0x7b>
		if (!spin_trylock(&sbi->nsbi->aqusz_lock)) {
     13b:	85 c0                	test   %eax,%eax
     13d:	75 3f                	jne    17e <update_aqu_sz+0xbe>
			pre_ssd_rq_ticks = ssd_rq_ticks;
		if (nvm_aqu_sz != 0)
			pre_nvm_rq_ticks = nvm_rq_ticks;
		spin_unlock(&sbi->nsbi->aqusz_lock);
		next:
		SLEEP_MILLI_SEC(LOAD_COLLECT_INTERVAL)
     13f:	bf ee 02 00 00       	mov    $0x2ee,%edi
     144:	e8 00 00 00 00       	callq  149 <update_aqu_sz+0x89>
     149:	48 89 c7             	mov    %rax,%rdi
     14c:	48 85 c0             	test   %rax,%rax
     14f:	7f f3                	jg     144 <update_aqu_sz+0x84>
	while (!kthread_should_stop()) {
     151:	e8 00 00 00 00       	callq  156 <update_aqu_sz+0x96>
     156:	84 c0                	test   %al,%al
     158:	74 ce                	je     128 <update_aqu_sz+0x68>
	}

	return 0;
     15a:	31 c0                	xor    %eax,%eax
}
     15c:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     160:	65 48 33 1c 25 28 00 	xor    %gs:0x28,%rbx
     167:	00 00 
     169:	0f 85 92 02 00 00    	jne    401 <update_aqu_sz+0x341>
     16f:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
     173:	5b                   	pop    %rbx
     174:	41 5c                	pop    %r12
     176:	41 5d                	pop    %r13
     178:	41 5e                	pop    %r14
     17a:	41 5f                	pop    %r15
     17c:	5d                   	pop    %rbp
     17d:	c3                   	retq   
		if ((fp = filp_open(DISKSTATS, O_RDONLY, 0644)) == NULL)
     17e:	ba a4 01 00 00       	mov    $0x1a4,%edx
     183:	31 f6                	xor    %esi,%esi
     185:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     18c:	e8 00 00 00 00       	callq  191 <update_aqu_sz+0xd1>
     191:	49 89 c5             	mov    %rax,%r13
     194:	48 85 c0             	test   %rax,%rax
     197:	0f 84 5a 02 00 00    	je     3f7 <update_aqu_sz+0x337>
		util_count %= (UTIL_COLLECT_INTERVAL / LOAD_COLLECT_INTERVAL);
     19d:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 1a7 <update_aqu_sz+0xe7>
     1a4:	00 00 00 
		now_rd = 0;
     1a7:	45 31 e4             	xor    %r12d,%r12d
		now_wr = 0;
     1aa:	31 db                	xor    %ebx,%ebx
		while (read_line(line, sizeof(line), fp) != NULL) {
     1ac:	4c 89 ee             	mov    %r13,%rsi
     1af:	48 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%rdi
     1b6:	e8 45 fe ff ff       	callq  0 <read_line.constprop.0>
     1bb:	48 85 c0             	test   %rax,%rax
     1be:	0f 84 93 01 00 00    	je     357 <update_aqu_sz+0x297>
			sscanf(line, "%u %u %s %lu %lu %lu %lu %lu %lu %lu %u %u %u %u %lu %lu %lu %lu",
     1c4:	48 8d 85 a8 fe ff ff 	lea    -0x158(%rbp),%rax
     1cb:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     1d2:	48 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%rdi
     1d9:	50                   	push   %rax
     1da:	48 8d 85 a0 fe ff ff 	lea    -0x160(%rbp),%rax
     1e1:	4c 8d 8d 58 fe ff ff 	lea    -0x1a8(%rbp),%r9
     1e8:	50                   	push   %rax
     1e9:	48 8d 85 98 fe ff ff 	lea    -0x168(%rbp),%rax
     1f0:	4c 8d 85 b0 fe ff ff 	lea    -0x150(%rbp),%r8
     1f7:	50                   	push   %rax
     1f8:	48 8d 85 90 fe ff ff 	lea    -0x170(%rbp),%rax
     1ff:	48 8d 8d 54 fe ff ff 	lea    -0x1ac(%rbp),%rcx
     206:	50                   	push   %rax
     207:	48 8d 85 48 fe ff ff 	lea    -0x1b8(%rbp),%rax
     20e:	48 8d 95 50 fe ff ff 	lea    -0x1b0(%rbp),%rdx
     215:	50                   	push   %rax
     216:	48 8d 85 44 fe ff ff 	lea    -0x1bc(%rbp),%rax
     21d:	50                   	push   %rax
     21e:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
     225:	50                   	push   %rax
     226:	48 8d 85 4c fe ff ff 	lea    -0x1b4(%rbp),%rax
     22d:	50                   	push   %rax
     22e:	48 8d 85 88 fe ff ff 	lea    -0x178(%rbp),%rax
     235:	50                   	push   %rax
     236:	48 8d 85 78 fe ff ff 	lea    -0x188(%rbp),%rax
     23d:	50                   	push   %rax
     23e:	48 8d 85 70 fe ff ff 	lea    -0x190(%rbp),%rax
     245:	50                   	push   %rax
     246:	48 8d 85 68 fe ff ff 	lea    -0x198(%rbp),%rax
     24d:	50                   	push   %rax
     24e:	48 8d 85 80 fe ff ff 	lea    -0x180(%rbp),%rax
     255:	50                   	push   %rax
     256:	48 8d 85 60 fe ff ff 	lea    -0x1a0(%rbp),%rax
     25d:	50                   	push   %rax
     25e:	e8 00 00 00 00       	callq  263 <update_aqu_sz+0x1a3>
			if (strcmp(ssd_bdev->bd_disk->disk_name, dev_name) == 0) {
     263:	49 8b 86 80 00 00 00 	mov    0x80(%r14),%rax
     26a:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
     271:	48 83 c4 70          	add    $0x70,%rsp
     275:	48 8d 78 0c          	lea    0xc(%rax),%rdi
     279:	e8 00 00 00 00       	callq  27e <update_aqu_sz+0x1be>
     27e:	85 c0                	test   %eax,%eax
     280:	75 54                	jne    2d6 <update_aqu_sz+0x216>
				ssd_rq_ticks = rq_ticks;
     282:	8b 85 48 fe ff ff    	mov    -0x1b8(%rbp),%eax
				if (util_count == 0) {
     288:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 28e <update_aqu_sz+0x1ce>
				now_wr += wr_sec;
     28e:	03 9d 88 fe ff ff    	add    -0x178(%rbp),%ebx
				now_rd += rd_sec_or_wr_ios;
     294:	44 03 a5 80 fe ff ff 	add    -0x180(%rbp),%r12d
				ssd_rq_ticks = rq_ticks;
     29b:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%rbp)
				if (util_count == 0) {
     2a1:	85 d2                	test   %edx,%edx
     2a3:	0f 85 03 ff ff ff    	jne    1ac <update_aqu_sz+0xec>
					util_ssd = 100 * (tot_ticks - pre_tot_ticks_ssd) / UTIL_COLLECT_INTERVAL;
     2a9:	8b 95 44 fe ff ff    	mov    -0x1bc(%rbp),%edx
     2af:	89 d0                	mov    %edx,%eax
     2b1:	2b 05 00 00 00 00    	sub    0x0(%rip),%eax        # 2b7 <update_aqu_sz+0x1f7>
					pre_tot_ticks_ssd = tot_ticks;
     2b7:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 2bd <update_aqu_sz+0x1fd>
					util_ssd = 100 * (tot_ticks - pre_tot_ticks_ssd) / UTIL_COLLECT_INTERVAL;
     2bd:	6b c0 64             	imul   $0x64,%eax,%eax
     2c0:	48 69 c0 f1 19 76 05 	imul   $0x57619f1,%rax,%rax
     2c7:	48 c1 e8 26          	shr    $0x26,%rax
     2cb:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 2d1 <update_aqu_sz+0x211>
					pre_tot_ticks_ssd = tot_ticks;
     2d1:	e9 d6 fe ff ff       	jmpq   1ac <update_aqu_sz+0xec>
			} else if (strcmp(nvm_bdev->bd_disk->disk_name, dev_name) == 0) {
     2d6:	48 8b 85 28 fe ff ff 	mov    -0x1d8(%rbp),%rax
     2dd:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
     2e4:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
     2eb:	48 8d 78 0c          	lea    0xc(%rax),%rdi
     2ef:	48 89 85 38 fe ff ff 	mov    %rax,-0x1c8(%rbp)
     2f6:	e8 00 00 00 00       	callq  2fb <update_aqu_sz+0x23b>
     2fb:	85 c0                	test   %eax,%eax
     2fd:	0f 85 a9 fe ff ff    	jne    1ac <update_aqu_sz+0xec>
				nvm_rq_ticks = rq_ticks;
     303:	8b 85 48 fe ff ff    	mov    -0x1b8(%rbp),%eax
				now_wr += wr_sec;
     309:	03 9d 88 fe ff ff    	add    -0x178(%rbp),%ebx
				now_rd += rd_sec_or_wr_ios;
     30f:	44 03 a5 80 fe ff ff 	add    -0x180(%rbp),%r12d
				nvm_rq_ticks = rq_ticks;
     316:	89 85 30 fe ff ff    	mov    %eax,-0x1d0(%rbp)
				if (util_count == 0) {
     31c:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 322 <update_aqu_sz+0x262>
     322:	85 c0                	test   %eax,%eax
     324:	0f 85 82 fe ff ff    	jne    1ac <update_aqu_sz+0xec>
					util_nvm = 100 * (tot_ticks - pre_tot_ticks_nvm) / UTIL_COLLECT_INTERVAL;
     32a:	8b 95 44 fe ff ff    	mov    -0x1bc(%rbp),%edx
     330:	89 d0                	mov    %edx,%eax
     332:	2b 05 00 00 00 00    	sub    0x0(%rip),%eax        # 338 <update_aqu_sz+0x278>
					pre_tot_ticks_nvm = tot_ticks;
     338:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 33e <update_aqu_sz+0x27e>
					util_nvm = 100 * (tot_ticks - pre_tot_ticks_nvm) / UTIL_COLLECT_INTERVAL;
     33e:	6b c0 64             	imul   $0x64,%eax,%eax
     341:	48 69 c0 f1 19 76 05 	imul   $0x57619f1,%rax,%rax
     348:	48 c1 e8 26          	shr    $0x26,%rax
     34c:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 352 <update_aqu_sz+0x292>
					pre_tot_ticks_nvm = tot_ticks;
     352:	e9 55 fe ff ff       	jmpq   1ac <update_aqu_sz+0xec>
		filp_close(fp, NULL);
     357:	31 f6                	xor    %esi,%esi
     359:	4c 89 ef             	mov    %r13,%rdi
     35c:	e8 00 00 00 00       	callq  361 <update_aqu_sz+0x2a1>
		delt = now_wr + now_rd - pre_rd_sec - pre_wr_sec;
     361:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 367 <update_aqu_sz+0x2a7>
     367:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # 36d <update_aqu_sz+0x2ad>
     36d:	44 89 e2             	mov    %r12d,%edx
     370:	01 f0                	add    %esi,%eax
     372:	29 c2                	sub    %eax,%edx
			write_ratio = 50;
     374:	b8 32 00 00 00       	mov    $0x32,%eax
		if (delt == 0) {
     379:	89 d1                	mov    %edx,%ecx
     37b:	01 d9                	add    %ebx,%ecx
     37d:	74 0b                	je     38a <update_aqu_sz+0x2ca>
			write_ratio = 100 * (now_wr - pre_wr_sec) / delt;
     37f:	89 d8                	mov    %ebx,%eax
     381:	31 d2                	xor    %edx,%edx
     383:	29 f0                	sub    %esi,%eax
     385:	6b c0 64             	imul   $0x64,%eax,%eax
     388:	f7 f1                	div    %ecx
		pre_wr_sec = now_wr;
     38a:	89 1d 00 00 00 00    	mov    %ebx,0x0(%rip)        # 390 <update_aqu_sz+0x2d0>
		ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
     390:	8b 9d 34 fe ff ff    	mov    -0x1cc(%rbp),%ebx
     396:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 39c <update_aqu_sz+0x2dc>
		nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
     39c:	8b 85 30 fe ff ff    	mov    -0x1d0(%rbp),%eax
		pre_rd_sec = now_rd;
     3a2:	44 89 25 00 00 00 00 	mov    %r12d,0x0(%rip)        # 3a9 <update_aqu_sz+0x2e9>
		ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
     3a9:	89 da                	mov    %ebx,%edx
		nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
     3ab:	2b 05 00 00 00 00    	sub    0x0(%rip),%eax        # 3b1 <update_aqu_sz+0x2f1>
		ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
     3b1:	2b 15 00 00 00 00    	sub    0x0(%rip),%edx        # 3b7 <update_aqu_sz+0x2f7>
     3b7:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 3bd <update_aqu_sz+0x2fd>
		nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
     3bd:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 3c3 <update_aqu_sz+0x303>
		if (ssd_aqu_sz != 0)
     3c3:	85 d2                	test   %edx,%edx
     3c5:	74 06                	je     3cd <update_aqu_sz+0x30d>
			pre_ssd_rq_ticks = ssd_rq_ticks;
     3c7:	89 1d 00 00 00 00    	mov    %ebx,0x0(%rip)        # 3cd <update_aqu_sz+0x30d>
		if (nvm_aqu_sz != 0)
     3cd:	85 c0                	test   %eax,%eax
     3cf:	74 0c                	je     3dd <update_aqu_sz+0x31d>
			pre_nvm_rq_ticks = nvm_rq_ticks;
     3d1:	8b 85 30 fe ff ff    	mov    -0x1d0(%rbp),%eax
     3d7:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 3dd <update_aqu_sz+0x31d>
	arch_spin_unlock(&lock->raw_lock);
     3dd:	49 8b 87 48 07 00 00 	mov    0x748(%r15),%rax
     3e4:	48 8d b8 00 01 00 00 	lea    0x100(%rax),%rdi
	PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);
     3eb:	ff 14 25 00 00 00 00 	callq  *0x0
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
}
     3f2:	e9 48 fd ff ff       	jmpq   13f <update_aqu_sz+0x7f>
			return 1;
     3f7:	b8 01 00 00 00       	mov    $0x1,%eax
     3fc:	e9 5b fd ff ff       	jmpq   15c <update_aqu_sz+0x9c>
}
     401:	e8 00 00 00 00       	callq  406 <update_aqu_sz+0x346>
     406:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     40d:	00 00 00 

0000000000000410 <nvm_flush_mpt_pages>:
void nvm_flush_mpt_pages(struct f2fs_sb_info *sbi, int flush_all) {
     410:	f3 0f 1e fa          	endbr64 
     414:	e8 00 00 00 00       	callq  419 <nvm_flush_mpt_pages+0x9>
     419:	55                   	push   %rbp
     41a:	48 89 e5             	mov    %rsp,%rbp
     41d:	41 57                	push   %r15
     41f:	45 31 ff             	xor    %r15d,%r15d
     422:	41 56                	push   %r14
     424:	41 55                	push   %r13
     426:	41 89 f5             	mov    %esi,%r13d
     429:	41 54                	push   %r12
     42b:	53                   	push   %rbx
     42c:	48 89 fb             	mov    %rdi,%rbx
     42f:	48 83 ec 10          	sub    $0x10,%rsp
	struct nvm_sb_info *nsbi = sbi->nsbi;
     433:	4c 8b b7 48 07 00 00 	mov    0x748(%rdi),%r14
	raw_spin_lock(&lock->rlock);
     43a:	4d 8d 66 64          	lea    0x64(%r14),%r12
     43e:	4c 89 e7             	mov    %r12,%rdi
     441:	e8 00 00 00 00       	callq  446 <nvm_flush_mpt_pages+0x36>
	if (flush_all) {
     446:	31 c0                	xor    %eax,%eax
     448:	45 85 ed             	test   %r13d,%r13d
     44b:	74 23                	je     470 <nvm_flush_mpt_pages+0x60>
	while (mpt_pgoff != nsbi->mpt_dirty_map_bits) {
     44d:	41 3b 46 60          	cmp    0x60(%r14),%eax
     451:	0f 85 00 00 00 00    	jne    457 <nvm_flush_mpt_pages+0x47>
     457:	4c 89 e7             	mov    %r12,%rdi
     45a:	ff 14 25 00 00 00 00 	callq  *0x0
}
     461:	48 83 c4 10          	add    $0x10,%rsp
     465:	5b                   	pop    %rbx
     466:	41 5c                	pop    %r12
     468:	41 5d                	pop    %r13
     46a:	41 5e                	pop    %r14
     46c:	41 5f                	pop    %r15
     46e:	5d                   	pop    %rbp
     46f:	c3                   	retq   
		mpt_pgoff = find_next_bit(nsbi->mpt_dirty_map, nsbi->mpt_dirty_map_bits, 0);
     470:	41 8b 76 60          	mov    0x60(%r14),%esi
     474:	49 8b 7e 58          	mov    0x58(%r14),%rdi
     478:	31 d2                	xor    %edx,%edx
     47a:	e8 00 00 00 00       	callq  47f <nvm_flush_mpt_pages+0x6f>
     47f:	41 89 c7             	mov    %eax,%r15d
     482:	eb c9                	jmp    44d <nvm_flush_mpt_pages+0x3d>
     484:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     48b:	00 00 00 00 
     48f:	90                   	nop

0000000000000490 <nvm_flush_nsb_pages>:
void nvm_flush_nsb_pages(struct f2fs_sb_info *sbi, pgoff_t block_addr) {
     490:	f3 0f 1e fa          	endbr64 
     494:	e8 00 00 00 00       	callq  499 <nvm_flush_nsb_pages+0x9>
     499:	55                   	push   %rbp
     49a:	48 89 e5             	mov    %rsp,%rbp
     49d:	41 56                	push   %r14
     49f:	41 55                	push   %r13
     4a1:	41 54                	push   %r12
     4a3:	53                   	push   %rbx
	struct nvm_sb_info *nsbi = sbi->nsbi;
     4a4:	4c 8b b7 48 07 00 00 	mov    0x748(%rdi),%r14
	int mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;//mpt版本位图占用字节数
     4ab:	49 8b 06             	mov    (%r14),%rax
     4ae:	8b 48 34             	mov    0x34(%rax),%ecx
	int segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1;//segment位图占用字节数
     4b1:	8b 58 2c             	mov    0x2c(%rax),%ebx
	int mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;//mpt版本位图占用字节数
     4b4:	44 8d 61 ff          	lea    -0x1(%rcx),%r12d
	int segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1;//segment位图占用字节数
     4b8:	83 eb 01             	sub    $0x1,%ebx
	dst_page = f2fs_grab_meta_page(sbi, block_addr);
     4bb:	e8 00 00 00 00       	callq  4c0 <nvm_flush_nsb_pages+0x30>
	int mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;//mpt版本位图占用字节数
     4c0:	41 c1 ec 03          	shr    $0x3,%r12d
	int segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1;//segment位图占用字节数
     4c4:	c1 eb 03             	shr    $0x3,%ebx
	dst_page = f2fs_grab_meta_page(sbi, block_addr);
     4c7:	49 89 c5             	mov    %rax,%r13
 */
#include <linux/vmstat.h>

static __always_inline void *lowmem_page_address(const struct page *page)
{
	return page_to_virt(page);
     4ca:	48 89 c7             	mov    %rax,%rdi
		if (q_size < size)
			__read_overflow2();
	}
	if (p_size < size || q_size < size)
		fortify_panic(__func__);
	return __builtin_memcpy(p, q, size);
     4cd:	49 8b 06             	mov    (%r14),%rax
     4d0:	48 2b 3d 00 00 00 00 	sub    0x0(%rip),%rdi        # 4d7 <nvm_flush_nsb_pages+0x47>
     4d7:	48 c1 ff 06          	sar    $0x6,%rdi
	int mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;//mpt版本位图占用字节数
     4db:	41 83 c4 01          	add    $0x1,%r12d
	int segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1;//segment位图占用字节数
     4df:	83 c3 01             	add    $0x1,%ebx
     4e2:	48 8b 10             	mov    (%rax),%rdx
     4e5:	48 c1 e7 0c          	shl    $0xc,%rdi
     4e9:	48 03 3d 00 00 00 00 	add    0x0(%rip),%rdi        # 4f0 <nvm_flush_nsb_pages+0x60>
	memcpy(&dst_addr->map[0], nsbi->mpt_ver_map, mpt_ver_map_bytes);
     4f0:	48 83 c7 3c          	add    $0x3c,%rdi
     4f4:	48 89 57 c4          	mov    %rdx,-0x3c(%rdi)
     4f8:	48 8b 50 08          	mov    0x8(%rax),%rdx
     4fc:	48 89 57 cc          	mov    %rdx,-0x34(%rdi)
     500:	48 8b 50 10          	mov    0x10(%rax),%rdx
     504:	48 89 57 d4          	mov    %rdx,-0x2c(%rdi)
     508:	48 8b 50 18          	mov    0x18(%rax),%rdx
     50c:	48 89 57 dc          	mov    %rdx,-0x24(%rdi)
     510:	48 8b 50 20          	mov    0x20(%rax),%rdx
     514:	48 89 57 e4          	mov    %rdx,-0x1c(%rdi)
     518:	48 8b 50 28          	mov    0x28(%rax),%rdx
     51c:	48 89 57 ec          	mov    %rdx,-0x14(%rdi)
     520:	48 8b 50 30          	mov    0x30(%rax),%rdx
     524:	48 89 57 f4          	mov    %rdx,-0xc(%rdi)
     528:	48 8b 40 38          	mov    0x38(%rax),%rax
     52c:	4c 89 e2             	mov    %r12,%rdx
     52f:	48 89 47 fc          	mov    %rax,-0x4(%rdi)
     533:	49 8b 76 68          	mov    0x68(%r14),%rsi
     537:	e8 00 00 00 00       	callq  53c <nvm_flush_nsb_pages+0xac>
     53c:	49 8b 76 78          	mov    0x78(%r14),%rsi
	memcpy(&dst_addr->map[0] + mpt_ver_map_bytes, nsbi->segment_map, segment_map_bytes);
     540:	89 da                	mov    %ebx,%edx
     542:	48 89 c7             	mov    %rax,%rdi
     545:	4c 01 e7             	add    %r12,%rdi
     548:	e8 00 00 00 00       	callq  54d <nvm_flush_nsb_pages+0xbd>
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
     54d:	49 8b 55 08          	mov    0x8(%r13),%rdx
static inline struct page *compound_head(struct page *page)
{
	unsigned long head = READ_ONCE(page->compound_head);

	if (unlikely(head & 1))
		return (struct page *) (head - 1);
     551:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     555:	83 e2 01             	and    $0x1,%edx
     558:	49 0f 44 c5          	cmove  %r13,%rax
}

static __always_inline bool constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     55c:	48 8b 00             	mov    (%rax),%rax
	if (!PageDirty(dst_page))
     55f:	a8 10                	test   $0x10,%al
     561:	74 7a                	je     5dd <nvm_flush_nsb_pages+0x14d>
	kunmap(src);
}

static inline void f2fs_put_page(struct page *page, int unlock)
{
	if (!page)
     563:	4d 85 ed             	test   %r13,%r13
     566:	74 40                	je     5a8 <nvm_flush_nsb_pages+0x118>
     568:	49 8b 55 08          	mov    0x8(%r13),%rdx
     56c:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     570:	83 e2 01             	and    $0x1,%edx
     573:	49 0f 44 c5          	cmove  %r13,%rax
     577:	48 8b 00             	mov    (%rax),%rax
		return;

	if (unlock) {
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     57a:	a8 01                	test   $0x1,%al
     57c:	74 6c                	je     5ea <nvm_flush_nsb_pages+0x15a>
		unlock_page(page);
     57e:	4c 89 ef             	mov    %r13,%rdi
     581:	e8 00 00 00 00       	callq  586 <nvm_flush_nsb_pages+0xf6>
     586:	49 8b 45 08          	mov    0x8(%r13),%rax
     58a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
     58e:	a8 01                	test   $0x1,%al
     590:	4c 0f 45 ea          	cmovne %rdx,%r13
#include <linux/stringify.h>
#include <linux/types.h>

static __always_inline bool arch_static_branch(struct static_key *key, bool branch)
{
	asm_volatile_goto("1:"
     594:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 * returns true if the result is 0, or false for all other
 * cases.
 */
static __always_inline bool arch_atomic_dec_and_test(atomic_t *v)
{
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     599:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
	if (put_page_testzero(page))
     59e:	75 08                	jne    5a8 <nvm_flush_nsb_pages+0x118>
		__put_page(page);
     5a0:	4c 89 ef             	mov    %r13,%rdi
     5a3:	e8 00 00 00 00       	callq  5a8 <nvm_flush_nsb_pages+0x118>
}
     5a8:	5b                   	pop    %rbx
     5a9:	41 5c                	pop    %r12
     5ab:	41 5d                	pop    %r13
     5ad:	41 5e                	pop    %r14
     5af:	5d                   	pop    %rbp
     5b0:	c3                   	retq   
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     5b1:	49 8b 45 00          	mov    0x0(%r13),%rax
     5b5:	48 c1 e8 33          	shr    $0x33,%rax
     5b9:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     5bc:	83 f8 04             	cmp    $0x4,%eax
     5bf:	75 d8                	jne    599 <nvm_flush_nsb_pages+0x109>
	switch (page->pgmap->type) {
     5c1:	49 8b 45 08          	mov    0x8(%r13),%rax
     5c5:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     5cb:	83 e8 01             	sub    $0x1,%eax
     5ce:	83 f8 02             	cmp    $0x2,%eax
     5d1:	77 c6                	ja     599 <nvm_flush_nsb_pages+0x109>
		__put_devmap_managed_page(page);
     5d3:	4c 89 ef             	mov    %r13,%rdi
     5d6:	e8 00 00 00 00       	callq  5db <nvm_flush_nsb_pages+0x14b>
		return;
     5db:	eb cb                	jmp    5a8 <nvm_flush_nsb_pages+0x118>
		set_page_dirty(dst_page);
     5dd:	4c 89 ef             	mov    %r13,%rdi
     5e0:	e8 00 00 00 00       	callq  5e5 <nvm_flush_nsb_pages+0x155>
     5e5:	e9 79 ff ff ff       	jmpq   563 <nvm_flush_nsb_pages+0xd3>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     5ea:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     5ec:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
     5f0:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     5f3:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     5f7:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     5fe:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
     603:	e9 76 ff ff ff       	jmpq   57e <nvm_flush_nsb_pages+0xee>
     608:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     60f:	00 

0000000000000610 <nvm_move_lfu_count>:
void nvm_move_lfu_count(struct f2fs_sb_info *sbi) {
     610:	f3 0f 1e fa          	endbr64 
     614:	e8 00 00 00 00       	callq  619 <nvm_move_lfu_count+0x9>
	int i, clear_index, pre_index = sbi->nsbi->now_lfu_counter;
     619:	48 8b 8f 48 07 00 00 	mov    0x748(%rdi),%rcx
void nvm_move_lfu_count(struct f2fs_sb_info *sbi) {
     620:	55                   	push   %rbp
	int i, clear_index, pre_index = sbi->nsbi->now_lfu_counter;
     621:	4c 63 89 90 00 00 00 	movslq 0x90(%rcx),%r9
void nvm_move_lfu_count(struct f2fs_sb_info *sbi) {
     628:	48 89 e5             	mov    %rsp,%rbp
	if (pre_index == 0) {
     62b:	45 85 c9             	test   %r9d,%r9d
     62e:	74 5e                	je     68e <nvm_move_lfu_count+0x7e>
		clear_index = pre_index - 1;
     630:	45 8d 51 ff          	lea    -0x1(%r9),%r10d
     634:	45 89 d3             	mov    %r10d,%r11d
	for (i = 0; i < sbi->raw_super->segment_count_main; i++) {
     637:	48 8b 77 10          	mov    0x10(%rdi),%rsi
     63b:	8b 46 44             	mov    0x44(%rsi),%eax
     63e:	85 c0                	test   %eax,%eax
     640:	74 43                	je     685 <nvm_move_lfu_count+0x75>
			atomic_set(&sbi->nsbi->lfu_count[clear_index][i], 0);
     642:	4d 63 d2             	movslq %r10d,%r10
	for (i = 0; i < sbi->raw_super->segment_count_main; i++) {
     645:	31 d2                	xor    %edx,%edx
		if (atomic_read(&sbi->nsbi->lfu_count[pre_index][i]) == -1) {
     647:	49 83 c1 12          	add    $0x12,%r9
			atomic_set(&sbi->nsbi->lfu_count[clear_index][i], 0);
     64b:	49 83 c2 12          	add    $0x12,%r10
		if (atomic_read(&sbi->nsbi->lfu_count[pre_index][i]) == -1) {
     64f:	4e 8b 44 c9 08       	mov    0x8(%rcx,%r9,8),%r8
     654:	48 63 c2             	movslq %edx,%rax
     657:	48 c1 e0 02          	shl    $0x2,%rax
     65b:	49 01 c0             	add    %rax,%r8
     65e:	45 8b 00             	mov    (%r8),%r8d
     661:	41 83 f8 ff          	cmp    $0xffffffff,%r8d
     665:	74 16                	je     67d <nvm_move_lfu_count+0x6d>
			atomic_set(&sbi->nsbi->lfu_count[clear_index][i], 0);
     667:	4a 03 44 d1 08       	add    0x8(%rcx,%r10,8),%rax
static __always_inline void __write_once_size(volatile void *p, void *res, int size)
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
     66c:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	WRITE_ONCE(v->counter, i);
     672:	48 8b 8f 48 07 00 00 	mov    0x748(%rdi),%rcx
     679:	48 8b 77 10          	mov    0x10(%rdi),%rsi
	for (i = 0; i < sbi->raw_super->segment_count_main; i++) {
     67d:	83 c2 01             	add    $0x1,%edx
     680:	39 56 44             	cmp    %edx,0x44(%rsi)
     683:	77 ca                	ja     64f <nvm_move_lfu_count+0x3f>
	sbi->nsbi->now_lfu_counter = clear_index;
     685:	44 89 99 90 00 00 00 	mov    %r11d,0x90(%rcx)
}
     68c:	5d                   	pop    %rbp
     68d:	c3                   	retq   
     68e:	41 bb 03 00 00 00    	mov    $0x3,%r11d
		clear_index = LFU_LEVELS - 1;
     694:	41 ba 03 00 00 00    	mov    $0x3,%r10d
     69a:	eb 9b                	jmp    637 <nvm_move_lfu_count+0x27>
     69c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000006a0 <nvm_flush_lfu_pages>:
void nvm_flush_lfu_pages(struct f2fs_sb_info *sbi, int flag) {
     6a0:	f3 0f 1e fa          	endbr64 
     6a4:	e8 00 00 00 00       	callq  6a9 <nvm_flush_lfu_pages+0x9>
     6a9:	55                   	push   %rbp
     6aa:	48 89 e5             	mov    %rsp,%rbp
     6ad:	41 57                	push   %r15
     6af:	41 56                	push   %r14
     6b1:	41 55                	push   %r13
     6b3:	49 89 fd             	mov    %rdi,%r13
     6b6:	41 54                	push   %r12
     6b8:	53                   	push   %rbx
     6b9:	48 83 ec 10          	sub    $0x10,%rsp
	int lfu_blk_num = ((sbi->raw_super->segment_count_main + 1) * sizeof(atomic_t) - 1) / PAGE_SIZE + 1;
     6bd:	48 8b 47 10          	mov    0x10(%rdi),%rax
	struct nvm_sb_info *nsbi = sbi->nsbi;
     6c1:	4c 8b b7 48 07 00 00 	mov    0x748(%rdi),%r14
	int lfu_blk_num = ((sbi->raw_super->segment_count_main + 1) * sizeof(atomic_t) - 1) / PAGE_SIZE + 1;
     6c8:	8b 40 44             	mov    0x44(%rax),%eax
     6cb:	49 8b 16             	mov    (%r14),%rdx
     6ce:	83 c0 01             	add    $0x1,%eax
     6d1:	48 8d 04 85 ff ff ff 	lea    -0x1(,%rax,4),%rax
     6d8:	ff 
     6d9:	48 c1 e8 0c          	shr    $0xc,%rax
     6dd:	83 c0 01             	add    $0x1,%eax
	if (flag & CP_LFU_VER_FLAG) {
     6e0:	81 e6 00 00 01 00    	and    $0x10000,%esi
     6e6:	0f 84 84 01 00 00    	je     870 <nvm_flush_lfu_pages+0x1d0>
		lfu_blkaddr = nsbi->nsb->lfu_blkaddr1;
     6ec:	8b 5a 20             	mov    0x20(%rdx),%ebx
	for (i = 0; i < lfu_blk_num; ++i) {
     6ef:	49 8d 96 98 00 00 00 	lea    0x98(%r14),%rdx
     6f6:	45 31 e4             	xor    %r12d,%r12d
     6f9:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
     6fd:	8d 14 03             	lea    (%rbx,%rax,1),%edx
     700:	89 55 cc             	mov    %edx,-0x34(%rbp)
     703:	85 c0                	test   %eax,%eax
     705:	7f 5d                	jg     764 <nvm_flush_lfu_pages+0xc4>
     707:	e9 2a 01 00 00       	jmpq   836 <nvm_flush_lfu_pages+0x196>
	if (!page)
     70c:	4d 85 ff             	test   %r15,%r15
     70f:	74 40                	je     751 <nvm_flush_lfu_pages+0xb1>
	__READ_ONCE_SIZE;
     711:	49 8b 57 08          	mov    0x8(%r15),%rdx
     715:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     719:	83 e2 01             	and    $0x1,%edx
     71c:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     720:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     723:	a8 01                	test   $0x1,%al
     725:	0f 84 27 01 00 00    	je     852 <nvm_flush_lfu_pages+0x1b2>
		unlock_page(page);
     72b:	4c 89 ff             	mov    %r15,%rdi
     72e:	e8 00 00 00 00       	callq  733 <nvm_flush_lfu_pages+0x93>
     733:	49 8b 47 08          	mov    0x8(%r15),%rax
     737:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
     73b:	a8 01                	test   $0x1,%al
     73d:	4c 0f 45 fa          	cmovne %rdx,%r15
     741:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     746:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
     74b:	0f 84 f4 00 00 00    	je     845 <nvm_flush_lfu_pages+0x1a5>
		lfu_blkaddr++;
     751:	83 c3 01             	add    $0x1,%ebx
	for (i = 0; i < lfu_blk_num; ++i) {
     754:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
     75b:	3b 5d cc             	cmp    -0x34(%rbp),%ebx
     75e:	0f 84 d2 00 00 00    	je     836 <nvm_flush_lfu_pages+0x196>
		src_addr = nsbi->lfu_count + (PAGE_SIZE * i / sizeof(atomic_t));
     764:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
     768:	4c 89 e0             	mov    %r12,%rax
		lfu_page = f2fs_grab_meta_page(sbi, lfu_blkaddr);
     76b:	48 63 f3             	movslq %ebx,%rsi
		src_addr = nsbi->lfu_count + (PAGE_SIZE * i / sizeof(atomic_t));
     76e:	48 c1 e8 02          	shr    $0x2,%rax
     772:	4c 8d 34 c7          	lea    (%rdi,%rax,8),%r14
		lfu_page = f2fs_grab_meta_page(sbi, lfu_blkaddr);
     776:	4c 89 ef             	mov    %r13,%rdi
     779:	e8 00 00 00 00       	callq  77e <nvm_flush_lfu_pages+0xde>
     77e:	4c 89 f6             	mov    %r14,%rsi
	return page_to_virt(page);
     781:	48 89 c1             	mov    %rax,%rcx
     784:	48 2b 0d 00 00 00 00 	sub    0x0(%rip),%rcx        # 78b <nvm_flush_lfu_pages+0xeb>
     78b:	49 89 c7             	mov    %rax,%r15
     78e:	49 8b 06             	mov    (%r14),%rax
     791:	48 c1 f9 06          	sar    $0x6,%rcx
     795:	48 c1 e1 0c          	shl    $0xc,%rcx
     799:	48 03 0d 00 00 00 00 	add    0x0(%rip),%rcx        # 7a0 <nvm_flush_lfu_pages+0x100>
     7a0:	48 89 01             	mov    %rax,(%rcx)
     7a3:	48 8d 79 08          	lea    0x8(%rcx),%rdi
     7a7:	49 8b 86 f8 0f 00 00 	mov    0xff8(%r14),%rax
     7ae:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
     7b2:	48 89 81 f8 0f 00 00 	mov    %rax,0xff8(%rcx)
     7b9:	48 29 f9             	sub    %rdi,%rcx
     7bc:	48 29 ce             	sub    %rcx,%rsi
     7bf:	81 c1 00 10 00 00    	add    $0x1000,%ecx
     7c5:	c1 e9 03             	shr    $0x3,%ecx
     7c8:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
     7cb:	49 8b 57 08          	mov    0x8(%r15),%rdx
     7cf:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     7d3:	83 e2 01             	and    $0x1,%edx
     7d6:	49 0f 44 c7          	cmove  %r15,%rax
     7da:	48 8b 00             	mov    (%rax),%rax
		if (!PageDirty(lfu_page))
     7dd:	a8 10                	test   $0x10,%al
     7df:	0f 85 27 ff ff ff    	jne    70c <nvm_flush_lfu_pages+0x6c>
			set_page_dirty(lfu_page);
     7e5:	4c 89 ff             	mov    %r15,%rdi
     7e8:	e8 00 00 00 00       	callq  7ed <nvm_flush_lfu_pages+0x14d>
     7ed:	e9 1a ff ff ff       	jmpq   70c <nvm_flush_lfu_pages+0x6c>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     7f2:	49 8b 07             	mov    (%r15),%rax
     7f5:	48 c1 e8 33          	shr    $0x33,%rax
     7f9:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     7fc:	83 f8 04             	cmp    $0x4,%eax
     7ff:	0f 85 41 ff ff ff    	jne    746 <nvm_flush_lfu_pages+0xa6>
	switch (page->pgmap->type) {
     805:	49 8b 47 08          	mov    0x8(%r15),%rax
     809:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     80f:	83 e8 01             	sub    $0x1,%eax
     812:	83 f8 02             	cmp    $0x2,%eax
     815:	0f 87 2b ff ff ff    	ja     746 <nvm_flush_lfu_pages+0xa6>
		__put_devmap_managed_page(page);
     81b:	4c 89 ff             	mov    %r15,%rdi
		lfu_blkaddr++;
     81e:	83 c3 01             	add    $0x1,%ebx
     821:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
     828:	e8 00 00 00 00       	callq  82d <nvm_flush_lfu_pages+0x18d>
	for (i = 0; i < lfu_blk_num; ++i) {
     82d:	3b 5d cc             	cmp    -0x34(%rbp),%ebx
     830:	0f 85 2e ff ff ff    	jne    764 <nvm_flush_lfu_pages+0xc4>
}
     836:	48 83 c4 10          	add    $0x10,%rsp
     83a:	5b                   	pop    %rbx
     83b:	41 5c                	pop    %r12
     83d:	41 5d                	pop    %r13
     83f:	41 5e                	pop    %r14
     841:	41 5f                	pop    %r15
     843:	5d                   	pop    %rbp
     844:	c3                   	retq   
		__put_page(page);
     845:	4c 89 ff             	mov    %r15,%rdi
     848:	e8 00 00 00 00       	callq  84d <nvm_flush_lfu_pages+0x1ad>
     84d:	e9 ff fe ff ff       	jmpq   751 <nvm_flush_lfu_pages+0xb1>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     852:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     854:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
     858:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     85b:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     85f:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     866:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
     86b:	e9 bb fe ff ff       	jmpq   72b <nvm_flush_lfu_pages+0x8b>
		lfu_blkaddr = nsbi->nsb->lfu_blkaddr0;
     870:	8b 5a 1c             	mov    0x1c(%rdx),%ebx
     873:	e9 77 fe ff ff       	jmpq   6ef <nvm_flush_lfu_pages+0x4f>
     878:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     87f:	00 

0000000000000880 <nvm_redirect_bio>:
struct bio *nvm_redirect_bio(struct f2fs_sb_info *sbi, struct bio *bio, enum page_type type) {
     880:	f3 0f 1e fa          	endbr64 
     884:	e8 00 00 00 00       	callq  889 <nvm_redirect_bio+0x9>
	if (type == META || type == META_FLUSH) {
     889:	83 ea 02             	sub    $0x2,%edx
struct bio *nvm_redirect_bio(struct f2fs_sb_info *sbi, struct bio *bio, enum page_type type) {
     88c:	48 89 f0             	mov    %rsi,%rax
	struct nvm_sb_info *nsbi = sbi->nsbi;
     88f:	48 8b b7 48 07 00 00 	mov    0x748(%rdi),%rsi
	if (type == META || type == META_FLUSH) {
     896:	83 e2 fd             	and    $0xfffffffd,%edx
     899:	0f 84 17 01 00 00    	je     9b6 <nvm_redirect_bio+0x136>
struct bio *nvm_redirect_bio(struct f2fs_sb_info *sbi, struct bio *bio, enum page_type type) {
     89f:	55                   	push   %rbp
	ssd_blk_addr = SECTOR_TO_BLOCK(bio->bi_iter.bi_sector);
     8a0:	48 8b 50 28          	mov    0x28(%rax),%rdx
     8a4:	48 c1 ea 03          	shr    $0x3,%rdx
struct bio *nvm_redirect_bio(struct f2fs_sb_info *sbi, struct bio *bio, enum page_type type) {
     8a8:	48 89 e5             	mov    %rsp,%rbp
     8ab:	41 54                	push   %r12
     8ad:	53                   	push   %rbx
	return (struct f2fs_sm_info *)(sbi->sm_info);
     8ae:	48 8b 4f 68          	mov    0x68(%rdi),%rcx
     8b2:	4c 8b 47 10          	mov    0x10(%rdi),%r8
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
     8b6:	48 85 c9             	test   %rcx,%rcx
     8b9:	0f 84 36 01 00 00    	je     9f5 <nvm_redirect_bio+0x175>
     8bf:	44 8b 49 48          	mov    0x48(%rcx),%r9d
     8c3:	8b 8f 20 04 00 00    	mov    0x420(%rdi),%ecx
     8c9:	44 29 ca             	sub    %r9d,%edx
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
     8cc:	45 8b 40 5c          	mov    0x5c(%r8),%r8d
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
     8d0:	41 89 d2             	mov    %edx,%r10d
     8d3:	41 d3 ea             	shr    %cl,%r10d
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
     8d6:	45 29 c8             	sub    %r9d,%r8d
     8d9:	41 d3 e8             	shr    %cl,%r8d
     8dc:	44 89 d1             	mov    %r10d,%ecx
	offset = GET_BLKOFF_FROM_SEG0(sbi, ssd_blk_addr);
     8df:	44 8b 97 24 04 00 00 	mov    0x424(%rdi),%r10d
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
     8e6:	44 29 c1             	sub    %r8d,%ecx
	nr_nvm_main_segs = nsbi->nsb->main_segment_nums;
     8e9:	4c 8b 06             	mov    (%rsi),%r8
	index = nr_nvm_main_segs + ssd_main_segoff;
     8ec:	41 8b 58 2c          	mov    0x2c(%r8),%ebx
static inline void set_map_flag(struct nvm_sb_info *nsbi, int index) {
	nsbi->mpt[index] = nsbi->mpt[index] | rw_map;
}

static inline int get_redirect_flag(struct nvm_sb_info *nsbi, int index) {
	return nsbi->mpt[index] & rw_redirect;
     8f0:	4c 8b 46 50          	mov    0x50(%rsi),%r8
     8f4:	01 cb                	add    %ecx,%ebx
     8f6:	48 63 db             	movslq %ebx,%rbx
     8f9:	45 8b 04 98          	mov    (%r8,%rbx,4),%r8d
     8fd:	41 83 e0 02          	and    $0x2,%r8d
	if (is_read_io(bio_op(bio))) {
     901:	80 78 10 00          	cmpb   $0x0,0x10(%rax)
     905:	75 43                	jne    94a <nvm_redirect_bio+0xca>
		size_count = get_size_count(bio->bi_vcnt);
     907:	44 0f b7 48 70       	movzwl 0x70(%rax),%r9d
	if (size < 4)return size1;
     90c:	41 bb 05 00 00 00    	mov    $0x5,%r11d
     912:	41 83 f9 03          	cmp    $0x3,%r9d
     916:	7e 1b                	jle    933 <nvm_redirect_bio+0xb3>
	else if (size < 8)return size2;
     918:	41 bb 03 00 00 00    	mov    $0x3,%r11d
     91e:	41 83 f9 07          	cmp    $0x7,%r9d
     922:	7e 0f                	jle    933 <nvm_redirect_bio+0xb3>
	else return size4;
     924:	45 31 db             	xor    %r11d,%r11d
     927:	41 83 f9 10          	cmp    $0x10,%r9d
     92b:	41 0f 9c c3          	setl   %r11b
     92f:	41 83 c3 01          	add    $0x1,%r11d
		atomic_add(size_count,&nsbi->lfu_count[nsbi->now_lfu_counter][ssd_main_segoff]);
     933:	44 8b a6 90 00 00 00 	mov    0x90(%rsi),%r12d
     93a:	41 89 c9             	mov    %ecx,%r9d
     93d:	4a 8b 8c e6 98 00 00 	mov    0x98(%rsi,%r12,8),%rcx
     944:	00 
	asm volatile(LOCK_PREFIX "addl %1,%0"
     945:	f0 46 01 1c 89       	lock add %r11d,(%rcx,%r9,4)
	if (!redirect_flag) {
     94a:	45 85 c0             	test   %r8d,%r8d
     94d:	74 62                	je     9b1 <nvm_redirect_bio+0x131>
	return nsbi->mpt[index] >> rw_bits;
     94f:	48 8b 8f 48 07 00 00 	mov    0x748(%rdi),%rcx
	nvm_blk_addr = nsbi->nsb->main_blkaddr + nvm_main_segoff * sbi->blocks_per_seg + offset;
     956:	4c 8b 06             	mov    (%rsi),%r8
     959:	48 8b 49 50          	mov    0x50(%rcx),%rcx
     95d:	8b 0c 99             	mov    (%rcx,%rbx,4),%ecx
     960:	c1 e9 03             	shr    $0x3,%ecx
     963:	0f af 8f 24 04 00 00 	imul   0x424(%rdi),%ecx
     96a:	89 cf                	mov    %ecx,%edi
	offset = GET_BLKOFF_FROM_SEG0(sbi, ssd_blk_addr);
     96c:	41 8d 4a ff          	lea    -0x1(%r10),%ecx
     970:	21 ca                	and    %ecx,%edx
	nvm_blk_addr = nsbi->nsb->main_blkaddr + nvm_main_segoff * sbi->blocks_per_seg + offset;
     972:	41 03 50 18          	add    0x18(%r8),%edx
	bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(nvm_blk_addr);
     976:	01 fa                	add    %edi,%edx
     978:	48 c1 e2 03          	shl    $0x3,%rdx
     97c:	48 89 50 28          	mov    %rdx,0x28(%rax)
	bio_set_dev(bio, nsbi->nbdev);
     980:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     984:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
     98b:	48 39 50 08          	cmp    %rdx,0x8(%rax)
     98f:	74 11                	je     9a2 <nvm_redirect_bio+0x122>
	bio->bi_flags |= (1U << bit);
}

static inline void bio_clear_flag(struct bio *bio, unsigned int bit)
{
	bio->bi_flags &= ~(1U << bit);
     991:	66 81 60 14 ff fd    	andw   $0xfdff,0x14(%rax)
     997:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     99b:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
     9a2:	48 89 50 08          	mov    %rdx,0x8(%rax)
     9a6:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     9aa:	0f b6 52 6c          	movzbl 0x6c(%rdx),%edx
     9ae:	88 50 1b             	mov    %dl,0x1b(%rax)
}
     9b1:	5b                   	pop    %rbx
     9b2:	41 5c                	pop    %r12
     9b4:	5d                   	pop    %rbp
     9b5:	c3                   	retq   
		if (!(nsbi->nvm_flag & NVM_FIRST_MOUNR) || !is_read_io(bio_op(bio))) {
     9b6:	f6 46 10 02          	testb  $0x2,0x10(%rsi)
     9ba:	74 07                	je     9c3 <nvm_redirect_bio+0x143>
     9bc:	80 78 10 00          	cmpb   $0x0,0x10(%rax)
     9c0:	75 01                	jne    9c3 <nvm_redirect_bio+0x143>
}
     9c2:	c3                   	retq   
			bio_set_dev(bio, nsbi->nbdev);
     9c3:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     9c7:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
     9ce:	48 39 50 08          	cmp    %rdx,0x8(%rax)
     9d2:	74 11                	je     9e5 <nvm_redirect_bio+0x165>
     9d4:	66 81 60 14 ff fd    	andw   $0xfdff,0x14(%rax)
     9da:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     9de:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
     9e5:	48 89 50 08          	mov    %rdx,0x8(%rax)
     9e9:	48 8b 56 08          	mov    0x8(%rsi),%rdx
     9ed:	0f b6 52 6c          	movzbl 0x6c(%rdx),%edx
     9f1:	88 50 1b             	mov    %dl,0x1b(%rax)
     9f4:	c3                   	retq   
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
     9f5:	45 8b 48 48          	mov    0x48(%r8),%r9d
     9f9:	e9 c5 fe ff ff       	jmpq   8c3 <nvm_redirect_bio+0x43>
     9fe:	66 90                	xchg   %ax,%ax

0000000000000a00 <create_mapping>:
void create_mapping(struct f2fs_sb_info *sbi, unsigned int ssd_segoff, unsigned int nvm_segoff, int rw_flag) {
     a00:	f3 0f 1e fa          	endbr64 
     a04:	e8 00 00 00 00       	callq  a09 <create_mapping+0x9>
     a09:	55                   	push   %rbp
     a0a:	48 89 e5             	mov    %rsp,%rbp
     a0d:	41 57                	push   %r15
     a0f:	41 56                	push   %r14
     a11:	49 89 fe             	mov    %rdi,%r14
     a14:	41 55                	push   %r13
     a16:	41 54                	push   %r12
     a18:	41 89 d4             	mov    %edx,%r12d
     a1b:	53                   	push   %rbx
     a1c:	89 f3                	mov    %esi,%ebx
     a1e:	48 83 ec 08          	sub    $0x8,%rsp
	struct nvm_sb_info *nsbi = sbi->nsbi;
     a22:	4c 8b af 48 07 00 00 	mov    0x748(%rdi),%r13
void create_mapping(struct f2fs_sb_info *sbi, unsigned int ssd_segoff, unsigned int nvm_segoff, int rw_flag) {
     a29:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
     a2c:	4d 8d 7d 64          	lea    0x64(%r13),%r15
     a30:	4c 89 ff             	mov    %r15,%rdi
     a33:	e8 00 00 00 00       	callq  a38 <create_mapping+0x38>
	nsbi->mpt[index] = ((offset << rw_bits) | rw_flag);
     a38:	49 8b 86 48 07 00 00 	mov    0x748(%r14),%rax
     a3f:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
     a42:	44 89 e6             	mov    %r12d,%esi
     a45:	48 8b 50 50          	mov    0x50(%rax),%rdx
     a49:	8d 04 dd 00 00 00 00 	lea    0x0(,%rbx,8),%eax
     a50:	09 c8                	or     %ecx,%eax
     a52:	89 04 b2             	mov    %eax,(%rdx,%rsi,4)
     a55:	49 8b 86 48 07 00 00 	mov    0x748(%r14),%rax
     a5c:	89 de                	mov    %ebx,%esi
	set_mpt_entry(sbi->nsbi, nsbi->nsb->main_segment_nums + ssd_segoff, nvm_segoff, rw_flag);
     a5e:	49 8b 55 00          	mov    0x0(%r13),%rdx
     a62:	03 72 2c             	add    0x2c(%rdx),%esi
     a65:	48 8b 50 50          	mov    0x50(%rax),%rdx
     a69:	42 8d 04 e5 00 00 00 	lea    0x0(,%r12,8),%eax
     a70:	00 
	dirty_bit[0] = nvm_segoff / entries_per_blk;
     a71:	41 c1 ec 0a          	shr    $0xa,%r12d
     a75:	09 c1                	or     %eax,%ecx
     a77:	89 0c b2             	mov    %ecx,(%rdx,%rsi,4)
	test_and_set_bit(dirty_bit[0], nsbi->mpt_dirty_map);
     a7a:	49 8b 45 58          	mov    0x58(%r13),%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
     a7e:	f0 4c 0f ab 20       	lock bts %r12,(%rax)
	dirty_bit[1] = (nsbi->nsb->main_segment_nums + ssd_segoff) / entries_per_blk;
     a83:	49 8b 55 00          	mov    0x0(%r13),%rdx
	test_and_set_bit(dirty_bit[1], nsbi->mpt_dirty_map);
     a87:	49 8b 45 58          	mov    0x58(%r13),%rax
	dirty_bit[1] = (nsbi->nsb->main_segment_nums + ssd_segoff) / entries_per_blk;
     a8b:	03 5a 2c             	add    0x2c(%rdx),%ebx
     a8e:	c1 eb 0a             	shr    $0xa,%ebx
     a91:	f0 48 0f ab 18       	lock bts %rbx,(%rax)
     a96:	4c 89 ff             	mov    %r15,%rdi
     a99:	ff 14 25 00 00 00 00 	callq  *0x0
}
     aa0:	48 83 c4 08          	add    $0x8,%rsp
     aa4:	5b                   	pop    %rbx
     aa5:	41 5c                	pop    %r12
     aa7:	41 5d                	pop    %r13
     aa9:	41 5e                	pop    %r14
     aab:	41 5f                	pop    %r15
     aad:	5d                   	pop    %rbp
     aae:	c3                   	retq   
     aaf:	90                   	nop

0000000000000ab0 <nvm_allocate_segment>:
int nvm_allocate_segment(struct f2fs_sb_info *sbi, unsigned int ssd_segoff, int is_create_mapping) {
     ab0:	f3 0f 1e fa          	endbr64 
     ab4:	e8 00 00 00 00       	callq  ab9 <nvm_allocate_segment+0x9>
     ab9:	55                   	push   %rbp
     aba:	48 89 e5             	mov    %rsp,%rbp
     abd:	41 57                	push   %r15
     abf:	41 56                	push   %r14
     ac1:	41 55                	push   %r13
     ac3:	41 54                	push   %r12
     ac5:	49 89 fc             	mov    %rdi,%r12
     ac8:	53                   	push   %rbx
     ac9:	89 d3                	mov    %edx,%ebx
     acb:	48 83 ec 08          	sub    $0x8,%rsp
	struct nvm_sb_info *nsbi = sbi->nsbi;
     acf:	4c 8b af 48 07 00 00 	mov    0x748(%rdi),%r13
int nvm_allocate_segment(struct f2fs_sb_info *sbi, unsigned int ssd_segoff, int is_create_mapping) {
     ad6:	89 75 d4             	mov    %esi,-0x2c(%rbp)
     ad9:	4d 8d b5 88 00 00 00 	lea    0x88(%r13),%r14
	unsigned int nvm_segoff = nsbi->cur_alloc_nvm_segoff;
     ae0:	45 8b bd 8c 00 00 00 	mov    0x8c(%r13),%r15d
     ae7:	4c 89 f7             	mov    %r14,%rdi
     aea:	e8 00 00 00 00       	callq  aef <nvm_allocate_segment+0x3f>
	if (nsbi->nsb->main_segment_free_nums == 0) {
     aef:	49 8b 55 00          	mov    0x0(%r13),%rdx
     af3:	8b 42 30             	mov    0x30(%rdx),%eax
     af6:	85 c0                	test   %eax,%eax
     af8:	0f 84 96 00 00 00    	je     b94 <nvm_allocate_segment+0xe4>
	nvm_assert(nsbi->nsb->main_segment_free_nums <= nsbi->nsb->main_segment_nums);
     afe:	8b 72 2c             	mov    0x2c(%rdx),%esi
     b01:	39 f0                	cmp    %esi,%eax
     b03:	0f 87 89 00 00 00    	ja     b92 <nvm_allocate_segment+0xe2>
	nvm_segoff = find_next_zero_bit(nsbi->segment_map, nsbi->nsb->main_segment_nums, nvm_segoff);
     b09:	49 8b 7d 78          	mov    0x78(%r13),%rdi
     b0d:	44 89 fa             	mov    %r15d,%edx
     b10:	e8 00 00 00 00       	callq  b15 <nvm_allocate_segment+0x65>
     b15:	49 89 c7             	mov    %rax,%r15
     b18:	89 c2                	mov    %eax,%edx
	if (nvm_segoff >= nsbi->nsb->main_segment_nums) {
     b1a:	49 8b 45 00          	mov    0x0(%r13),%rax
     b1e:	8b 70 2c             	mov    0x2c(%rax),%esi
     b21:	44 39 fe             	cmp    %r15d,%esi
     b24:	77 0c                	ja     b32 <nvm_allocate_segment+0x82>
		nvm_assert(nsbi->nsb->main_segment_free_nums > 0);
     b26:	8b 40 30             	mov    0x30(%rax),%eax
		nvm_segoff = 0;
     b29:	45 31 ff             	xor    %r15d,%r15d
		nvm_assert(nsbi->nsb->main_segment_free_nums > 0);
     b2c:	85 c0                	test   %eax,%eax
     b2e:	75 d9                	jne    b09 <nvm_allocate_segment+0x59>
     b30:	0f 0b                	ud2    
	if (!test_and_set_bit(nvm_segoff, nsbi->segment_map)) {
     b32:	49 8b 45 78          	mov    0x78(%r13),%rax
     b36:	44 89 fe             	mov    %r15d,%esi
     b39:	f0 48 0f ab 30       	lock bts %rsi,(%rax)
     b3e:	73 2a                	jae    b6a <nvm_allocate_segment+0xba>
	nsbi->cur_alloc_nvm_segoff = nvm_segoff + 1;
     b40:	8d 42 01             	lea    0x1(%rdx),%eax
     b43:	4c 89 f7             	mov    %r14,%rdi
     b46:	41 89 85 8c 00 00 00 	mov    %eax,0x8c(%r13)
     b4d:	ff 14 25 00 00 00 00 	callq  *0x0
	if (is_create_mapping) {
     b54:	85 db                	test   %ebx,%ebx
     b56:	75 28                	jne    b80 <nvm_allocate_segment+0xd0>
	return nvm_segoff;
     b58:	44 89 f8             	mov    %r15d,%eax
}
     b5b:	48 83 c4 08          	add    $0x8,%rsp
     b5f:	5b                   	pop    %rbx
     b60:	41 5c                	pop    %r12
     b62:	41 5d                	pop    %r13
     b64:	41 5e                	pop    %r14
     b66:	41 5f                	pop    %r15
     b68:	5d                   	pop    %rbp
     b69:	c3                   	retq   
		--nsbi->nsb->main_segment_free_nums;
     b6a:	49 8b 45 00          	mov    0x0(%r13),%rax
     b6e:	83 68 30 01          	subl   $0x1,0x30(%rax)
		sbi->nsbi->nvm_flag |= NVM_NSB_DIRTY;// 设置nsb为脏
     b72:	49 8b 84 24 48 07 00 	mov    0x748(%r12),%rax
     b79:	00 
     b7a:	80 48 10 01          	orb    $0x1,0x10(%rax)
     b7e:	eb c0                	jmp    b40 <nvm_allocate_segment+0x90>
		create_mapping(sbi, ssd_segoff, nvm_segoff, rw_map | rw_redirect);
     b80:	8b 75 d4             	mov    -0x2c(%rbp),%esi
     b83:	b9 03 00 00 00       	mov    $0x3,%ecx
     b88:	4c 89 e7             	mov    %r12,%rdi
     b8b:	e8 00 00 00 00       	callq  b90 <nvm_allocate_segment+0xe0>
     b90:	eb c6                	jmp    b58 <nvm_allocate_segment+0xa8>
	nvm_assert(nsbi->nsb->main_segment_free_nums <= nsbi->nsb->main_segment_nums);
     b92:	0f 0b                	ud2    
     b94:	4c 89 f7             	mov    %r14,%rdi
     b97:	ff 14 25 00 00 00 00 	callq  *0x0
		return -ENVMNOSPACE;
     b9e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
     ba3:	eb b6                	jmp    b5b <nvm_allocate_segment+0xab>
     ba5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     bac:	00 00 00 00 

0000000000000bb0 <unset_mapping>:
void unset_mapping(struct f2fs_sb_info *sbi, unsigned int ssd_segno) {
     bb0:	f3 0f 1e fa          	endbr64 
     bb4:	e8 00 00 00 00       	callq  bb9 <unset_mapping+0x9>
     bb9:	55                   	push   %rbp
     bba:	48 89 e5             	mov    %rsp,%rbp
     bbd:	41 56                	push   %r14
     bbf:	41 55                	push   %r13
     bc1:	41 54                	push   %r12
     bc3:	53                   	push   %rbx
	struct nvm_sb_info *nsbi = sbi->nsbi;
     bc4:	48 8b 9f 48 07 00 00 	mov    0x748(%rdi),%rbx
	unsigned int ssd_offset = ssd_segno + nsbi->nsb->main_segment_nums;
     bcb:	48 8b 03             	mov    (%rbx),%rax
     bce:	4c 8d 6b 64          	lea    0x64(%rbx),%r13
     bd2:	4c 89 ef             	mov    %r13,%rdi
     bd5:	03 70 2c             	add    0x2c(%rax),%esi
     bd8:	41 89 f4             	mov    %esi,%r12d
     bdb:	e8 00 00 00 00       	callq  be0 <unset_mapping+0x30>
	return nsbi->mpt[index] & rw_map;
     be0:	48 8b 43 50          	mov    0x50(%rbx),%rax
     be4:	49 63 d4             	movslq %r12d,%rdx
     be7:	48 8d 14 90          	lea    (%rax,%rdx,4),%rdx
     beb:	8b 02                	mov    (%rdx),%eax
	if (get_map_flag(nsbi, ssd_offset)) {
     bed:	a8 01                	test   $0x1,%al
     bef:	74 5b                	je     c4c <unset_mapping+0x9c>
	int low = nsbi->mpt[index] & (rw_double - 1);
	nsbi->mpt[index] = ((nsbi->mpt[index] >> rw_double) << rw_double) | low;
}

static inline void clear_map(struct nvm_sb_info *nsbi, int index) {
	nsbi->mpt[index] = 0;
     bf1:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
	return nsbi->mpt[index] >> rw_bits;
     bf7:	41 89 c6             	mov    %eax,%r14d
	nsbi->mpt[index] = 0;
     bfa:	48 8b 53 50          	mov    0x50(%rbx),%rdx
		set_bit(ssd_offset / entries_per_blk, nsbi->mpt_dirty_map);
     bfe:	41 c1 ec 0a          	shr    $0xa,%r12d
	return nsbi->mpt[index] >> rw_bits;
     c02:	41 c1 ee 03          	shr    $0x3,%r14d
	nsbi->mpt[index] = 0;
     c06:	42 c7 04 b2 00 00 00 	movl   $0x0,(%rdx,%r14,4)
     c0d:	00 
     c0e:	48 8b 53 58          	mov    0x58(%rbx),%rdx
		asm volatile(LOCK_PREFIX __ASM_SIZE(bts) " %1,%0"
     c12:	f0 4c 0f ab 22       	lock bts %r12,(%rdx)
		set_bit(nvm_offset / entries_per_blk, nsbi->mpt_dirty_map);
     c17:	48 8b 53 58          	mov    0x58(%rbx),%rdx
     c1b:	c1 e8 0d             	shr    $0xd,%eax
     c1e:	f0 48 0f ab 02       	lock bts %rax,(%rdx)
     c23:	4c 8d a3 88 00 00 00 	lea    0x88(%rbx),%r12
     c2a:	4c 89 e7             	mov    %r12,%rdi
     c2d:	e8 00 00 00 00       	callq  c32 <unset_mapping+0x82>
		clear_bit(nvm_offset, nsbi->segment_map);
     c32:	48 8b 43 78          	mov    0x78(%rbx),%rax
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
     c36:	f0 4c 0f b3 30       	lock btr %r14,(%rax)
		nsbi->nsb->main_segment_free_nums++;
     c3b:	48 8b 03             	mov    (%rbx),%rax
     c3e:	4c 89 e7             	mov    %r12,%rdi
     c41:	83 40 30 01          	addl   $0x1,0x30(%rax)
     c45:	ff 14 25 00 00 00 00 	callq  *0x0
     c4c:	4c 89 ef             	mov    %r13,%rdi
     c4f:	ff 14 25 00 00 00 00 	callq  *0x0
}
     c56:	5b                   	pop    %rbx
     c57:	41 5c                	pop    %r12
     c59:	41 5d                	pop    %r13
     c5b:	41 5e                	pop    %r14
     c5d:	5d                   	pop    %rbp
     c5e:	c3                   	retq   
     c5f:	90                   	nop

0000000000000c60 <nvm_set_ckpt_segment_map>:
void nvm_set_ckpt_segment_map(struct f2fs_sb_info *sbi) {
     c60:	f3 0f 1e fa          	endbr64 
     c64:	e8 00 00 00 00       	callq  c69 <nvm_set_ckpt_segment_map+0x9>
     c69:	55                   	push   %rbp
	struct nvm_sb_info *nsbi = sbi->nsbi;
     c6a:	48 8b 87 48 07 00 00 	mov    0x748(%rdi),%rax
	memcpy(nsbi->ckpt_segment_map, nsbi->segment_map, (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1);
     c71:	48 8b 10             	mov    (%rax),%rdx
     c74:	48 8b b8 80 00 00 00 	mov    0x80(%rax),%rdi
     c7b:	48 8b 70 78          	mov    0x78(%rax),%rsi
void nvm_set_ckpt_segment_map(struct f2fs_sb_info *sbi) {
     c7f:	48 89 e5             	mov    %rsp,%rbp
	memcpy(nsbi->ckpt_segment_map, nsbi->segment_map, (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1);
     c82:	8b 52 2c             	mov    0x2c(%rdx),%edx
     c85:	83 ea 01             	sub    $0x1,%edx
     c88:	c1 ea 03             	shr    $0x3,%edx
     c8b:	83 c2 01             	add    $0x1,%edx
     c8e:	e8 00 00 00 00       	callq  c93 <nvm_set_ckpt_segment_map+0x33>
}
     c93:	5d                   	pop    %rbp
     c94:	c3                   	retq   
     c95:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     c9c:	00 00 00 00 

0000000000000ca0 <__nvm_debug>:
				 unsigned int line, const char *fmt, ...) {
     ca0:	f3 0f 1e fa          	endbr64 
     ca4:	e8 00 00 00 00       	callq  ca9 <__nvm_debug+0x9>
     ca9:	55                   	push   %rbp
     caa:	48 89 e5             	mov    %rsp,%rbp
     cad:	48 83 ec 60          	sub    $0x60,%rsp
     cb1:	4c 89 44 24 50       	mov    %r8,0x50(%rsp)
     cb6:	4c 89 4c 24 58       	mov    %r9,0x58(%rsp)
     cbb:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     cc2:	00 00 
     cc4:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
     cc9:	31 c0                	xor    %eax,%eax
	if (level >= __NVM_DEBUG__)
     ccb:	85 ff                	test   %edi,%edi
     ccd:	0f 88 00 00 00 00    	js     cd3 <__nvm_debug+0x33>
}
     cd3:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
     cd8:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
     cdf:	00 00 
     ce1:	75 02                	jne    ce5 <__nvm_debug+0x45>
     ce3:	c9                   	leaveq 
     ce4:	c3                   	retq   
     ce5:	e8 00 00 00 00       	callq  cea <__nvm_debug+0x4a>
     cea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000cf0 <read_meta_page_from_SSD>:
int read_meta_page_from_SSD(struct f2fs_sb_info *sbi) {
     cf0:	f3 0f 1e fa          	endbr64 
     cf4:	e8 00 00 00 00       	callq  cf9 <read_meta_page_from_SSD+0x9>
     cf9:	55                   	push   %rbp
     cfa:	48 89 e5             	mov    %rsp,%rbp
     cfd:	41 57                	push   %r15
     cff:	41 56                	push   %r14
     d01:	41 55                	push   %r13
     d03:	41 54                	push   %r12
     d05:	53                   	push   %rbx
	unsigned long start = sbi->raw_super->cp_blkaddr;
     d06:	48 8b 47 10          	mov    0x10(%rdi),%rax
	struct nvm_sb_info *nsbi = sbi->nsbi;
     d0a:	4c 8b bf 48 07 00 00 	mov    0x748(%rdi),%r15
	unsigned long start = sbi->raw_super->cp_blkaddr;
     d11:	8b 58 4c             	mov    0x4c(%rax),%ebx
	unsigned long end = sbi->raw_super->main_blkaddr;
     d14:	44 8b 70 5c          	mov    0x5c(%rax),%r14d
	for (; start < end; start++) {
     d18:	4c 39 f3             	cmp    %r14,%rbx
     d1b:	0f 83 b8 00 00 00    	jae    dd9 <read_meta_page_from_SSD+0xe9>
     d21:	49 89 fd             	mov    %rdi,%r13
     d24:	eb 51                	jmp    d77 <read_meta_page_from_SSD+0x87>
	if (!page)
     d26:	4d 85 e4             	test   %r12,%r12
     d29:	74 43                	je     d6e <read_meta_page_from_SSD+0x7e>
     d2b:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
     d30:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     d34:	83 e2 01             	and    $0x1,%edx
     d37:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     d3b:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     d3e:	a8 01                	test   $0x1,%al
     d40:	0f 84 bd 00 00 00    	je     e03 <read_meta_page_from_SSD+0x113>
		unlock_page(page);
     d46:	4c 89 e7             	mov    %r12,%rdi
     d49:	e8 00 00 00 00       	callq  d4e <read_meta_page_from_SSD+0x5e>
     d4e:	49 8b 44 24 08       	mov    0x8(%r12),%rax
     d53:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
     d57:	a8 01                	test   $0x1,%al
     d59:	4c 0f 45 e2          	cmovne %rdx,%r12
     d5d:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     d62:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
     d68:	0f 84 88 00 00 00    	je     df6 <read_meta_page_from_SSD+0x106>
     d6e:	48 83 c3 01          	add    $0x1,%rbx
     d72:	49 39 de             	cmp    %rbx,%r14
     d75:	74 62                	je     dd9 <read_meta_page_from_SSD+0xe9>
		page = f2fs_get_meta_page(sbi, start);
     d77:	48 89 de             	mov    %rbx,%rsi
     d7a:	4c 89 ef             	mov    %r13,%rdi
     d7d:	e8 00 00 00 00       	callq  d82 <read_meta_page_from_SSD+0x92>
     d82:	48 8b 50 08          	mov    0x8(%rax),%rdx
     d86:	49 89 c4             	mov    %rax,%r12
     d89:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     d8d:	83 e2 01             	and    $0x1,%edx
     d90:	49 0f 44 c4          	cmove  %r12,%rax
     d94:	48 8b 00             	mov    (%rax),%rax
		if (!PageDirty(page))
     d97:	a8 10                	test   $0x10,%al
     d99:	75 8b                	jne    d26 <read_meta_page_from_SSD+0x36>
			set_page_dirty(page);
     d9b:	4c 89 e7             	mov    %r12,%rdi
     d9e:	e8 00 00 00 00       	callq  da3 <read_meta_page_from_SSD+0xb3>
     da3:	eb 81                	jmp    d26 <read_meta_page_from_SSD+0x36>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     da5:	49 8b 04 24          	mov    (%r12),%rax
     da9:	48 c1 e8 33          	shr    $0x33,%rax
     dad:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     db0:	83 f8 04             	cmp    $0x4,%eax
     db3:	75 ad                	jne    d62 <read_meta_page_from_SSD+0x72>
	switch (page->pgmap->type) {
     db5:	49 8b 44 24 08       	mov    0x8(%r12),%rax
     dba:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     dc0:	83 e8 01             	sub    $0x1,%eax
     dc3:	83 f8 02             	cmp    $0x2,%eax
     dc6:	77 9a                	ja     d62 <read_meta_page_from_SSD+0x72>
		__put_devmap_managed_page(page);
     dc8:	4c 89 e7             	mov    %r12,%rdi
	for (; start < end; start++) {
     dcb:	48 83 c3 01          	add    $0x1,%rbx
     dcf:	e8 00 00 00 00       	callq  dd4 <read_meta_page_from_SSD+0xe4>
     dd4:	49 39 de             	cmp    %rbx,%r14
     dd7:	75 9e                	jne    d77 <read_meta_page_from_SSD+0x87>
	nvm_assert(nsbi->nvm_flag & NVM_FIRST_MOUNR);
     dd9:	41 0f b6 47 10       	movzbl 0x10(%r15),%eax
     dde:	a8 02                	test   $0x2,%al
     de0:	74 40                	je     e22 <read_meta_page_from_SSD+0x132>
	nsbi->nvm_flag ^= NVM_FIRST_MOUNR;
     de2:	83 f0 02             	xor    $0x2,%eax
     de5:	41 88 47 10          	mov    %al,0x10(%r15)
}
     de9:	31 c0                	xor    %eax,%eax
     deb:	5b                   	pop    %rbx
     dec:	41 5c                	pop    %r12
     dee:	41 5d                	pop    %r13
     df0:	41 5e                	pop    %r14
     df2:	41 5f                	pop    %r15
     df4:	5d                   	pop    %rbp
     df5:	c3                   	retq   
		__put_page(page);
     df6:	4c 89 e7             	mov    %r12,%rdi
     df9:	e8 00 00 00 00       	callq  dfe <read_meta_page_from_SSD+0x10e>
     dfe:	e9 6b ff ff ff       	jmpq   d6e <read_meta_page_from_SSD+0x7e>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     e03:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     e05:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
     e0a:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     e0d:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     e11:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     e18:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
     e1d:	e9 24 ff ff ff       	jmpq   d46 <read_meta_page_from_SSD+0x56>
	nvm_assert(nsbi->nvm_flag & NVM_FIRST_MOUNR);
     e22:	0f 0b                	ud2    
     e24:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     e2b:	00 00 00 00 
     e2f:	90                   	nop

0000000000000e30 <flush_meta_page_to_NVM>:
int flush_meta_page_to_NVM(struct f2fs_sb_info *sbi) {
     e30:	f3 0f 1e fa          	endbr64 
     e34:	e8 00 00 00 00       	callq  e39 <flush_meta_page_to_NVM+0x9>
     e39:	55                   	push   %rbp
     e3a:	48 89 e5             	mov    %rsp,%rbp
     e3d:	41 56                	push   %r14
     e3f:	41 55                	push   %r13
     e41:	41 54                	push   %r12
     e43:	53                   	push   %rbx
	struct nvm_super_block *nsb = nsbi->nsb;
     e44:	48 8b 87 48 07 00 00 	mov    0x748(%rdi),%rax
	unsigned long end = nsb->main_blkaddr;
     e4b:	48 8b 00             	mov    (%rax),%rax
     e4e:	44 8b 70 18          	mov    0x18(%rax),%r14d
	for (; start < end; start++) {
     e52:	4d 85 f6             	test   %r14,%r14
     e55:	0f 84 a2 00 00 00    	je     efd <flush_meta_page_to_NVM+0xcd>
     e5b:	49 89 fd             	mov    %rdi,%r13
	unsigned long start = 0;
     e5e:	45 31 e4             	xor    %r12d,%r12d
     e61:	eb 41                	jmp    ea4 <flush_meta_page_to_NVM+0x74>
		f2fs_do_write_meta_page(sbi, page, FS_META_IO);
     e63:	ba 06 00 00 00       	mov    $0x6,%edx
     e68:	48 89 de             	mov    %rbx,%rsi
     e6b:	4c 89 ef             	mov    %r13,%rdi
     e6e:	e8 00 00 00 00       	callq  e73 <flush_meta_page_to_NVM+0x43>
     e73:	48 8b 53 08          	mov    0x8(%rbx),%rdx
     e77:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     e7b:	83 e2 01             	and    $0x1,%edx
     e7e:	48 0f 44 c3          	cmove  %rbx,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     e82:	48 8b 00             	mov    (%rax),%rax
		if (PageDirty(page))
     e85:	a8 10                	test   $0x10,%al
     e87:	74 12                	je     e9b <flush_meta_page_to_NVM+0x6b>
     e89:	48 8b 43 08          	mov    0x8(%rbx),%rax
     e8d:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
     e91:	a8 01                	test   $0x1,%al
     e93:	48 0f 45 da          	cmovne %rdx,%rbx
		asm volatile(LOCK_PREFIX "andb %1,%0"
     e97:	f0 80 23 ef          	lock andb $0xef,(%rbx)
	for (; start < end; start++) {
     e9b:	49 83 c4 01          	add    $0x1,%r12
     e9f:	4d 39 e6             	cmp    %r12,%r14
     ea2:	74 59                	je     efd <flush_meta_page_to_NVM+0xcd>
		page = f2fs_get_meta_page(sbi, start);
     ea4:	4c 89 ef             	mov    %r13,%rdi
     ea7:	4c 89 e6             	mov    %r12,%rsi
     eaa:	e8 00 00 00 00       	callq  eaf <flush_meta_page_to_NVM+0x7f>
     eaf:	48 89 c3             	mov    %rax,%rbx
     eb2:	48 8b 40 08          	mov    0x8(%rax),%rax
     eb6:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
     eba:	a8 01                	test   $0x1,%al
     ebc:	48 0f 44 fb          	cmove  %rbx,%rdi
     ec0:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     ec5:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
     ec9:	75 98                	jne    e63 <flush_meta_page_to_NVM+0x33>
		__put_page(page);
     ecb:	e8 00 00 00 00       	callq  ed0 <flush_meta_page_to_NVM+0xa0>
     ed0:	eb 91                	jmp    e63 <flush_meta_page_to_NVM+0x33>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     ed2:	48 8b 07             	mov    (%rdi),%rax
     ed5:	48 c1 e8 33          	shr    $0x33,%rax
     ed9:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     edc:	83 f8 04             	cmp    $0x4,%eax
     edf:	75 e4                	jne    ec5 <flush_meta_page_to_NVM+0x95>
	switch (page->pgmap->type) {
     ee1:	48 8b 47 08          	mov    0x8(%rdi),%rax
     ee5:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     eeb:	83 e8 01             	sub    $0x1,%eax
     eee:	83 f8 02             	cmp    $0x2,%eax
     ef1:	77 d2                	ja     ec5 <flush_meta_page_to_NVM+0x95>
		__put_devmap_managed_page(page);
     ef3:	e8 00 00 00 00       	callq  ef8 <flush_meta_page_to_NVM+0xc8>
		return;
     ef8:	e9 66 ff ff ff       	jmpq   e63 <flush_meta_page_to_NVM+0x33>
}
     efd:	5b                   	pop    %rbx
     efe:	31 c0                	xor    %eax,%eax
     f00:	41 5c                	pop    %r12
     f02:	41 5d                	pop    %r13
     f04:	41 5e                	pop    %r14
     f06:	5d                   	pop    %rbp
     f07:	c3                   	retq   
     f08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     f0f:	00 

0000000000000f10 <sanity_check_nvm_super>:
						   struct nvm_super_block *nsb) {
     f10:	f3 0f 1e fa          	endbr64 
     f14:	e8 00 00 00 00       	callq  f19 <sanity_check_nvm_super+0x9>
     f19:	55                   	push   %rbp
	if (strncmp(nsb->uuid, F2FS_RAW_SUPER(sbi)->uuid, sizeof(nsb->uuid))) {
     f1a:	ba 10 00 00 00       	mov    $0x10,%edx
						   struct nvm_super_block *nsb) {
     f1f:	48 89 e5             	mov    %rsp,%rbp
     f22:	41 55                	push   %r13
     f24:	41 54                	push   %r12
     f26:	49 89 f4             	mov    %rsi,%r12
     f29:	53                   	push   %rbx
	if (strncmp(nsb->uuid, F2FS_RAW_SUPER(sbi)->uuid, sizeof(nsb->uuid))) {
     f2a:	48 8b 47 10          	mov    0x10(%rdi),%rax
						   struct nvm_super_block *nsb) {
     f2e:	48 89 fb             	mov    %rdi,%rbx
	if (strncmp(nsb->uuid, F2FS_RAW_SUPER(sbi)->uuid, sizeof(nsb->uuid))) {
     f31:	4c 89 e7             	mov    %r12,%rdi
     f34:	4c 8d 68 6c          	lea    0x6c(%rax),%r13
     f38:	4c 89 ee             	mov    %r13,%rsi
     f3b:	e8 00 00 00 00       	callq  f40 <sanity_check_nvm_super+0x30>
     f40:	85 c0                	test   %eax,%eax
     f42:	75 07                	jne    f4b <sanity_check_nvm_super+0x3b>
}
     f44:	5b                   	pop    %rbx
     f45:	41 5c                	pop    %r12
     f47:	41 5d                	pop    %r13
     f49:	5d                   	pop    %rbp
     f4a:	c3                   	retq   
		f2fs_msg(sb, KERN_ERR,
     f4b:	48 8b 3b             	mov    (%rbx),%rdi
     f4e:	4d 89 e8             	mov    %r13,%r8
     f51:	4c 89 e1             	mov    %r12,%rcx
     f54:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
     f5b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     f62:	e8 00 00 00 00       	callq  f67 <sanity_check_nvm_super+0x57>
		return 1;
     f67:	b8 01 00 00 00       	mov    $0x1,%eax
}
     f6c:	5b                   	pop    %rbx
     f6d:	41 5c                	pop    %r12
     f6f:	41 5d                	pop    %r13
     f71:	5d                   	pop    %rbp
     f72:	c3                   	retq   
     f73:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     f7a:	00 00 00 00 
     f7e:	66 90                	xchg   %ax,%ax

0000000000000f80 <get_current_mpt_page>:
struct page *get_current_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
     f80:	f3 0f 1e fa          	endbr64 
     f84:	e8 00 00 00 00       	callq  f89 <get_current_mpt_page+0x9>
	struct nvm_sb_info *nsbi = sbi->nsbi;
     f89:	48 8b 97 48 07 00 00 	mov    0x748(%rdi),%rdx
struct page *get_current_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
     f90:	55                   	push   %rbp
	block_addr = nsbi->nsb->mpt_blkaddr + mpt_pgoff;
     f91:	41 89 f0             	mov    %esi,%r8d
     f94:	48 8b 02             	mov    (%rdx),%rax
{
	int mask;

	addr += (nr >> 3);
	mask = 1 << (7 - (nr & 0x07));
	return mask & *addr;
     f97:	48 8b 52 68          	mov    0x68(%rdx),%rdx
struct page *get_current_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
     f9b:	48 89 e5             	mov    %rsp,%rbp
	block_addr = nsbi->nsb->mpt_blkaddr + mpt_pgoff;
     f9e:	44 03 40 10          	add    0x10(%rax),%r8d
	addr += (nr >> 3);
     fa2:	89 f0                	mov    %esi,%eax
	mask = 1 << (7 - (nr & 0x07));
     fa4:	f7 d6                	not    %esi
	addr += (nr >> 3);
     fa6:	c1 e8 03             	shr    $0x3,%eax
	mask = 1 << (7 - (nr & 0x07));
     fa9:	83 e6 07             	and    $0x7,%esi
	return mask & *addr;
     fac:	0f be 04 02          	movsbl (%rdx,%rax,1),%eax
	if (f2fs_test_bit(mpt_pgoff, nsbi->mpt_ver_map))
     fb0:	0f a3 f0             	bt     %esi,%eax
     fb3:	73 09                	jae    fbe <get_current_mpt_page+0x3e>
		block_addr += sbi->blocks_per_seg;
     fb5:	8b 87 24 04 00 00    	mov    0x424(%rdi),%eax
     fbb:	49 01 c0             	add    %rax,%r8
	dst_page = f2fs_get_meta_page(sbi, block_addr);
     fbe:	4c 89 c6             	mov    %r8,%rsi
     fc1:	e8 00 00 00 00       	callq  fc6 <get_current_mpt_page+0x46>
}
     fc6:	5d                   	pop    %rbp
     fc7:	c3                   	retq   
     fc8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     fcf:	00 

0000000000000fd0 <f2fs_get_mpt>:
void f2fs_get_mpt(struct f2fs_sb_info *sbi) {
     fd0:	f3 0f 1e fa          	endbr64 
     fd4:	e8 00 00 00 00       	callq  fd9 <f2fs_get_mpt+0x9>
     fd9:	55                   	push   %rbp
     fda:	48 89 e5             	mov    %rsp,%rbp
     fdd:	41 57                	push   %r15
     fdf:	41 56                	push   %r14
     fe1:	41 55                	push   %r13
     fe3:	41 54                	push   %r12
     fe5:	53                   	push   %rbx
	struct nvm_sb_info *nsbi = sbi->nsbi;
     fe6:	4c 8b a7 48 07 00 00 	mov    0x748(%rdi),%r12
	struct nvm_super_block *nsb = nsbi->nsb;
     fed:	4d 8b 2c 24          	mov    (%r12),%r13
	for (i = 0; i < nsb->mpt_ver_map_bits; ++i) {
     ff1:	41 8b 45 34          	mov    0x34(%r13),%eax
     ff5:	85 c0                	test   %eax,%eax
     ff7:	0f 84 ce 00 00 00    	je     10cb <f2fs_get_mpt+0xfb>
     ffd:	48 89 fb             	mov    %rdi,%rbx
    1000:	45 31 f6             	xor    %r14d,%r14d
    1003:	eb 0e                	jmp    1013 <f2fs_get_mpt+0x43>
    1005:	41 83 c6 01          	add    $0x1,%r14d
    1009:	45 39 75 34          	cmp    %r14d,0x34(%r13)
    100d:	0f 86 b8 00 00 00    	jbe    10cb <f2fs_get_mpt+0xfb>
		mpt_page = get_current_mpt_page(sbi, i);
    1013:	44 89 f6             	mov    %r14d,%esi
    1016:	48 89 df             	mov    %rbx,%rdi
    1019:	e8 00 00 00 00       	callq  101e <f2fs_get_mpt+0x4e>
		dst_addr = nsbi->mpt + (PAGE_SIZE * i) / sizeof(unsigned int);
    101e:	49 63 ce             	movslq %r14d,%rcx
	return page_to_virt(page);
    1021:	48 89 c6             	mov    %rax,%rsi
    1024:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 102b <f2fs_get_mpt+0x5b>
		mpt_page = get_current_mpt_page(sbi, i);
    102b:	49 89 c7             	mov    %rax,%r15
		dst_addr = nsbi->mpt + (PAGE_SIZE * i) / sizeof(unsigned int);
    102e:	48 c1 e1 0c          	shl    $0xc,%rcx
    1032:	48 c1 fe 06          	sar    $0x6,%rsi
    1036:	49 03 4c 24 50       	add    0x50(%r12),%rcx
    103b:	48 c1 e6 0c          	shl    $0xc,%rsi
    103f:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 1046 <f2fs_get_mpt+0x76>
    1046:	48 8d 79 08          	lea    0x8(%rcx),%rdi
    104a:	48 8b 06             	mov    (%rsi),%rax
    104d:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1051:	48 89 01             	mov    %rax,(%rcx)
    1054:	48 8b 86 f8 0f 00 00 	mov    0xff8(%rsi),%rax
    105b:	48 89 81 f8 0f 00 00 	mov    %rax,0xff8(%rcx)
    1062:	48 29 f9             	sub    %rdi,%rcx
    1065:	48 29 ce             	sub    %rcx,%rsi
    1068:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    106e:	c1 e9 03             	shr    $0x3,%ecx
    1071:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	if (!page)
    1074:	4d 85 ff             	test   %r15,%r15
    1077:	74 8c                	je     1005 <f2fs_get_mpt+0x35>
    1079:	49 8b 57 08          	mov    0x8(%r15),%rdx
    107d:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    1081:	83 e2 01             	and    $0x1,%edx
    1084:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    1088:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    108b:	a8 01                	test   $0x1,%al
    108d:	74 75                	je     1104 <f2fs_get_mpt+0x134>
		unlock_page(page);
    108f:	4c 89 ff             	mov    %r15,%rdi
    1092:	e8 00 00 00 00       	callq  1097 <f2fs_get_mpt+0xc7>
    1097:	49 8b 47 08          	mov    0x8(%r15),%rax
    109b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    109f:	a8 01                	test   $0x1,%al
    10a1:	4c 0f 45 fa          	cmovne %rdx,%r15
    10a5:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    10aa:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
    10af:	0f 85 50 ff ff ff    	jne    1005 <f2fs_get_mpt+0x35>
		__put_page(page);
    10b5:	4c 89 ff             	mov    %r15,%rdi
	for (i = 0; i < nsb->mpt_ver_map_bits; ++i) {
    10b8:	41 83 c6 01          	add    $0x1,%r14d
    10bc:	e8 00 00 00 00       	callq  10c1 <f2fs_get_mpt+0xf1>
    10c1:	45 39 75 34          	cmp    %r14d,0x34(%r13)
    10c5:	0f 87 48 ff ff ff    	ja     1013 <f2fs_get_mpt+0x43>
}
    10cb:	5b                   	pop    %rbx
    10cc:	41 5c                	pop    %r12
    10ce:	41 5d                	pop    %r13
    10d0:	41 5e                	pop    %r14
    10d2:	41 5f                	pop    %r15
    10d4:	5d                   	pop    %rbp
    10d5:	c3                   	retq   
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    10d6:	49 8b 07             	mov    (%r15),%rax
    10d9:	48 c1 e8 33          	shr    $0x33,%rax
    10dd:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    10e0:	83 f8 04             	cmp    $0x4,%eax
    10e3:	75 c5                	jne    10aa <f2fs_get_mpt+0xda>
	switch (page->pgmap->type) {
    10e5:	49 8b 47 08          	mov    0x8(%r15),%rax
    10e9:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    10ef:	83 e8 01             	sub    $0x1,%eax
    10f2:	83 f8 02             	cmp    $0x2,%eax
    10f5:	77 b3                	ja     10aa <f2fs_get_mpt+0xda>
		__put_devmap_managed_page(page);
    10f7:	4c 89 ff             	mov    %r15,%rdi
    10fa:	e8 00 00 00 00       	callq  10ff <f2fs_get_mpt+0x12f>
		return;
    10ff:	e9 01 ff ff ff       	jmpq   1005 <f2fs_get_mpt+0x35>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    1104:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    1106:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
    110a:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    110d:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    1111:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1118:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    111d:	e9 6d ff ff ff       	jmpq   108f <f2fs_get_mpt+0xbf>
    1122:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1129:	00 00 00 00 
    112d:	0f 1f 00             	nopl   (%rax)

0000000000001130 <f2fs_get_lfu>:
void f2fs_get_lfu(struct f2fs_sb_info *sbi) {
    1130:	f3 0f 1e fa          	endbr64 
    1134:	e8 00 00 00 00       	callq  1139 <f2fs_get_lfu+0x9>
    1139:	55                   	push   %rbp
    113a:	48 89 e5             	mov    %rsp,%rbp
    113d:	41 57                	push   %r15
    113f:	41 56                	push   %r14
    1141:	41 55                	push   %r13
    1143:	49 89 fd             	mov    %rdi,%r13
    1146:	41 54                	push   %r12
    1148:	53                   	push   %rbx
    1149:	48 83 ec 08          	sub    $0x8,%rsp
	lfu_blk_num = ((sbi->raw_super->segment_count_main + 1) * sizeof(atomic_t) - 1) / PAGE_SIZE + 1;
    114d:	48 8b 47 10          	mov    0x10(%rdi),%rax
	struct nvm_sb_info *nsbi = sbi->nsbi;
    1151:	4c 8b b7 48 07 00 00 	mov    0x748(%rdi),%r14
	start_blk = sbi->ckpt->ckpt_flags & CP_LFU_VER_FLAG ? nsbi->nsb->lfu_blkaddr1 : nsbi->nsb->lfu_blkaddr0;
    1158:	48 8b 8f 78 01 00 00 	mov    0x178(%rdi),%rcx
	lfu_blk_num = ((sbi->raw_super->segment_count_main + 1) * sizeof(atomic_t) - 1) / PAGE_SIZE + 1;
    115f:	8b 40 44             	mov    0x44(%rax),%eax
    1162:	49 8b 16             	mov    (%r14),%rdx
    1165:	83 c0 01             	add    $0x1,%eax
    1168:	48 8d 04 85 ff ff ff 	lea    -0x1(,%rax,4),%rax
    116f:	ff 
    1170:	48 c1 e8 0c          	shr    $0xc,%rax
    1174:	83 c0 01             	add    $0x1,%eax
	start_blk = sbi->ckpt->ckpt_flags & CP_LFU_VER_FLAG ? nsbi->nsb->lfu_blkaddr1 : nsbi->nsb->lfu_blkaddr0;
    1177:	f6 81 86 00 00 00 01 	testb  $0x1,0x86(%rcx)
    117e:	0f 84 46 01 00 00    	je     12ca <f2fs_get_lfu+0x19a>
    1184:	8b 5a 20             	mov    0x20(%rdx),%ebx
	for (i = 0; i < lfu_blk_num; ++i) {
    1187:	8d 14 03             	lea    (%rbx,%rax,1),%edx
    118a:	49 81 c6 98 00 00 00 	add    $0x98,%r14
    1191:	45 31 e4             	xor    %r12d,%r12d
    1194:	89 55 d4             	mov    %edx,-0x2c(%rbp)
    1197:	85 c0                	test   %eax,%eax
    1199:	7f 18                	jg     11b3 <f2fs_get_lfu+0x83>
    119b:	e9 cf 00 00 00       	jmpq   126f <f2fs_get_lfu+0x13f>
		start_blk++;
    11a0:	83 c3 01             	add    $0x1,%ebx
	for (i = 0; i < lfu_blk_num; ++i) {
    11a3:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
    11aa:	39 5d d4             	cmp    %ebx,-0x2c(%rbp)
    11ad:	0f 84 bc 00 00 00    	je     126f <f2fs_get_lfu+0x13f>
		lfu_page = f2fs_get_meta_page(sbi, start_blk);
    11b3:	48 63 f3             	movslq %ebx,%rsi
    11b6:	4c 89 ef             	mov    %r13,%rdi
    11b9:	e8 00 00 00 00       	callq  11be <f2fs_get_lfu+0x8e>
    11be:	49 89 c7             	mov    %rax,%r15
		dst_addr = nsbi->lfu_count + (PAGE_SIZE * i) / sizeof(atomic_t);
    11c1:	4c 89 e0             	mov    %r12,%rax
	return page_to_virt(page);
    11c4:	4c 89 fe             	mov    %r15,%rsi
    11c7:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 11ce <f2fs_get_lfu+0x9e>
    11ce:	48 c1 e8 02          	shr    $0x2,%rax
    11d2:	48 c1 fe 06          	sar    $0x6,%rsi
    11d6:	49 8d 0c c6          	lea    (%r14,%rax,8),%rcx
    11da:	48 c1 e6 0c          	shl    $0xc,%rsi
    11de:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 11e5 <f2fs_get_lfu+0xb5>
    11e5:	48 8d 79 08          	lea    0x8(%rcx),%rdi
    11e9:	48 8b 06             	mov    (%rsi),%rax
    11ec:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    11f0:	48 89 01             	mov    %rax,(%rcx)
    11f3:	48 8b 86 f8 0f 00 00 	mov    0xff8(%rsi),%rax
    11fa:	48 89 81 f8 0f 00 00 	mov    %rax,0xff8(%rcx)
    1201:	48 29 f9             	sub    %rdi,%rcx
    1204:	48 29 ce             	sub    %rcx,%rsi
    1207:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    120d:	c1 e9 03             	shr    $0x3,%ecx
    1210:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	if (!page)
    1213:	4d 85 ff             	test   %r15,%r15
    1216:	74 88                	je     11a0 <f2fs_get_lfu+0x70>
    1218:	49 8b 57 08          	mov    0x8(%r15),%rdx
    121c:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    1220:	83 e2 01             	and    $0x1,%edx
    1223:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    1227:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    122a:	a8 01                	test   $0x1,%al
    122c:	74 7e                	je     12ac <f2fs_get_lfu+0x17c>
		unlock_page(page);
    122e:	4c 89 ff             	mov    %r15,%rdi
    1231:	e8 00 00 00 00       	callq  1236 <f2fs_get_lfu+0x106>
    1236:	49 8b 47 08          	mov    0x8(%r15),%rax
    123a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    123e:	a8 01                	test   $0x1,%al
    1240:	4c 0f 45 fa          	cmovne %rdx,%r15
    1244:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    1249:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
    124e:	0f 85 4c ff ff ff    	jne    11a0 <f2fs_get_lfu+0x70>
		__put_page(page);
    1254:	4c 89 ff             	mov    %r15,%rdi
		start_blk++;
    1257:	83 c3 01             	add    $0x1,%ebx
    125a:	49 81 c4 00 10 00 00 	add    $0x1000,%r12
    1261:	e8 00 00 00 00       	callq  1266 <f2fs_get_lfu+0x136>
	for (i = 0; i < lfu_blk_num; ++i) {
    1266:	39 5d d4             	cmp    %ebx,-0x2c(%rbp)
    1269:	0f 85 44 ff ff ff    	jne    11b3 <f2fs_get_lfu+0x83>
}
    126f:	48 83 c4 08          	add    $0x8,%rsp
    1273:	5b                   	pop    %rbx
    1274:	41 5c                	pop    %r12
    1276:	41 5d                	pop    %r13
    1278:	41 5e                	pop    %r14
    127a:	41 5f                	pop    %r15
    127c:	5d                   	pop    %rbp
    127d:	c3                   	retq   
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    127e:	49 8b 07             	mov    (%r15),%rax
    1281:	48 c1 e8 33          	shr    $0x33,%rax
    1285:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    1288:	83 f8 04             	cmp    $0x4,%eax
    128b:	75 bc                	jne    1249 <f2fs_get_lfu+0x119>
	switch (page->pgmap->type) {
    128d:	49 8b 47 08          	mov    0x8(%r15),%rax
    1291:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    1297:	83 e8 01             	sub    $0x1,%eax
    129a:	83 f8 02             	cmp    $0x2,%eax
    129d:	77 aa                	ja     1249 <f2fs_get_lfu+0x119>
		__put_devmap_managed_page(page);
    129f:	4c 89 ff             	mov    %r15,%rdi
    12a2:	e8 00 00 00 00       	callq  12a7 <f2fs_get_lfu+0x177>
		return;
    12a7:	e9 f4 fe ff ff       	jmpq   11a0 <f2fs_get_lfu+0x70>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    12ac:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    12ae:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
    12b2:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    12b5:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    12b9:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    12c0:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    12c5:	e9 64 ff ff ff       	jmpq   122e <f2fs_get_lfu+0xfe>
	start_blk = sbi->ckpt->ckpt_flags & CP_LFU_VER_FLAG ? nsbi->nsb->lfu_blkaddr1 : nsbi->nsb->lfu_blkaddr0;
    12ca:	8b 5a 1c             	mov    0x1c(%rdx),%ebx
    12cd:	e9 b5 fe ff ff       	jmpq   1187 <f2fs_get_lfu+0x57>
    12d2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    12d9:	00 00 00 00 
    12dd:	0f 1f 00             	nopl   (%rax)

00000000000012e0 <init_max_heap>:
struct max_heap *init_max_heap(struct f2fs_sb_info *sbi, int k) {
    12e0:	f3 0f 1e fa          	endbr64 
    12e4:	e8 00 00 00 00       	callq  12e9 <init_max_heap+0x9>
    12e9:	55                   	push   %rbp
	return kvmalloc_node(size, flags, NUMA_NO_NODE);
    12ea:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    12ef:	bf 18 00 00 00       	mov    $0x18,%edi
    12f4:	48 89 e5             	mov    %rsp,%rbp
    12f7:	41 54                	push   %r12
    12f9:	53                   	push   %rbx
    12fa:	89 f3                	mov    %esi,%ebx
    12fc:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1301:	e8 00 00 00 00       	callq  1306 <init_max_heap+0x26>
	mh->nodes = f2fs_kvzalloc(sbi, k * sizeof(struct heap_node), GFP_KERNEL);
    1306:	48 63 fb             	movslq %ebx,%rdi
    1309:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    130e:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1313:	48 c1 e7 04          	shl    $0x4,%rdi
    1317:	49 89 c4             	mov    %rax,%r12
    131a:	e8 00 00 00 00       	callq  131f <init_max_heap+0x3f>
	mh->k = k;
    131f:	41 89 5c 24 0c       	mov    %ebx,0xc(%r12)
	mh->nodes = f2fs_kvzalloc(sbi, k * sizeof(struct heap_node), GFP_KERNEL);
    1324:	49 89 04 24          	mov    %rax,(%r12)
}
    1328:	4c 89 e0             	mov    %r12,%rax
	mh->cur_num = 0;
    132b:	41 c7 44 24 08 00 00 	movl   $0x0,0x8(%r12)
    1332:	00 00 
	mh->max_count = 0;
    1334:	41 c7 44 24 10 00 00 	movl   $0x0,0x10(%r12)
    133b:	00 00 
}
    133d:	5b                   	pop    %rbx
    133e:	41 5c                	pop    %r12
    1340:	5d                   	pop    %rbp
    1341:	c3                   	retq   
    1342:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1349:	00 00 00 00 
    134d:	0f 1f 00             	nopl   (%rax)

0000000000001350 <init_min_heap>:
struct min_heap *init_min_heap(struct f2fs_sb_info *sbi, int k) {
    1350:	f3 0f 1e fa          	endbr64 
    1354:	e8 00 00 00 00       	callq  1359 <init_min_heap+0x9>
    1359:	55                   	push   %rbp
    135a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    135f:	bf 18 00 00 00       	mov    $0x18,%edi
    1364:	48 89 e5             	mov    %rsp,%rbp
    1367:	41 54                	push   %r12
    1369:	53                   	push   %rbx
    136a:	89 f3                	mov    %esi,%ebx
    136c:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1371:	e8 00 00 00 00       	callq  1376 <init_min_heap+0x26>
	minh->nodes = f2fs_kvzalloc(sbi, k * sizeof(struct heap_node), GFP_KERNEL);
    1376:	48 63 fb             	movslq %ebx,%rdi
    1379:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    137e:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1383:	48 c1 e7 04          	shl    $0x4,%rdi
    1387:	49 89 c4             	mov    %rax,%r12
    138a:	e8 00 00 00 00       	callq  138f <init_min_heap+0x3f>
	minh->k = k;
    138f:	41 89 5c 24 0c       	mov    %ebx,0xc(%r12)
	minh->nodes = f2fs_kvzalloc(sbi, k * sizeof(struct heap_node), GFP_KERNEL);
    1394:	49 89 04 24          	mov    %rax,(%r12)
}
    1398:	4c 89 e0             	mov    %r12,%rax
	minh->cur_num = 0;
    139b:	41 c7 44 24 08 00 00 	movl   $0x0,0x8(%r12)
    13a2:	00 00 
	minh->min_count = 0;
    13a4:	41 c7 44 24 10 00 00 	movl   $0x0,0x10(%r12)
    13ab:	00 00 
}
    13ad:	5b                   	pop    %rbx
    13ae:	41 5c                	pop    %r12
    13b0:	5d                   	pop    %rbp
    13b1:	c3                   	retq   
    13b2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    13b9:	00 00 00 00 
    13bd:	0f 1f 00             	nopl   (%rax)

00000000000013c0 <init_nvm_sb_info>:
unsigned int init_nvm_sb_info(struct f2fs_sb_info *sbi, struct nvm_super_block *nsb) {
    13c0:	f3 0f 1e fa          	endbr64 
    13c4:	e8 00 00 00 00       	callq  13c9 <init_nvm_sb_info+0x9>
    13c9:	55                   	push   %rbp
    13ca:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    13cf:	48 89 e5             	mov    %rsp,%rbp
    13d2:	41 56                	push   %r14
    13d4:	41 55                	push   %r13
    13d6:	49 89 fd             	mov    %rdi,%r13
    13d9:	41 54                	push   %r12
    13db:	53                   	push   %rbx
	struct nvm_sb_info *nsbi = sbi->nsbi;
    13dc:	4c 8b a7 48 07 00 00 	mov    0x748(%rdi),%r12
unsigned int init_nvm_sb_info(struct f2fs_sb_info *sbi, struct nvm_super_block *nsb) {
    13e3:	48 89 f3             	mov    %rsi,%rbx
	nsbi->nsb = nsb;
    13e6:	49 89 34 24          	mov    %rsi,(%r12)
	nsbi->byte_private = NULL;
    13ea:	49 c7 84 24 08 01 00 	movq   $0x0,0x108(%r12)
    13f1:	00 00 00 00 00 
	nsbi->mpt_ver_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(nsb->mpt_ver_map_bits), GFP_KERNEL);
    13f6:	8b 7e 34             	mov    0x34(%rsi),%edi
    13f9:	be c0 80 60 00       	mov    $0x6080c0,%esi
    13fe:	48 83 c7 3f          	add    $0x3f,%rdi
    1402:	48 c1 ef 06          	shr    $0x6,%rdi
    1406:	48 c1 e7 03          	shl    $0x3,%rdi
    140a:	e8 00 00 00 00       	callq  140f <init_nvm_sb_info+0x4f>
    140f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    1414:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1419:	49 89 44 24 68       	mov    %rax,0x68(%r12)
	nsbi->segment_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(nsb->main_segment_nums), GFP_KERNEL);
    141e:	8b 7b 2c             	mov    0x2c(%rbx),%edi
    1421:	48 83 c7 3f          	add    $0x3f,%rdi
    1425:	48 c1 ef 06          	shr    $0x6,%rdi
    1429:	48 c1 e7 03          	shl    $0x3,%rdi
    142d:	e8 00 00 00 00       	callq  1432 <init_nvm_sb_info+0x72>
    1432:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    1437:	be c0 80 60 00       	mov    $0x6080c0,%esi
    143c:	49 89 44 24 78       	mov    %rax,0x78(%r12)
	nsbi->ckpt_segment_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(nsb->main_segment_nums), GFP_KERNEL);
    1441:	8b 7b 2c             	mov    0x2c(%rbx),%edi
    1444:	48 83 c7 3f          	add    $0x3f,%rdi
    1448:	48 c1 ef 06          	shr    $0x6,%rdi
    144c:	48 c1 e7 03          	shl    $0x3,%rdi
    1450:	e8 00 00 00 00       	callq  1455 <init_nvm_sb_info+0x95>
    1455:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    145a:	be c0 80 60 00       	mov    $0x6080c0,%esi
    145f:	49 89 84 24 80 00 00 	mov    %rax,0x80(%r12)
    1466:	00 
	nsbi->mpt_dirty_map_bits = nsb->mpt_ver_map_bits;
    1467:	8b 7b 34             	mov    0x34(%rbx),%edi
    146a:	41 89 7c 24 60       	mov    %edi,0x60(%r12)
	nsbi->mpt_dirty_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(nsbi->mpt_dirty_map_bits), GFP_KERNEL);
    146f:	48 83 c7 3f          	add    $0x3f,%rdi
    1473:	48 c1 ef 06          	shr    $0x6,%rdi
    1477:	48 c1 e7 03          	shl    $0x3,%rdi
    147b:	e8 00 00 00 00       	callq  1480 <init_nvm_sb_info+0xc0>
	if (!(nsbi->mpt_ver_map && nsbi->segment_map && nsbi->mpt_dirty_map)) {
    1480:	49 83 7c 24 68 00    	cmpq   $0x0,0x68(%r12)
	nsbi->mpt_dirty_map = f2fs_kvzalloc(sbi, f2fs_bitmap_size(nsbi->mpt_dirty_map_bits), GFP_KERNEL);
    1486:	49 89 44 24 58       	mov    %rax,0x58(%r12)
	if (!(nsbi->mpt_ver_map && nsbi->segment_map && nsbi->mpt_dirty_map)) {
    148b:	74 0d                	je     149a <init_nvm_sb_info+0xda>
    148d:	49 83 7c 24 78 00    	cmpq   $0x0,0x78(%r12)
    1493:	74 05                	je     149a <init_nvm_sb_info+0xda>
    1495:	48 85 c0             	test   %rax,%rax
    1498:	75 0e                	jne    14a8 <init_nvm_sb_info+0xe8>
		return -ENOMEM;
    149a:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
    149f:	5b                   	pop    %rbx
    14a0:	41 5c                	pop    %r12
    14a2:	41 5d                	pop    %r13
    14a4:	41 5e                	pop    %r14
    14a6:	5d                   	pop    %rbp
    14a7:	c3                   	retq   
	mutex_init(&nsbi->nvmgc_mutex);
    14a8:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    14af:	49 8d 7c 24 30       	lea    0x30(%r12),%rdi
    14b4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    14bb:	e8 00 00 00 00       	callq  14c0 <init_nvm_sb_info+0x100>
	printk(KERN_INFO"ZN trap: mpt_entries size = %d", nsb->mpt_entries);
    14c0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	spin_lock_init(&nsbi->mpt_ver_map_lock);
    14c7:	41 c7 44 24 70 00 00 	movl   $0x0,0x70(%r12)
    14ce:	00 00 
	spin_lock_init(&nsbi->segment_map_lock);
    14d0:	4d 8d b4 24 98 00 00 	lea    0x98(%r12),%r14
    14d7:	00 
    14d8:	41 c7 84 24 88 00 00 	movl   $0x0,0x88(%r12)
    14df:	00 00 00 00 00 
	spin_lock_init(&nsbi->mpt_lock);
    14e4:	41 c7 44 24 64 00 00 	movl   $0x0,0x64(%r12)
    14eb:	00 00 
	spin_lock_init(&nsbi->lfu_half_lock);
    14ed:	41 c7 84 24 b8 00 00 	movl   $0x0,0xb8(%r12)
    14f4:	00 00 00 00 00 
	spin_lock_init(&nsbi->aqusz_lock);
    14f9:	41 c7 84 24 00 01 00 	movl   $0x0,0x100(%r12)
    1500:	00 00 00 00 00 
	printk(KERN_INFO"ZN trap: mpt_entries size = %d", nsb->mpt_entries);
    1505:	8b 73 38             	mov    0x38(%rbx),%esi
    1508:	e8 00 00 00 00       	callq  150d <init_nvm_sb_info+0x14d>
	nsbi->mpt = f2fs_kvzalloc(sbi, ((nsb->mpt_entries * sizeof(unsigned int) - 1) / PAGE_SIZE + 1) * PAGE_SIZE,
    150d:	8b 43 38             	mov    0x38(%rbx),%eax
    1510:	83 ca ff             	or     $0xffffffff,%edx
    1513:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1518:	49 8d 9c 24 b8 00 00 	lea    0xb8(%r12),%rbx
    151f:	00 
    1520:	48 8d 04 85 ff ff ff 	lea    -0x1(,%rax,4),%rax
    1527:	ff 
    1528:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
    152e:	48 8d b8 00 10 00 00 	lea    0x1000(%rax),%rdi
    1535:	e8 00 00 00 00       	callq  153a <init_nvm_sb_info+0x17a>
    153a:	49 89 44 24 50       	mov    %rax,0x50(%r12)
										   (((sbi->raw_super->segment_count_main + 1) * sizeof(atomic_t) - 1) /
    153f:	49 8b 45 10          	mov    0x10(%r13),%rax
    1543:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    1548:	be c0 80 60 00       	mov    $0x6080c0,%esi
    154d:	8b 40 44             	mov    0x44(%rax),%eax
    1550:	83 c0 01             	add    $0x1,%eax
    1553:	48 8d 04 85 ff ff ff 	lea    -0x1(,%rax,4),%rax
    155a:	ff 
											PAGE_SIZE + 1) * PAGE_SIZE, GFP_KERNEL);
    155b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
		nsbi->lfu_count[i] = f2fs_kvzalloc(sbi,
    1561:	48 8d b8 00 10 00 00 	lea    0x1000(%rax),%rdi
    1568:	e8 00 00 00 00       	callq  156d <init_nvm_sb_info+0x1ad>
    156d:	49 89 06             	mov    %rax,(%r14)
    1570:	48 89 c1             	mov    %rax,%rcx
		for (j = 0; j < sbi->raw_super->segment_count_main; j++) {
    1573:	49 8b 45 10          	mov    0x10(%r13),%rax
    1577:	8b 50 44             	mov    0x44(%rax),%edx
    157a:	85 d2                	test   %edx,%edx
    157c:	74 22                	je     15a0 <init_nvm_sb_info+0x1e0>
    157e:	31 c0                	xor    %eax,%eax
    1580:	eb 03                	jmp    1585 <init_nvm_sb_info+0x1c5>
    1582:	49 8b 0e             	mov    (%r14),%rcx
			atomic_set(&nsbi->lfu_count[i][j], -1);
    1585:	48 63 d0             	movslq %eax,%rdx
		for (j = 0; j < sbi->raw_super->segment_count_main; j++) {
    1588:	83 c0 01             	add    $0x1,%eax
			atomic_set(&nsbi->lfu_count[i][j], -1);
    158b:	48 8d 14 91          	lea    (%rcx,%rdx,4),%rdx
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
    158f:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%rdx)
		for (j = 0; j < sbi->raw_super->segment_count_main; j++) {
    1595:	49 8b 55 10          	mov    0x10(%r13),%rdx
    1599:	8b 52 44             	mov    0x44(%rdx),%edx
    159c:	39 c2                	cmp    %eax,%edx
    159e:	77 e2                	ja     1582 <init_nvm_sb_info+0x1c2>
		atomic_set(&nsbi->lfu_count[i][sbi->raw_super->segment_count_main], 0);
    15a0:	49 8b 06             	mov    (%r14),%rax
    15a3:	49 83 c6 08          	add    $0x8,%r14
    15a7:	48 8d 04 90          	lea    (%rax,%rdx,4),%rax
    15ab:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	for (i = 0; i < LFU_LEVELS; i++) {
    15b1:	4c 39 f3             	cmp    %r14,%rbx
    15b4:	75 89                	jne    153f <init_nvm_sb_info+0x17f>
	nsbi->now_lfu_counter = 0;//初始化当前计数器为第一个计数器
    15b6:	41 c7 84 24 90 00 00 	movl   $0x0,0x90(%r12)
    15bd:	00 00 00 00 00 
	nsbi->mh = init_max_heap(sbi, NVM_TO_SSD);
    15c2:	be 32 00 00 00       	mov    $0x32,%esi
    15c7:	4c 89 ef             	mov    %r13,%rdi
    15ca:	e8 00 00 00 00       	callq  15cf <init_nvm_sb_info+0x20f>
	nsbi->minh = init_min_heap(sbi, SSD_TO_NVM);
    15cf:	be 14 00 00 00       	mov    $0x14,%esi
    15d4:	4c 89 ef             	mov    %r13,%rdi
	nsbi->mh = init_max_heap(sbi, NVM_TO_SSD);
    15d7:	49 89 84 24 c0 00 00 	mov    %rax,0xc0(%r12)
    15de:	00 
	nsbi->minh = init_min_heap(sbi, SSD_TO_NVM);
    15df:	e8 00 00 00 00       	callq  15e4 <init_nvm_sb_info+0x224>
extern struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);

static inline struct page *
alloc_pages(gfp_t gfp_mask, unsigned int order)
{
	return alloc_pages_current(gfp_mask, order);
    15e4:	bf c0 00 60 00       	mov    $0x6000c0,%edi
    15e9:	49 89 84 24 c8 00 00 	mov    %rax,0xc8(%r12)
    15f0:	00 
    15f1:	41 8b b5 20 04 00 00 	mov    0x420(%r13),%esi
    15f8:	e8 00 00 00 00       	callq  15fd <init_nvm_sb_info+0x23d>
    15fd:	bf c0 00 60 00       	mov    $0x6000c0,%edi
	nsbi->nvm_gc_start_page = alloc_pages(GFP_KERNEL, sbi->log_blocks_per_seg);// 分配用于NVM-GC段迁移的连续物理内存页
    1602:	49 89 84 24 d0 00 00 	mov    %rax,0xd0(%r12)
    1609:	00 
    160a:	41 8b b5 20 04 00 00 	mov    0x420(%r13),%esi
    1611:	e8 00 00 00 00       	callq  1616 <init_nvm_sb_info+0x256>
	nvm_assert(nsbi->nvm_gc_start_page);
    1616:	49 83 bc 24 d0 00 00 	cmpq   $0x0,0xd0(%r12)
    161d:	00 00 
	nsbi->ssd_to_nvm_start_page = alloc_pages(GFP_KERNEL, sbi->log_blocks_per_seg);// 分配用于NVM-GC段迁移的连续物理内存页
    161f:	49 89 84 24 d8 00 00 	mov    %rax,0xd8(%r12)
    1626:	00 
	nvm_assert(nsbi->nvm_gc_start_page);
    1627:	74 27                	je     1650 <init_nvm_sb_info+0x290>
	nvm_assert(nsbi->ssd_to_nvm_start_page);
    1629:	48 85 c0             	test   %rax,%rax
    162c:	74 24                	je     1652 <init_nvm_sb_info+0x292>
	if (!nsbi->lfu_count[0] || !nsbi->mpt)
    162e:	49 83 bc 24 98 00 00 	cmpq   $0x0,0x98(%r12)
    1635:	00 00 
    1637:	0f 84 5d fe ff ff    	je     149a <init_nvm_sb_info+0xda>
    163d:	49 83 7c 24 50 00    	cmpq   $0x0,0x50(%r12)
    1643:	0f 84 51 fe ff ff    	je     149a <init_nvm_sb_info+0xda>
	return 0;
    1649:	31 c0                	xor    %eax,%eax
    164b:	e9 4f fe ff ff       	jmpq   149f <init_nvm_sb_info+0xdf>
	nvm_assert(nsbi->nvm_gc_start_page);
    1650:	0f 0b                	ud2    
	nvm_assert(nsbi->ssd_to_nvm_start_page);
    1652:	0f 0b                	ud2    
    1654:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    165b:	00 00 00 00 
    165f:	90                   	nop

0000000000001660 <read_nvm_super_block>:
int read_nvm_super_block(struct f2fs_sb_info *sbi, int *recovery) {
    1660:	f3 0f 1e fa          	endbr64 
    1664:	e8 00 00 00 00       	callq  1669 <read_nvm_super_block+0x9>
    1669:	55                   	push   %rbp
			unsigned int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    166a:	ba 40 00 00 00       	mov    $0x40,%edx
    166f:	48 89 e5             	mov    %rsp,%rbp
    1672:	41 57                	push   %r15
    1674:	49 89 ff             	mov    %rdi,%r15
    1677:	41 56                	push   %r14
    1679:	41 55                	push   %r13
    167b:	41 54                	push   %r12
    167d:	53                   	push   %rbx
    167e:	48 83 ec 10          	sub    $0x10,%rsp
	struct nvm_sb_info *nsbi = sbi->nsbi;
    1682:	4c 8b af 48 07 00 00 	mov    0x748(%rdi),%r13
int read_nvm_super_block(struct f2fs_sb_info *sbi, int *recovery) {
    1689:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    168d:	be c0 80 60 00       	mov    $0x6080c0,%esi
    1692:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1699 <read_nvm_super_block+0x39>
    1699:	e8 00 00 00 00       	callq  169e <read_nvm_super_block+0x3e>
	if (!super)
    169e:	48 85 c0             	test   %rax,%rax
    16a1:	0f 84 a9 03 00 00    	je     1a50 <read_nvm_super_block+0x3f0>
    16a7:	49 89 c6             	mov    %rax,%r14
	block = sbi->ckpt->ckpt_flags & CP_NSB_VER_FLAG ? 1 : 0;
    16aa:	49 8b 87 78 01 00 00 	mov    0x178(%r15),%rax
	page = f2fs_get_meta_page(sbi, block);
    16b1:	4c 89 ff             	mov    %r15,%rdi
	block = sbi->ckpt->ckpt_flags & CP_NSB_VER_FLAG ? 1 : 0;
    16b4:	8b b0 84 00 00 00    	mov    0x84(%rax),%esi
    16ba:	c1 ee 0c             	shr    $0xc,%esi
	page = f2fs_get_meta_page(sbi, block);
    16bd:	83 e6 01             	and    $0x1,%esi
    16c0:	e8 00 00 00 00       	callq  16c5 <read_nvm_super_block+0x65>
    16c5:	49 89 c4             	mov    %rax,%r12
	if (!page) {
    16c8:	48 85 c0             	test   %rax,%rax
    16cb:	0f 84 61 01 00 00    	je     1832 <read_nvm_super_block+0x1d2>
	return page_to_virt(page);
    16d1:	48 89 c3             	mov    %rax,%rbx
    16d4:	48 2b 1d 00 00 00 00 	sub    0x0(%rip),%rbx        # 16db <read_nvm_super_block+0x7b>
	if (sanity_check_nvm_super(sbi, nsb_page)) {
    16db:	4c 89 ff             	mov    %r15,%rdi
    16de:	48 c1 fb 06          	sar    $0x6,%rbx
    16e2:	48 c1 e3 0c          	shl    $0xc,%rbx
    16e6:	48 03 1d 00 00 00 00 	add    0x0(%rip),%rbx        # 16ed <read_nvm_super_block+0x8d>
    16ed:	48 89 de             	mov    %rbx,%rsi
    16f0:	e8 00 00 00 00       	callq  16f5 <read_nvm_super_block+0x95>
    16f5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
    16f8:	85 c0                	test   %eax,%eax
    16fa:	0f 85 29 02 00 00    	jne    1929 <read_nvm_super_block+0x2c9>
    1700:	48 8b 03             	mov    (%rbx),%rax
	if (init_nvm_sb_info(sbi, super)) {
    1703:	4c 89 f6             	mov    %r14,%rsi
    1706:	4c 89 ff             	mov    %r15,%rdi
    1709:	49 89 06             	mov    %rax,(%r14)
    170c:	48 8b 43 08          	mov    0x8(%rbx),%rax
    1710:	49 89 46 08          	mov    %rax,0x8(%r14)
    1714:	48 8b 43 10          	mov    0x10(%rbx),%rax
    1718:	49 89 46 10          	mov    %rax,0x10(%r14)
    171c:	48 8b 43 18          	mov    0x18(%rbx),%rax
    1720:	49 89 46 18          	mov    %rax,0x18(%r14)
    1724:	48 8b 43 20          	mov    0x20(%rbx),%rax
    1728:	49 89 46 20          	mov    %rax,0x20(%r14)
    172c:	48 8b 43 28          	mov    0x28(%rbx),%rax
    1730:	49 89 46 28          	mov    %rax,0x28(%r14)
    1734:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1738:	49 89 46 30          	mov    %rax,0x30(%r14)
    173c:	48 8b 43 38          	mov    0x38(%rbx),%rax
    1740:	49 89 46 38          	mov    %rax,0x38(%r14)
    1744:	e8 00 00 00 00       	callq  1749 <read_nvm_super_block+0xe9>
    1749:	85 c0                	test   %eax,%eax
    174b:	0f 85 85 01 00 00    	jne    18d6 <read_nvm_super_block+0x276>
	mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;  // mpt版本位图占用字节数
    1751:	49 8b 45 00          	mov    0x0(%r13),%rax
	memcpy(nsbi->mpt_ver_map, &nsb_page->map[0], mpt_ver_map_bytes);
    1755:	48 83 c3 3c          	add    $0x3c,%rbx
    1759:	49 8b 7d 68          	mov    0x68(%r13),%rdi
    175d:	48 89 de             	mov    %rbx,%rsi
	segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1; // segment位图占用字节数
    1760:	8b 48 2c             	mov    0x2c(%rax),%ecx
    1763:	44 8d 79 ff          	lea    -0x1(%rcx),%r15d
	mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;  // mpt版本位图占用字节数
    1767:	8b 48 34             	mov    0x34(%rax),%ecx
	segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1; // segment位图占用字节数
    176a:	41 c1 ef 03          	shr    $0x3,%r15d
	mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;  // mpt版本位图占用字节数
    176e:	83 e9 01             	sub    $0x1,%ecx
	segment_map_bytes = (nsbi->nsb->main_segment_nums - 1) / BITS_PER_BYTE + 1; // segment位图占用字节数
    1771:	41 83 c7 01          	add    $0x1,%r15d
	mpt_ver_map_bytes = (nsbi->nsb->mpt_ver_map_bits - 1) / BITS_PER_BYTE + 1;  // mpt版本位图占用字节数
    1775:	c1 e9 03             	shr    $0x3,%ecx
    1778:	44 8d 71 01          	lea    0x1(%rcx),%r14d
    177c:	4c 89 f2             	mov    %r14,%rdx
    177f:	e8 00 00 00 00       	callq  1784 <read_nvm_super_block+0x124>
    1784:	49 8b 7d 78          	mov    0x78(%r13),%rdi
	memcpy(nsbi->segment_map, &nsb_page->map[0] + mpt_ver_map_bytes, segment_map_bytes);
    1788:	4a 8d 34 33          	lea    (%rbx,%r14,1),%rsi
    178c:	4c 89 fa             	mov    %r15,%rdx
    178f:	e8 00 00 00 00       	callq  1794 <read_nvm_super_block+0x134>
    1794:	49 8b bd 80 00 00 00 	mov    0x80(%r13),%rdi
    179b:	49 8b 75 78          	mov    0x78(%r13),%rsi
    179f:	4c 89 fa             	mov    %r15,%rdx
    17a2:	e8 00 00 00 00       	callq  17a7 <read_nvm_super_block+0x147>
	if (!page)
    17a7:	4d 85 e4             	test   %r12,%r12
    17aa:	74 47                	je     17f3 <read_nvm_super_block+0x193>
	__READ_ONCE_SIZE;
    17ac:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    17b1:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    17b5:	83 e2 01             	and    $0x1,%edx
    17b8:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    17bc:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    17bf:	a8 01                	test   $0x1,%al
    17c1:	0f 84 f0 00 00 00    	je     18b7 <read_nvm_super_block+0x257>
		unlock_page(page);
    17c7:	4c 89 e7             	mov    %r12,%rdi
    17ca:	e8 00 00 00 00       	callq  17cf <read_nvm_super_block+0x16f>
    17cf:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    17d4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    17d8:	a8 01                	test   $0x1,%al
    17da:	4c 0f 45 e2          	cmovne %rdx,%r12
    17de:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    17e3:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    17e9:	75 08                	jne    17f3 <read_nvm_super_block+0x193>
		__put_page(page);
    17eb:	4c 89 e7             	mov    %r12,%rdi
    17ee:	e8 00 00 00 00       	callq  17f3 <read_nvm_super_block+0x193>
}
    17f3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    17f6:	48 83 c4 10          	add    $0x10,%rsp
    17fa:	5b                   	pop    %rbx
    17fb:	41 5c                	pop    %r12
    17fd:	41 5d                	pop    %r13
    17ff:	41 5e                	pop    %r14
    1801:	41 5f                	pop    %r15
    1803:	5d                   	pop    %rbp
    1804:	c3                   	retq   
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    1805:	49 8b 04 24          	mov    (%r12),%rax
    1809:	48 c1 e8 33          	shr    $0x33,%rax
    180d:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    1810:	83 f8 04             	cmp    $0x4,%eax
    1813:	75 ce                	jne    17e3 <read_nvm_super_block+0x183>
	switch (page->pgmap->type) {
    1815:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    181a:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    1820:	83 e8 01             	sub    $0x1,%eax
    1823:	83 f8 02             	cmp    $0x2,%eax
    1826:	77 bb                	ja     17e3 <read_nvm_super_block+0x183>
		__put_devmap_managed_page(page);
    1828:	4c 89 e7             	mov    %r12,%rdi
    182b:	e8 00 00 00 00       	callq  1830 <read_nvm_super_block+0x1d0>
		return;
    1830:	eb c1                	jmp    17f3 <read_nvm_super_block+0x193>
	return page_to_virt(page);
    1832:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 1839 <read_nvm_super_block+0x1d9>
	if (sanity_check_nvm_super(sbi, nsb_page)) {
    1839:	4c 89 ff             	mov    %r15,%rdi
    183c:	48 f7 db             	neg    %rbx
    183f:	48 c1 fb 06          	sar    $0x6,%rbx
    1843:	48 c1 e3 0c          	shl    $0xc,%rbx
    1847:	48 03 1d 00 00 00 00 	add    0x0(%rip),%rbx        # 184e <read_nvm_super_block+0x1ee>
    184e:	48 89 de             	mov    %rbx,%rsi
    1851:	e8 00 00 00 00       	callq  1856 <read_nvm_super_block+0x1f6>
    1856:	85 c0                	test   %eax,%eax
    1858:	0f 85 a5 01 00 00    	jne    1a03 <read_nvm_super_block+0x3a3>
    185e:	48 8b 03             	mov    (%rbx),%rax
	if (init_nvm_sb_info(sbi, super)) {
    1861:	4c 89 f6             	mov    %r14,%rsi
    1864:	4c 89 ff             	mov    %r15,%rdi
    1867:	49 89 06             	mov    %rax,(%r14)
    186a:	48 8b 43 08          	mov    0x8(%rbx),%rax
    186e:	49 89 46 08          	mov    %rax,0x8(%r14)
    1872:	48 8b 43 10          	mov    0x10(%rbx),%rax
    1876:	49 89 46 10          	mov    %rax,0x10(%r14)
    187a:	48 8b 43 18          	mov    0x18(%rbx),%rax
    187e:	49 89 46 18          	mov    %rax,0x18(%r14)
    1882:	48 8b 43 20          	mov    0x20(%rbx),%rax
    1886:	49 89 46 20          	mov    %rax,0x20(%r14)
    188a:	48 8b 43 28          	mov    0x28(%rbx),%rax
    188e:	49 89 46 28          	mov    %rax,0x28(%r14)
    1892:	48 8b 43 30          	mov    0x30(%rbx),%rax
    1896:	49 89 46 30          	mov    %rax,0x30(%r14)
    189a:	48 8b 43 38          	mov    0x38(%rbx),%rax
    189e:	49 89 46 38          	mov    %rax,0x38(%r14)
    18a2:	e8 00 00 00 00       	callq  18a7 <read_nvm_super_block+0x247>
    18a7:	85 c0                	test   %eax,%eax
    18a9:	75 72                	jne    191d <read_nvm_super_block+0x2bd>
		err = -EIO;
    18ab:	c7 45 d4 fb ff ff ff 	movl   $0xfffffffb,-0x2c(%rbp)
    18b2:	e9 9a fe ff ff       	jmpq   1751 <read_nvm_super_block+0xf1>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    18b7:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    18b9:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    18be:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    18c1:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    18c5:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    18cc:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    18d1:	e9 f1 fe ff ff       	jmpq   17c7 <read_nvm_super_block+0x167>
    18d6:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    18db:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    18df:	83 e2 01             	and    $0x1,%edx
    18e2:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    18e6:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    18e9:	a8 01                	test   $0x1,%al
    18eb:	0f 84 40 01 00 00    	je     1a31 <read_nvm_super_block+0x3d1>
		unlock_page(page);
    18f1:	4c 89 e7             	mov    %r12,%rdi
    18f4:	e8 00 00 00 00       	callq  18f9 <read_nvm_super_block+0x299>
    18f9:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    18fe:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    1902:	a8 01                	test   $0x1,%al
    1904:	4c 0f 45 e2          	cmovne %rdx,%r12
    1908:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    190d:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    1913:	75 08                	jne    191d <read_nvm_super_block+0x2bd>
		__put_page(page);
    1915:	4c 89 e7             	mov    %r12,%rdi
    1918:	e8 00 00 00 00       	callq  191d <read_nvm_super_block+0x2bd>
		return err;
    191d:	c7 45 d4 ea ff ff ff 	movl   $0xffffffea,-0x2c(%rbp)
    1924:	e9 ca fe ff ff       	jmpq   17f3 <read_nvm_super_block+0x193>
		*recovery = 1;
    1929:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    192d:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    1933:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
	if (unlikely(head & 1))
    1938:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    193c:	83 e2 01             	and    $0x1,%edx
    193f:	49 0f 44 c4          	cmove  %r12,%rax
    1943:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    1946:	a8 01                	test   $0x1,%al
    1948:	0f 84 c4 00 00 00    	je     1a12 <read_nvm_super_block+0x3b2>
		unlock_page(page);
    194e:	4c 89 e7             	mov    %r12,%rdi
    1951:	e8 00 00 00 00       	callq  1956 <read_nvm_super_block+0x2f6>
    1956:	49 8b 44 24 08       	mov    0x8(%r12),%rax
		return (struct page *) (head - 1);
    195b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    195f:	a8 01                	test   $0x1,%al
    1961:	4c 0f 45 e2          	cmovne %rdx,%r12
    1965:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    196a:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    1970:	0f 84 80 00 00 00    	je     19f6 <read_nvm_super_block+0x396>
		kfree(super);
    1976:	4c 89 f7             	mov    %r14,%rdi
    1979:	e8 00 00 00 00       	callq  197e <read_nvm_super_block+0x31e>
		return err;
    197e:	c7 45 d4 ea ff ff ff 	movl   $0xffffffea,-0x2c(%rbp)
    1985:	e9 69 fe ff ff       	jmpq   17f3 <read_nvm_super_block+0x193>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    198a:	49 8b 04 24          	mov    (%r12),%rax
    198e:	48 c1 e8 33          	shr    $0x33,%rax
    1992:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    1995:	83 f8 04             	cmp    $0x4,%eax
    1998:	75 d0                	jne    196a <read_nvm_super_block+0x30a>
	switch (page->pgmap->type) {
    199a:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    199f:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    19a5:	83 e8 01             	sub    $0x1,%eax
    19a8:	83 f8 02             	cmp    $0x2,%eax
    19ab:	77 bd                	ja     196a <read_nvm_super_block+0x30a>
		__put_devmap_managed_page(page);
    19ad:	4c 89 e7             	mov    %r12,%rdi
    19b0:	e8 00 00 00 00       	callq  19b5 <read_nvm_super_block+0x355>
		return;
    19b5:	eb bf                	jmp    1976 <read_nvm_super_block+0x316>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    19b7:	49 8b 04 24          	mov    (%r12),%rax
    19bb:	48 c1 e8 33          	shr    $0x33,%rax
    19bf:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    19c2:	83 f8 04             	cmp    $0x4,%eax
    19c5:	0f 85 42 ff ff ff    	jne    190d <read_nvm_super_block+0x2ad>
	switch (page->pgmap->type) {
    19cb:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    19d0:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    19d6:	83 e8 01             	sub    $0x1,%eax
    19d9:	83 f8 02             	cmp    $0x2,%eax
    19dc:	0f 87 2b ff ff ff    	ja     190d <read_nvm_super_block+0x2ad>
		__put_devmap_managed_page(page);
    19e2:	4c 89 e7             	mov    %r12,%rdi
    19e5:	e8 00 00 00 00       	callq  19ea <read_nvm_super_block+0x38a>
		return err;
    19ea:	c7 45 d4 ea ff ff ff 	movl   $0xffffffea,-0x2c(%rbp)
		return;
    19f1:	e9 fd fd ff ff       	jmpq   17f3 <read_nvm_super_block+0x193>
		__put_page(page);
    19f6:	4c 89 e7             	mov    %r12,%rdi
    19f9:	e8 00 00 00 00       	callq  19fe <read_nvm_super_block+0x39e>
    19fe:	e9 73 ff ff ff       	jmpq   1976 <read_nvm_super_block+0x316>
		*recovery = 1;
    1a03:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1a07:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	if (!page)
    1a0d:	e9 64 ff ff ff       	jmpq   1976 <read_nvm_super_block+0x316>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    1a12:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    1a14:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    1a19:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    1a1c:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    1a20:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1a27:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    1a2c:	e9 1d ff ff ff       	jmpq   194e <read_nvm_super_block+0x2ee>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    1a31:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    1a33:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    1a38:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    1a3b:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    1a3f:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    1a46:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    1a4b:	e9 a1 fe ff ff       	jmpq   18f1 <read_nvm_super_block+0x291>
		return -ENOMEM;
    1a50:	c7 45 d4 f4 ff ff ff 	movl   $0xfffffff4,-0x2c(%rbp)
    1a57:	e9 97 fd ff ff       	jmpq   17f3 <read_nvm_super_block+0x193>
    1a5c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001a60 <clear_heap>:
void clear_heap(struct max_heap *mh) {
    1a60:	f3 0f 1e fa          	endbr64 
    1a64:	e8 00 00 00 00       	callq  1a69 <clear_heap+0x9>
    1a69:	55                   	push   %rbp
    1a6a:	48 89 e5             	mov    %rsp,%rbp
    1a6d:	41 54                	push   %r12
    1a6f:	49 89 fc             	mov    %rdi,%r12
	kvfree(mh->nodes);
    1a72:	48 8b 3f             	mov    (%rdi),%rdi
    1a75:	e8 00 00 00 00       	callq  1a7a <clear_heap+0x1a>
	kvfree(mh);
    1a7a:	4c 89 e7             	mov    %r12,%rdi
    1a7d:	e8 00 00 00 00       	callq  1a82 <clear_heap+0x22>
}
    1a82:	41 5c                	pop    %r12
    1a84:	5d                   	pop    %rbp
    1a85:	c3                   	retq   
    1a86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1a8d:	00 00 00 

0000000000001a90 <clear_min_heap>:
void clear_min_heap(struct min_heap *mh) {
    1a90:	f3 0f 1e fa          	endbr64 
    1a94:	e8 00 00 00 00       	callq  1a99 <clear_min_heap+0x9>
    1a99:	55                   	push   %rbp
    1a9a:	48 89 e5             	mov    %rsp,%rbp
    1a9d:	41 54                	push   %r12
    1a9f:	49 89 fc             	mov    %rdi,%r12
	kvfree(mh->nodes);
    1aa2:	48 8b 3f             	mov    (%rdi),%rdi
    1aa5:	e8 00 00 00 00       	callq  1aaa <clear_min_heap+0x1a>
	kvfree(mh);
    1aaa:	4c 89 e7             	mov    %r12,%rdi
    1aad:	e8 00 00 00 00       	callq  1ab2 <clear_min_heap+0x22>
}
    1ab2:	41 5c                	pop    %r12
    1ab4:	5d                   	pop    %rbp
    1ab5:	c3                   	retq   
    1ab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1abd:	00 00 00 

0000000000001ac0 <is_empty_heap>:
bool is_empty_heap(struct max_heap *mh) {
    1ac0:	f3 0f 1e fa          	endbr64 
    1ac4:	e8 00 00 00 00       	callq  1ac9 <is_empty_heap+0x9>
    1ac9:	55                   	push   %rbp
	if (mh->cur_num == 0) {
    1aca:	8b 47 08             	mov    0x8(%rdi),%eax
    1acd:	85 c0                	test   %eax,%eax
bool is_empty_heap(struct max_heap *mh) {
    1acf:	48 89 e5             	mov    %rsp,%rbp
	if (mh->cur_num == 0) {
    1ad2:	0f 94 c0             	sete   %al
}
    1ad5:	5d                   	pop    %rbp
    1ad6:	c3                   	retq   
    1ad7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1ade:	00 00 

0000000000001ae0 <get_max_heap_top>:
unsigned long get_max_heap_top(struct max_heap *mh) {
    1ae0:	f3 0f 1e fa          	endbr64 
    1ae4:	e8 00 00 00 00       	callq  1ae9 <get_max_heap_top+0x9>
    1ae9:	55                   	push   %rbp
	if (mh->cur_num == 0) {
    1aea:	8b 47 08             	mov    0x8(%rdi),%eax
unsigned long get_max_heap_top(struct max_heap *mh) {
    1aed:	48 89 e5             	mov    %rsp,%rbp
	if (mh->cur_num == 0) {
    1af0:	85 c0                	test   %eax,%eax
    1af2:	74 08                	je     1afc <get_max_heap_top+0x1c>
	return mh->nodes[0].count;
    1af4:	48 8b 07             	mov    (%rdi),%rax
}
    1af7:	5d                   	pop    %rbp
	return mh->nodes[0].count;
    1af8:	48 8b 00             	mov    (%rax),%rax
}
    1afb:	c3                   	retq   
    1afc:	31 c0                	xor    %eax,%eax
    1afe:	5d                   	pop    %rbp
    1aff:	c3                   	retq   

0000000000001b00 <is_last_ckpt_curseg>:
bool is_last_ckpt_curseg(struct f2fs_checkpoint *ckpt, int ssd_segoff) {
    1b00:	f3 0f 1e fa          	endbr64 
    1b04:	e8 00 00 00 00       	callq  1b09 <is_last_ckpt_curseg+0x9>
    1b09:	55                   	push   %rbp
		return true;
    1b0a:	b8 01 00 00 00       	mov    $0x1,%eax
bool is_last_ckpt_curseg(struct f2fs_checkpoint *ckpt, int ssd_segoff) {
    1b0f:	48 89 e5             	mov    %rsp,%rbp
	if (ssd_segoff == node_h)
    1b12:	39 77 30             	cmp    %esi,0x30(%rdi)
    1b15:	74 1a                	je     1b31 <is_last_ckpt_curseg+0x31>
	if (ssd_segoff == node_w)
    1b17:	3b 77 34             	cmp    0x34(%rdi),%esi
    1b1a:	74 15                	je     1b31 <is_last_ckpt_curseg+0x31>
	if (ssd_segoff == node_c)
    1b1c:	3b 77 38             	cmp    0x38(%rdi),%esi
    1b1f:	74 10                	je     1b31 <is_last_ckpt_curseg+0x31>
	if (ssd_segoff == data_h)
    1b21:	3b 77 54             	cmp    0x54(%rdi),%esi
    1b24:	74 0b                	je     1b31 <is_last_ckpt_curseg+0x31>
	if (ssd_segoff == data_w)
    1b26:	3b 77 58             	cmp    0x58(%rdi),%esi
    1b29:	74 06                	je     1b31 <is_last_ckpt_curseg+0x31>
	if (ssd_segoff == data_c)
    1b2b:	39 77 5c             	cmp    %esi,0x5c(%rdi)
    1b2e:	0f 94 c0             	sete   %al
}
    1b31:	5d                   	pop    %rbp
    1b32:	c3                   	retq   
    1b33:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1b3a:	00 00 00 00 
    1b3e:	66 90                	xchg   %ax,%ax

0000000000001b40 <calc_count>:
int calc_count(struct f2fs_sb_info *sbi, unsigned int ssd_segno) {
    1b40:	f3 0f 1e fa          	endbr64 
    1b44:	e8 00 00 00 00       	callq  1b49 <calc_count+0x9>
    1b49:	55                   	push   %rbp
		count[i] = atomic_read(&nsbi->lfu_count[i][ssd_segno]);
    1b4a:	89 f6                	mov    %esi,%esi
	int i, nums = 0;
    1b4c:	45 31 c0             	xor    %r8d,%r8d
		count[i] = atomic_read(&nsbi->lfu_count[i][ssd_segno]);
    1b4f:	48 c1 e6 02          	shl    $0x2,%rsi
int calc_count(struct f2fs_sb_info *sbi, unsigned int ssd_segno) {
    1b53:	48 89 e5             	mov    %rsp,%rbp
    1b56:	48 83 ec 28          	sub    $0x28,%rsp
	struct nvm_sb_info *nsbi = sbi->nsbi;
    1b5a:	48 8b bf 48 07 00 00 	mov    0x748(%rdi),%rdi
int calc_count(struct f2fs_sb_info *sbi, unsigned int ssd_segno) {
    1b61:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1b68:	00 00 
    1b6a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    1b6e:	31 c0                	xor    %eax,%eax
	int now = nsbi->now_lfu_counter;
    1b70:	8b 97 90 00 00 00    	mov    0x90(%rdi),%edx
		count[i] = atomic_read(&nsbi->lfu_count[i][ssd_segno]);
    1b76:	48 8b 8c c7 98 00 00 	mov    0x98(%rdi,%rax,8),%rcx
    1b7d:	00 
    1b7e:	48 01 f1             	add    %rsi,%rcx
    1b81:	8b 09                	mov    (%rcx),%ecx
		if (count[i] == -1) {
    1b83:	83 f9 ff             	cmp    $0xffffffff,%ecx
    1b86:	74 4f                	je     1bd7 <calc_count+0x97>
		count[i] = atomic_read(&nsbi->lfu_count[i][ssd_segno]);
    1b88:	89 4c 85 e8          	mov    %ecx,-0x18(%rbp,%rax,4)
	for (i = 0; i < LFU_LEVELS; i++) {
    1b8c:	48 83 c0 01          	add    $0x1,%rax
    1b90:	48 83 f8 04          	cmp    $0x4,%rax
    1b94:	75 e0                	jne    1b76 <calc_count+0x36>
	if (nums == LFU_LEVELS)return -1;
    1b96:	41 83 f8 04          	cmp    $0x4,%r8d
    1b9a:	74 5d                	je     1bf9 <calc_count+0xb9>
	if (now == 0) {
    1b9c:	85 d2                	test   %edx,%edx
    1b9e:	75 45                	jne    1be5 <calc_count+0xa5>
		level[1] = LFU_LEVEL2;
    1ba0:	48 b8 03 00 00 00 02 	movabs $0x200000003,%rax
    1ba7:	00 00 00 
		level[3] = LFU_LEVEL4;
    1baa:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
    1bb1:	ba 04 00 00 00       	mov    $0x4,%edx
		level[1] = LFU_LEVEL2;
    1bb6:	48 89 45 dc          	mov    %rax,-0x24(%rbp)
	for (i = 0; i < LFU_LEVELS; i++) {
    1bba:	31 c0                	xor    %eax,%eax
	nums = 0;
    1bbc:	45 31 c0             	xor    %r8d,%r8d
		nums += count[i] * level[i];
    1bbf:	0f af 54 05 e8       	imul   -0x18(%rbp,%rax,1),%edx
    1bc4:	48 83 c0 04          	add    $0x4,%rax
    1bc8:	41 01 d0             	add    %edx,%r8d
	for (i = 0; i < LFU_LEVELS; i++) {
    1bcb:	48 83 f8 10          	cmp    $0x10,%rax
    1bcf:	74 2e                	je     1bff <calc_count+0xbf>
    1bd1:	8b 54 05 d8          	mov    -0x28(%rbp,%rax,1),%edx
    1bd5:	eb e8                	jmp    1bbf <calc_count+0x7f>
			count[i] = 0;
    1bd7:	c7 44 85 e8 00 00 00 	movl   $0x0,-0x18(%rbp,%rax,4)
    1bde:	00 
			nums++;
    1bdf:	41 83 c0 01          	add    $0x1,%r8d
    1be3:	eb a7                	jmp    1b8c <calc_count+0x4c>
	} else if (now == 3) {
    1be5:	83 fa 03             	cmp    $0x3,%edx
    1be8:	74 40                	je     1c2a <calc_count+0xea>
	} else if (now == 2) {
    1bea:	83 fa 02             	cmp    $0x2,%edx
    1bed:	74 55                	je     1c44 <calc_count+0x104>
	} else if (now == 1) {
    1bef:	83 fa 01             	cmp    $0x1,%edx
    1bf2:	74 1f                	je     1c13 <calc_count+0xd3>
    1bf4:	8b 55 d8             	mov    -0x28(%rbp),%edx
    1bf7:	eb c1                	jmp    1bba <calc_count+0x7a>
	if (nums == LFU_LEVELS)return -1;
    1bf9:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
}
    1bff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1c03:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    1c0a:	00 00 
    1c0c:	75 50                	jne    1c5e <calc_count+0x11e>
    1c0e:	c9                   	leaveq 
    1c0f:	44 89 c0             	mov    %r8d,%eax
    1c12:	c3                   	retq   
		level[1] = LFU_LEVEL1;
    1c13:	48 b8 04 00 00 00 03 	movabs $0x300000004,%rax
    1c1a:	00 00 00 
		level[3] = LFU_LEVEL3;
    1c1d:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%rbp)
		level[1] = LFU_LEVEL1;
    1c24:	48 89 45 dc          	mov    %rax,-0x24(%rbp)
    1c28:	eb 90                	jmp    1bba <calc_count+0x7a>
		level[1] = LFU_LEVEL3;
    1c2a:	48 b8 02 00 00 00 01 	movabs $0x100000002,%rax
    1c31:	00 00 00 
		level[3] = LFU_LEVEL1;
    1c34:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)
		level[1] = LFU_LEVEL3;
    1c3b:	48 89 45 dc          	mov    %rax,-0x24(%rbp)
    1c3f:	e9 76 ff ff ff       	jmpq   1bba <calc_count+0x7a>
		level[1] = LFU_LEVEL4;
    1c44:	48 b8 01 00 00 00 04 	movabs $0x400000001,%rax
    1c4b:	00 00 00 
		level[3] = LFU_LEVEL2;
    1c4e:	c7 45 e4 03 00 00 00 	movl   $0x3,-0x1c(%rbp)
		level[1] = LFU_LEVEL4;
    1c55:	48 89 45 dc          	mov    %rax,-0x24(%rbp)
    1c59:	e9 5c ff ff ff       	jmpq   1bba <calc_count+0x7a>
}
    1c5e:	e8 00 00 00 00       	callq  1c63 <calc_count+0x123>
    1c63:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1c6a:	00 00 00 00 
    1c6e:	66 90                	xchg   %ax,%ax

0000000000001c70 <insert_max_heap>:
void insert_max_heap(struct max_heap *mh, int seg_off, int count) {
    1c70:	f3 0f 1e fa          	endbr64 
    1c74:	e8 00 00 00 00       	callq  1c79 <insert_max_heap+0x9>
	i = mh->cur_num;
    1c79:	8b 4f 08             	mov    0x8(%rdi),%ecx
void insert_max_heap(struct max_heap *mh, int seg_off, int count) {
    1c7c:	55                   	push   %rbp
    1c7d:	48 63 d2             	movslq %edx,%rdx
	mh->cur_num++;
    1c80:	44 8d 41 01          	lea    0x1(%rcx),%r8d
    1c84:	48 63 c1             	movslq %ecx,%rax
    1c87:	44 89 47 08          	mov    %r8d,0x8(%rdi)
void insert_max_heap(struct max_heap *mh, int seg_off, int count) {
    1c8b:	48 89 e5             	mov    %rsp,%rbp
    1c8e:	4c 8b 07             	mov    (%rdi),%r8
	while (i > 0) {
    1c91:	85 c9                	test   %ecx,%ecx
    1c93:	7f 1c                	jg     1cb1 <insert_max_heap+0x41>
    1c95:	eb 57                	jmp    1cee <insert_max_heap+0x7e>
		mh->nodes[i].count = mh->nodes[j].count;
    1c97:	4d 89 10             	mov    %r10,(%r8)
		mh->nodes[i].seg_off = mh->nodes[j].seg_off;
    1c9a:	4c 8b 07             	mov    (%rdi),%r8
    1c9d:	47 8b 54 08 08       	mov    0x8(%r8,%r9,1),%r10d
    1ca2:	45 89 54 00 08       	mov    %r10d,0x8(%r8,%rax,1)
	while (i > 0) {
    1ca7:	85 c9                	test   %ecx,%ecx
    1ca9:	74 2e                	je     1cd9 <insert_max_heap+0x69>
    1cab:	4c 8b 07             	mov    (%rdi),%r8
    1cae:	48 63 c1             	movslq %ecx,%rax
		j = (i - 1) >> 1;// j指向i的双亲
    1cb1:	8d 48 ff             	lea    -0x1(%rax),%ecx
    1cb4:	48 c1 e0 04          	shl    $0x4,%rax
    1cb8:	d1 f9                	sar    %ecx
		if (count <= mh->nodes[j].count)
    1cba:	4c 63 c9             	movslq %ecx,%r9
    1cbd:	49 c1 e1 04          	shl    $0x4,%r9
    1cc1:	4f 8b 14 08          	mov    (%r8,%r9,1),%r10
    1cc5:	49 01 c0             	add    %rax,%r8
    1cc8:	49 39 d2             	cmp    %rdx,%r10
    1ccb:	72 ca                	jb     1c97 <insert_max_heap+0x27>
	mh->nodes[i].count = count;
    1ccd:	49 89 10             	mov    %rdx,(%r8)
	mh->nodes[i].seg_off = seg_off;
    1cd0:	48 8b 17             	mov    (%rdi),%rdx
    1cd3:	89 74 02 08          	mov    %esi,0x8(%rdx,%rax,1)
}
    1cd7:	5d                   	pop    %rbp
    1cd8:	c3                   	retq   
    1cd9:	4c 8b 07             	mov    (%rdi),%r8
		if (count <= mh->nodes[j].count)
    1cdc:	4c 89 c8             	mov    %r9,%rax
	mh->nodes[i].count = count;
    1cdf:	4d 01 c8             	add    %r9,%r8
    1ce2:	49 89 10             	mov    %rdx,(%r8)
	mh->nodes[i].seg_off = seg_off;
    1ce5:	48 8b 17             	mov    (%rdi),%rdx
    1ce8:	89 74 02 08          	mov    %esi,0x8(%rdx,%rax,1)
}
    1cec:	5d                   	pop    %rbp
    1ced:	c3                   	retq   
    1cee:	48 c1 e0 04          	shl    $0x4,%rax
    1cf2:	49 01 c0             	add    %rax,%r8
    1cf5:	eb d6                	jmp    1ccd <insert_max_heap+0x5d>
    1cf7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1cfe:	00 00 

0000000000001d00 <insert_min_heap>:
void insert_min_heap(struct min_heap *mh, int seg_off, int count) {
    1d00:	f3 0f 1e fa          	endbr64 
    1d04:	e8 00 00 00 00       	callq  1d09 <insert_min_heap+0x9>
	i = mh->cur_num;
    1d09:	8b 4f 08             	mov    0x8(%rdi),%ecx
void insert_min_heap(struct min_heap *mh, int seg_off, int count) {
    1d0c:	55                   	push   %rbp
    1d0d:	48 63 d2             	movslq %edx,%rdx
	mh->cur_num++;
    1d10:	44 8d 41 01          	lea    0x1(%rcx),%r8d
    1d14:	48 63 c1             	movslq %ecx,%rax
    1d17:	44 89 47 08          	mov    %r8d,0x8(%rdi)
void insert_min_heap(struct min_heap *mh, int seg_off, int count) {
    1d1b:	48 89 e5             	mov    %rsp,%rbp
    1d1e:	4c 8b 07             	mov    (%rdi),%r8
	while (i > 0) {
    1d21:	85 c9                	test   %ecx,%ecx
    1d23:	7f 1c                	jg     1d41 <insert_min_heap+0x41>
    1d25:	eb 57                	jmp    1d7e <insert_min_heap+0x7e>
		mh->nodes[i].count = mh->nodes[j].count;
    1d27:	4d 89 10             	mov    %r10,(%r8)
		mh->nodes[i].seg_off = mh->nodes[j].seg_off;
    1d2a:	4c 8b 07             	mov    (%rdi),%r8
    1d2d:	47 8b 54 08 08       	mov    0x8(%r8,%r9,1),%r10d
    1d32:	45 89 54 00 08       	mov    %r10d,0x8(%r8,%rax,1)
	while (i > 0) {
    1d37:	85 c9                	test   %ecx,%ecx
    1d39:	74 2e                	je     1d69 <insert_min_heap+0x69>
    1d3b:	4c 8b 07             	mov    (%rdi),%r8
    1d3e:	48 63 c1             	movslq %ecx,%rax
		j = (i - 1) >> 1;// j指向i的双亲
    1d41:	8d 48 ff             	lea    -0x1(%rax),%ecx
    1d44:	48 c1 e0 04          	shl    $0x4,%rax
    1d48:	d1 f9                	sar    %ecx
		if (count >= mh->nodes[j].count)
    1d4a:	4c 63 c9             	movslq %ecx,%r9
    1d4d:	49 c1 e1 04          	shl    $0x4,%r9
    1d51:	4f 8b 14 08          	mov    (%r8,%r9,1),%r10
    1d55:	49 01 c0             	add    %rax,%r8
    1d58:	49 39 d2             	cmp    %rdx,%r10
    1d5b:	77 ca                	ja     1d27 <insert_min_heap+0x27>
	mh->nodes[i].count = count;
    1d5d:	49 89 10             	mov    %rdx,(%r8)
	mh->nodes[i].seg_off = seg_off;
    1d60:	48 8b 17             	mov    (%rdi),%rdx
    1d63:	89 74 02 08          	mov    %esi,0x8(%rdx,%rax,1)
}
    1d67:	5d                   	pop    %rbp
    1d68:	c3                   	retq   
    1d69:	4c 8b 07             	mov    (%rdi),%r8
		if (count >= mh->nodes[j].count)
    1d6c:	4c 89 c8             	mov    %r9,%rax
	mh->nodes[i].count = count;
    1d6f:	4d 01 c8             	add    %r9,%r8
    1d72:	49 89 10             	mov    %rdx,(%r8)
	mh->nodes[i].seg_off = seg_off;
    1d75:	48 8b 17             	mov    (%rdi),%rdx
    1d78:	89 74 02 08          	mov    %esi,0x8(%rdx,%rax,1)
}
    1d7c:	5d                   	pop    %rbp
    1d7d:	c3                   	retq   
    1d7e:	48 c1 e0 04          	shl    $0x4,%rax
    1d82:	49 01 c0             	add    %rax,%r8
    1d85:	eb d6                	jmp    1d5d <insert_min_heap+0x5d>
    1d87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1d8e:	00 00 

0000000000001d90 <max_heap_adjust_down>:
void max_heap_adjust_down(struct max_heap *mh) {
    1d90:	f3 0f 1e fa          	endbr64 
    1d94:	e8 00 00 00 00       	callq  1d99 <max_heap_adjust_down+0x9>
	int tmp_count = mh->nodes[0].count;
    1d99:	48 8b 37             	mov    (%rdi),%rsi
	while (i < mh->cur_num) {
    1d9c:	44 8b 47 08          	mov    0x8(%rdi),%r8d
void max_heap_adjust_down(struct max_heap *mh) {
    1da0:	55                   	push   %rbp
    1da1:	48 89 e5             	mov    %rsp,%rbp
    1da4:	41 54                	push   %r12
    1da6:	53                   	push   %rbx
	int tmp_segoff = mh->nodes[0].seg_off;
    1da7:	8b 5e 08             	mov    0x8(%rsi),%ebx
	while (i < mh->cur_num) {
    1daa:	4c 63 1e             	movslq (%rsi),%r11
    1dad:	45 85 c0             	test   %r8d,%r8d
    1db0:	0f 84 94 00 00 00    	je     1e4a <max_heap_adjust_down+0xba>
	int i = 0, j;
    1db6:	31 c0                	xor    %eax,%eax
    1db8:	eb 2f                	jmp    1de9 <max_heap_adjust_down+0x59>
		if (j >= mh->cur_num || tmp_count >= mh->nodes[j].count)
    1dba:	48 63 ca             	movslq %edx,%rcx
    1dbd:	48 c1 e1 04          	shl    $0x4,%rcx
    1dc1:	48 8b 34 0e          	mov    (%rsi,%rcx,1),%rsi
    1dc5:	4c 39 de             	cmp    %r11,%rsi
    1dc8:	76 59                	jbe    1e23 <max_heap_adjust_down+0x93>
		mh->nodes[i].count = mh->nodes[j].count;
    1dca:	49 89 32             	mov    %rsi,(%r10)
		mh->nodes[i].seg_off = mh->nodes[j].seg_off;
    1dcd:	48 8b 37             	mov    (%rdi),%rsi
    1dd0:	44 8b 44 0e 08       	mov    0x8(%rsi,%rcx,1),%r8d
    1dd5:	44 89 44 06 08       	mov    %r8d,0x8(%rsi,%rax,1)
	while (i < mh->cur_num) {
    1dda:	44 8b 47 08          	mov    0x8(%rdi),%r8d
    1dde:	45 39 c8             	cmp    %r9d,%r8d
    1de1:	76 4f                	jbe    1e32 <max_heap_adjust_down+0xa2>
    1de3:	48 8b 37             	mov    (%rdi),%rsi
		i = j;
    1de6:	48 63 c2             	movslq %edx,%rax
		j = (i + 1) * 2 - 1;// j是i的左孩子
    1de9:	8d 4c 00 02          	lea    0x2(%rax,%rax,1),%ecx
		if (j < mh->cur_num - 1 && mh->nodes[j].count < mh->nodes[j + 1].count)
    1ded:	45 8d 50 ff          	lea    -0x1(%r8),%r10d
		j = (i + 1) * 2 - 1;// j是i的左孩子
    1df1:	8d 51 ff             	lea    -0x1(%rcx),%edx
		if (j < mh->cur_num - 1 && mh->nodes[j].count < mh->nodes[j + 1].count)
    1df4:	41 89 d1             	mov    %edx,%r9d
    1df7:	41 39 d2             	cmp    %edx,%r10d
    1dfa:	76 1a                	jbe    1e16 <max_heap_adjust_down+0x86>
    1dfc:	4c 63 d2             	movslq %edx,%r10
    1dff:	41 89 c9             	mov    %ecx,%r9d
    1e02:	49 c1 e2 04          	shl    $0x4,%r10
    1e06:	4e 8b 24 16          	mov    (%rsi,%r10,1),%r12
    1e0a:	4e 3b 64 16 10       	cmp    0x10(%rsi,%r10,1),%r12
    1e0f:	44 0f 43 ca          	cmovae %edx,%r9d
    1e13:	44 89 ca             	mov    %r9d,%edx
		if (j >= mh->cur_num || tmp_count >= mh->nodes[j].count)
    1e16:	48 c1 e0 04          	shl    $0x4,%rax
    1e1a:	4c 8d 14 06          	lea    (%rsi,%rax,1),%r10
    1e1e:	45 39 c8             	cmp    %r9d,%r8d
    1e21:	77 97                	ja     1dba <max_heap_adjust_down+0x2a>
	mh->nodes[i].count = tmp_count;
    1e23:	4d 89 1a             	mov    %r11,(%r10)
	mh->nodes[i].seg_off = tmp_segoff;
    1e26:	48 8b 17             	mov    (%rdi),%rdx
    1e29:	89 5c 02 08          	mov    %ebx,0x8(%rdx,%rax,1)
}
    1e2d:	5b                   	pop    %rbx
    1e2e:	41 5c                	pop    %r12
    1e30:	5d                   	pop    %rbp
    1e31:	c3                   	retq   
    1e32:	4c 8b 17             	mov    (%rdi),%r10
		if (j >= mh->cur_num || tmp_count >= mh->nodes[j].count)
    1e35:	48 89 c8             	mov    %rcx,%rax
	mh->nodes[i].count = tmp_count;
    1e38:	49 01 ca             	add    %rcx,%r10
    1e3b:	4d 89 1a             	mov    %r11,(%r10)
	mh->nodes[i].seg_off = tmp_segoff;
    1e3e:	48 8b 17             	mov    (%rdi),%rdx
    1e41:	89 5c 02 08          	mov    %ebx,0x8(%rdx,%rax,1)
}
    1e45:	5b                   	pop    %rbx
    1e46:	41 5c                	pop    %r12
    1e48:	5d                   	pop    %rbp
    1e49:	c3                   	retq   
	while (i < mh->cur_num) {
    1e4a:	49 89 f2             	mov    %rsi,%r10
    1e4d:	31 c0                	xor    %eax,%eax
    1e4f:	eb d2                	jmp    1e23 <max_heap_adjust_down+0x93>
    1e51:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1e58:	00 00 00 00 
    1e5c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001e60 <get_max_k>:
int get_max_k(struct f2fs_sb_info *sbi, struct max_heap *mh, int len, bool pre_move) {
    1e60:	f3 0f 1e fa          	endbr64 
    1e64:	e8 00 00 00 00       	callq  1e69 <get_max_k+0x9>
    1e69:	55                   	push   %rbp
		left_segoff = now - 500;
    1e6a:	b8 00 00 00 00       	mov    $0x0,%eax
int get_max_k(struct f2fs_sb_info *sbi, struct max_heap *mh, int len, bool pre_move) {
    1e6f:	48 89 e5             	mov    %rsp,%rbp
    1e72:	41 57                	push   %r15
    1e74:	49 89 ff             	mov    %rdi,%r15
    1e77:	41 56                	push   %r14
    1e79:	41 55                	push   %r13
    1e7b:	41 89 d5             	mov    %edx,%r13d
    1e7e:	41 54                	push   %r12
    1e80:	53                   	push   %rbx
    1e81:	48 83 ec 18          	sub    $0x18,%rsp
    1e85:	44 8b 5e 08          	mov    0x8(%rsi),%r11d
    1e89:	44 8b 56 0c          	mov    0xc(%rsi),%r10d
    1e8d:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	struct nvm_sb_info *nsbi = sbi->nsbi;
    1e91:	4c 8b 8f 48 07 00 00 	mov    0x748(%rdi),%r9
int get_max_k(struct f2fs_sb_info *sbi, struct max_heap *mh, int len, bool pre_move) {
    1e98:	88 4d d0             	mov    %cl,-0x30(%rbp)
	unsigned int now = nsbi->cur_alloc_nvm_segoff;
    1e9b:	45 8b a1 8c 00 00 00 	mov    0x8c(%r9),%r12d
		left_segoff = now - 500;
    1ea2:	41 81 fc f3 01 00 00 	cmp    $0x1f3,%r12d
    1ea9:	45 8d b4 24 0c fe ff 	lea    -0x1f4(%r12),%r14d
    1eb0:	ff 
    1eb1:	44 0f 46 f0          	cmovbe %eax,%r14d
	right_segoff = now + 50;
    1eb5:	41 83 c4 32          	add    $0x32,%r12d
	for (mpt_index = 0; mpt_index < len && mh->cur_num < mh->k; mpt_index++) {
    1eb9:	31 db                	xor    %ebx,%ebx
    1ebb:	85 d2                	test   %edx,%edx
    1ebd:	7f 19                	jg     1ed8 <get_max_k+0x78>
    1ebf:	e9 f6 00 00 00       	jmpq   1fba <get_max_k+0x15a>
		if (mpt_index >= left_segoff && mpt_index <= right_segoff) {
    1ec4:	44 39 e3             	cmp    %r12d,%ebx
    1ec7:	77 1d                	ja     1ee6 <get_max_k+0x86>
			mpt_index = right_segoff;
    1ec9:	44 89 e3             	mov    %r12d,%ebx
	for (mpt_index = 0; mpt_index < len && mh->cur_num < mh->k; mpt_index++) {
    1ecc:	83 c3 01             	add    $0x1,%ebx
    1ecf:	41 39 dd             	cmp    %ebx,%r13d
    1ed2:	0f 8e e2 00 00 00    	jle    1fba <get_max_k+0x15a>
    1ed8:	45 39 da             	cmp    %r11d,%r10d
    1edb:	0f 86 17 01 00 00    	jbe    1ff8 <get_max_k+0x198>
		if (mpt_index >= left_segoff && mpt_index <= right_segoff) {
    1ee1:	44 39 f3             	cmp    %r14d,%ebx
    1ee4:	73 de                	jae    1ec4 <get_max_k+0x64>
	return nsbi->mpt[index] & rw_map;
    1ee6:	49 8b 51 50          	mov    0x50(%r9),%rdx
    1eea:	48 63 c3             	movslq %ebx,%rax
    1eed:	8b 34 82             	mov    (%rdx,%rax,4),%esi
		if (!get_map_flag(nsbi, mpt_index)) {
    1ef0:	40 f6 c6 01          	test   $0x1,%sil
    1ef4:	74 d6                	je     1ecc <get_max_k+0x6c>
		if (pre_move && get_double_flag(nsbi, mpt_index)) {
    1ef6:	80 7d d0 00          	cmpb   $0x0,-0x30(%rbp)
    1efa:	74 06                	je     1f02 <get_max_k+0xa2>
    1efc:	40 f6 c6 04          	test   $0x4,%sil
    1f00:	75 ca                	jne    1ecc <get_max_k+0x6c>
		secno = GET_SEC_FROM_SEG(sbi, ssd_segno);
    1f02:	41 8b 8f 28 04 00 00 	mov    0x428(%r15),%ecx
	return nsbi->mpt[index] >> rw_bits;
    1f09:	c1 ee 03             	shr    $0x3,%esi
    1f0c:	31 d2                	xor    %edx,%edx
    1f0e:	89 f0                	mov    %esi,%eax
    1f10:	f7 f1                	div    %ecx
				- (base + 1) + type;
}

static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)
{
	if (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))
    1f12:	31 d2                	xor    %edx,%edx
    1f14:	89 c7                	mov    %eax,%edi
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    1f16:	49 8b 47 68          	mov    0x68(%r15),%rax
    1f1a:	4c 8b 40 18          	mov    0x18(%rax),%r8
	if (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))
    1f1e:	41 8b 40 5c          	mov    0x5c(%r8),%eax
    1f22:	f7 f1                	div    %ecx
    1f24:	39 c7                	cmp    %eax,%edi
    1f26:	74 a4                	je     1ecc <get_max_k+0x6c>
    1f28:	41 8b 80 cc 00 00 00 	mov    0xcc(%r8),%eax
    1f2f:	31 d2                	xor    %edx,%edx
    1f31:	f7 f1                	div    %ecx
    1f33:	39 c7                	cmp    %eax,%edi
    1f35:	74 95                	je     1ecc <get_max_k+0x6c>
    1f37:	41 8b 80 3c 01 00 00 	mov    0x13c(%r8),%eax
    1f3e:	31 d2                	xor    %edx,%edx
    1f40:	f7 f1                	div    %ecx
    1f42:	39 c7                	cmp    %eax,%edi
    1f44:	74 86                	je     1ecc <get_max_k+0x6c>
    1f46:	41 8b 80 ac 01 00 00 	mov    0x1ac(%r8),%eax
    1f4d:	31 d2                	xor    %edx,%edx
    1f4f:	f7 f1                	div    %ecx
    1f51:	39 c7                	cmp    %eax,%edi
    1f53:	0f 84 73 ff ff ff    	je     1ecc <get_max_k+0x6c>
    1f59:	41 8b 80 1c 02 00 00 	mov    0x21c(%r8),%eax
    1f60:	31 d2                	xor    %edx,%edx
    1f62:	f7 f1                	div    %ecx
    1f64:	39 c7                	cmp    %eax,%edi
    1f66:	0f 84 60 ff ff ff    	je     1ecc <get_max_k+0x6c>
    1f6c:	41 8b 80 8c 02 00 00 	mov    0x28c(%r8),%eax
    1f73:	31 d2                	xor    %edx,%edx
    1f75:	f7 f1                	div    %ecx
    1f77:	39 c7                	cmp    %eax,%edi
    1f79:	0f 84 4d ff ff ff    	je     1ecc <get_max_k+0x6c>
    1f7f:	41 3b bf 68 05 00 00 	cmp    0x568(%r15),%edi
    1f86:	0f 84 40 ff ff ff    	je     1ecc <get_max_k+0x6c>
		count = calc_count(sbi, ssd_segno);
    1f8c:	4c 89 ff             	mov    %r15,%rdi
    1f8f:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
    1f93:	e8 00 00 00 00       	callq  1f98 <get_max_k+0x138>
		if (count >= 0) {//计数为0，说明写入之后就没有读过，依然需要回收
    1f98:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
    1f9c:	85 c0                	test   %eax,%eax
		count = calc_count(sbi, ssd_segno);
    1f9e:	89 c2                	mov    %eax,%edx
		if (count >= 0) {//计数为0，说明写入之后就没有读过，依然需要回收
    1fa0:	79 32                	jns    1fd4 <get_max_k+0x174>
    1fa2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	for (mpt_index = 0; mpt_index < len && mh->cur_num < mh->k; mpt_index++) {
    1fa6:	83 c3 01             	add    $0x1,%ebx
    1fa9:	44 8b 58 08          	mov    0x8(%rax),%r11d
    1fad:	44 8b 50 0c          	mov    0xc(%rax),%r10d
    1fb1:	41 39 dd             	cmp    %ebx,%r13d
    1fb4:	0f 8f 1e ff ff ff    	jg     1ed8 <get_max_k+0x78>
	if (mh->cur_num < mh->k) {
    1fba:	45 39 d3             	cmp    %r10d,%r11d
    1fbd:	0f 82 6d 01 00 00    	jb     2130 <get_max_k+0x2d0>
	return 0;
    1fc3:	31 c0                	xor    %eax,%eax
}
    1fc5:	48 83 c4 18          	add    $0x18,%rsp
    1fc9:	5b                   	pop    %rbx
    1fca:	41 5c                	pop    %r12
    1fcc:	41 5d                	pop    %r13
    1fce:	41 5e                	pop    %r14
    1fd0:	41 5f                	pop    %r15
    1fd2:	5d                   	pop    %rbp
    1fd3:	c3                   	retq   
			insert_max_heap(mh, mpt_index, count);
    1fd4:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    1fd8:	89 de                	mov    %ebx,%esi
    1fda:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
    1fde:	e8 00 00 00 00       	callq  1fe3 <get_max_k+0x183>
    1fe3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1fe7:	4c 8b 4d c0          	mov    -0x40(%rbp),%r9
    1feb:	44 8b 58 08          	mov    0x8(%rax),%r11d
    1fef:	44 8b 50 0c          	mov    0xc(%rax),%r10d
    1ff3:	e9 d4 fe ff ff       	jmpq   1ecc <get_max_k+0x6c>
	for (; mpt_index < len; mpt_index++) {
    1ff8:	41 39 dd             	cmp    %ebx,%r13d
    1ffb:	7e c6                	jle    1fc3 <get_max_k+0x163>
    1ffd:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
    2002:	eb 14                	jmp    2018 <get_max_k+0x1b8>
		if (mpt_index >= left_segoff && mpt_index <= right_segoff) {
    2004:	44 39 e3             	cmp    %r12d,%ebx
    2007:	77 14                	ja     201d <get_max_k+0x1bd>
			mpt_index = right_segoff;
    2009:	44 89 e3             	mov    %r12d,%ebx
	for (; mpt_index < len; mpt_index++) {
    200c:	83 c3 01             	add    $0x1,%ebx
    200f:	41 39 dd             	cmp    %ebx,%r13d
    2012:	0f 8e 03 01 00 00    	jle    211b <get_max_k+0x2bb>
		if (mpt_index >= left_segoff && mpt_index <= right_segoff) {
    2018:	44 39 f3             	cmp    %r14d,%ebx
    201b:	73 e7                	jae    2004 <get_max_k+0x1a4>
	return nsbi->mpt[index] & rw_map;
    201d:	49 8b 51 50          	mov    0x50(%r9),%rdx
    2021:	48 63 c3             	movslq %ebx,%rax
    2024:	8b 04 82             	mov    (%rdx,%rax,4),%eax
		if (!get_map_flag(nsbi, mpt_index)) {
    2027:	a8 01                	test   $0x1,%al
    2029:	74 e1                	je     200c <get_max_k+0x1ac>
		if (pre_move && get_double_flag(nsbi, mpt_index)) {
    202b:	45 84 c0             	test   %r8b,%r8b
    202e:	74 04                	je     2034 <get_max_k+0x1d4>
    2030:	a8 04                	test   $0x4,%al
    2032:	75 d8                	jne    200c <get_max_k+0x1ac>
		secno = GET_SEC_FROM_SEG(sbi, ssd_segno);
    2034:	41 8b 8f 28 04 00 00 	mov    0x428(%r15),%ecx
	return nsbi->mpt[index] >> rw_bits;
    203b:	c1 e8 03             	shr    $0x3,%eax
    203e:	31 d2                	xor    %edx,%edx
    2040:	89 c6                	mov    %eax,%esi
    2042:	f7 f1                	div    %ecx
    2044:	31 d2                	xor    %edx,%edx
    2046:	89 c7                	mov    %eax,%edi
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    2048:	49 8b 47 68          	mov    0x68(%r15),%rax
    204c:	4c 8b 50 18          	mov    0x18(%rax),%r10
	if (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))
    2050:	41 8b 42 5c          	mov    0x5c(%r10),%eax
    2054:	f7 f1                	div    %ecx
    2056:	39 c7                	cmp    %eax,%edi
    2058:	74 b2                	je     200c <get_max_k+0x1ac>
    205a:	41 8b 82 cc 00 00 00 	mov    0xcc(%r10),%eax
    2061:	31 d2                	xor    %edx,%edx
    2063:	f7 f1                	div    %ecx
    2065:	39 c7                	cmp    %eax,%edi
    2067:	74 a3                	je     200c <get_max_k+0x1ac>
    2069:	41 8b 82 3c 01 00 00 	mov    0x13c(%r10),%eax
    2070:	31 d2                	xor    %edx,%edx
    2072:	f7 f1                	div    %ecx
    2074:	39 c7                	cmp    %eax,%edi
    2076:	74 94                	je     200c <get_max_k+0x1ac>
    2078:	41 8b 82 ac 01 00 00 	mov    0x1ac(%r10),%eax
    207f:	31 d2                	xor    %edx,%edx
    2081:	f7 f1                	div    %ecx
    2083:	39 c7                	cmp    %eax,%edi
    2085:	74 85                	je     200c <get_max_k+0x1ac>
    2087:	41 8b 82 1c 02 00 00 	mov    0x21c(%r10),%eax
    208e:	31 d2                	xor    %edx,%edx
    2090:	f7 f1                	div    %ecx
    2092:	39 c7                	cmp    %eax,%edi
    2094:	0f 84 72 ff ff ff    	je     200c <get_max_k+0x1ac>
    209a:	41 8b 82 8c 02 00 00 	mov    0x28c(%r10),%eax
    20a1:	31 d2                	xor    %edx,%edx
    20a3:	f7 f1                	div    %ecx
    20a5:	39 c7                	cmp    %eax,%edi
    20a7:	0f 84 5f ff ff ff    	je     200c <get_max_k+0x1ac>
    20ad:	41 3b bf 68 05 00 00 	cmp    0x568(%r15),%edi
    20b4:	0f 84 52 ff ff ff    	je     200c <get_max_k+0x1ac>
		count = calc_count(sbi, ssd_segno);
    20ba:	4c 89 ff             	mov    %r15,%rdi
    20bd:	44 88 45 c0          	mov    %r8b,-0x40(%rbp)
    20c1:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
    20c5:	e8 00 00 00 00       	callq  20ca <get_max_k+0x26a>
		if (count >= 0 && count < get_max_heap_top(mh)) {
    20ca:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
    20ce:	44 0f b6 45 c0       	movzbl -0x40(%rbp),%r8d
    20d3:	85 c0                	test   %eax,%eax
    20d5:	0f 88 31 ff ff ff    	js     200c <get_max_k+0x1ac>
	if (mh->cur_num == 0) {
    20db:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    20df:	8b 57 08             	mov    0x8(%rdi),%edx
    20e2:	85 d2                	test   %edx,%edx
    20e4:	0f 84 22 ff ff ff    	je     200c <get_max_k+0x1ac>
	return mh->nodes[0].count;
    20ea:	48 8b 17             	mov    (%rdi),%rdx
		if (count >= 0 && count < get_max_heap_top(mh)) {
    20ed:	48 98                	cltq   
    20ef:	48 3b 02             	cmp    (%rdx),%rax
    20f2:	0f 83 14 ff ff ff    	jae    200c <get_max_k+0x1ac>
			mh->nodes[0].count = count;
    20f8:	48 89 02             	mov    %rax,(%rdx)
			mh->nodes[0].seg_off = mpt_index;
    20fb:	48 8b 07             	mov    (%rdi),%rax
    20fe:	89 58 08             	mov    %ebx,0x8(%rax)
	for (; mpt_index < len; mpt_index++) {
    2101:	83 c3 01             	add    $0x1,%ebx
			max_heap_adjust_down(mh);
    2104:	e8 00 00 00 00       	callq  2109 <get_max_k+0x2a9>
    2109:	44 0f b6 45 c0       	movzbl -0x40(%rbp),%r8d
    210e:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
	for (; mpt_index < len; mpt_index++) {
    2112:	41 39 dd             	cmp    %ebx,%r13d
    2115:	0f 8f fd fe ff ff    	jg     2018 <get_max_k+0x1b8>
    211b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    211f:	44 8b 58 08          	mov    0x8(%rax),%r11d
    2123:	44 8b 50 0c          	mov    0xc(%rax),%r10d
	if (mh->cur_num < mh->k) {
    2127:	45 39 d3             	cmp    %r10d,%r11d
    212a:	0f 83 93 fe ff ff    	jae    1fc3 <get_max_k+0x163>
		return -ENOCOLD;
    2130:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    2135:	e9 8b fe ff ff       	jmpq   1fc5 <get_max_k+0x165>
    213a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000002140 <min_heap_adjust_down>:
void min_heap_adjust_down(struct min_heap *mh) {
    2140:	f3 0f 1e fa          	endbr64 
    2144:	e8 00 00 00 00       	callq  2149 <min_heap_adjust_down+0x9>
	int tmp_count = mh->nodes[0].count;
    2149:	48 8b 37             	mov    (%rdi),%rsi
	while (i < mh->cur_num) {
    214c:	44 8b 47 08          	mov    0x8(%rdi),%r8d
void min_heap_adjust_down(struct min_heap *mh) {
    2150:	55                   	push   %rbp
    2151:	48 89 e5             	mov    %rsp,%rbp
    2154:	41 54                	push   %r12
    2156:	53                   	push   %rbx
	int tmp_segoff = mh->nodes[0].seg_off;
    2157:	8b 5e 08             	mov    0x8(%rsi),%ebx
	while (i < mh->cur_num) {
    215a:	4c 63 1e             	movslq (%rsi),%r11
    215d:	45 85 c0             	test   %r8d,%r8d
    2160:	0f 84 94 00 00 00    	je     21fa <min_heap_adjust_down+0xba>
	int i = 0, j;
    2166:	31 c0                	xor    %eax,%eax
    2168:	eb 2f                	jmp    2199 <min_heap_adjust_down+0x59>
		if (j >= mh->cur_num || tmp_count <= mh->nodes[j].count)
    216a:	48 63 ca             	movslq %edx,%rcx
    216d:	48 c1 e1 04          	shl    $0x4,%rcx
    2171:	48 8b 34 0e          	mov    (%rsi,%rcx,1),%rsi
    2175:	4c 39 de             	cmp    %r11,%rsi
    2178:	73 59                	jae    21d3 <min_heap_adjust_down+0x93>
		mh->nodes[i].count = mh->nodes[j].count;
    217a:	49 89 32             	mov    %rsi,(%r10)
		mh->nodes[i].seg_off = mh->nodes[j].seg_off;
    217d:	48 8b 37             	mov    (%rdi),%rsi
    2180:	44 8b 44 0e 08       	mov    0x8(%rsi,%rcx,1),%r8d
    2185:	44 89 44 06 08       	mov    %r8d,0x8(%rsi,%rax,1)
	while (i < mh->cur_num) {
    218a:	44 8b 47 08          	mov    0x8(%rdi),%r8d
    218e:	45 39 c8             	cmp    %r9d,%r8d
    2191:	76 4f                	jbe    21e2 <min_heap_adjust_down+0xa2>
    2193:	48 8b 37             	mov    (%rdi),%rsi
		i = j;
    2196:	48 63 c2             	movslq %edx,%rax
		j = (i + 1) * 2 - 1;// j是i的左孩子
    2199:	8d 4c 00 02          	lea    0x2(%rax,%rax,1),%ecx
		if (j < mh->cur_num - 1 && mh->nodes[j].count > mh->nodes[j + 1].count)
    219d:	45 8d 50 ff          	lea    -0x1(%r8),%r10d
		j = (i + 1) * 2 - 1;// j是i的左孩子
    21a1:	8d 51 ff             	lea    -0x1(%rcx),%edx
		if (j < mh->cur_num - 1 && mh->nodes[j].count > mh->nodes[j + 1].count)
    21a4:	41 89 d1             	mov    %edx,%r9d
    21a7:	41 39 d2             	cmp    %edx,%r10d
    21aa:	76 1a                	jbe    21c6 <min_heap_adjust_down+0x86>
    21ac:	4c 63 d2             	movslq %edx,%r10
    21af:	41 89 c9             	mov    %ecx,%r9d
    21b2:	49 c1 e2 04          	shl    $0x4,%r10
    21b6:	4e 8b 24 16          	mov    (%rsi,%r10,1),%r12
    21ba:	4e 3b 64 16 10       	cmp    0x10(%rsi,%r10,1),%r12
    21bf:	44 0f 46 ca          	cmovbe %edx,%r9d
    21c3:	44 89 ca             	mov    %r9d,%edx
		if (j >= mh->cur_num || tmp_count <= mh->nodes[j].count)
    21c6:	48 c1 e0 04          	shl    $0x4,%rax
    21ca:	4c 8d 14 06          	lea    (%rsi,%rax,1),%r10
    21ce:	45 39 c8             	cmp    %r9d,%r8d
    21d1:	77 97                	ja     216a <min_heap_adjust_down+0x2a>
	mh->nodes[i].count = tmp_count;
    21d3:	4d 89 1a             	mov    %r11,(%r10)
	mh->nodes[i].seg_off = tmp_segoff;
    21d6:	48 8b 17             	mov    (%rdi),%rdx
    21d9:	89 5c 02 08          	mov    %ebx,0x8(%rdx,%rax,1)
}
    21dd:	5b                   	pop    %rbx
    21de:	41 5c                	pop    %r12
    21e0:	5d                   	pop    %rbp
    21e1:	c3                   	retq   
    21e2:	4c 8b 17             	mov    (%rdi),%r10
		if (j >= mh->cur_num || tmp_count <= mh->nodes[j].count)
    21e5:	48 89 c8             	mov    %rcx,%rax
	mh->nodes[i].count = tmp_count;
    21e8:	49 01 ca             	add    %rcx,%r10
    21eb:	4d 89 1a             	mov    %r11,(%r10)
	mh->nodes[i].seg_off = tmp_segoff;
    21ee:	48 8b 17             	mov    (%rdi),%rdx
    21f1:	89 5c 02 08          	mov    %ebx,0x8(%rdx,%rax,1)
}
    21f5:	5b                   	pop    %rbx
    21f6:	41 5c                	pop    %r12
    21f8:	5d                   	pop    %rbp
    21f9:	c3                   	retq   
	while (i < mh->cur_num) {
    21fa:	49 89 f2             	mov    %rsi,%r10
    21fd:	31 c0                	xor    %eax,%eax
    21ff:	eb d2                	jmp    21d3 <min_heap_adjust_down+0x93>
    2201:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    2208:	00 00 00 00 
    220c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002210 <get_min_k>:
int get_min_k(struct f2fs_sb_info *sbi, struct min_heap *mh, int len) {
    2210:	f3 0f 1e fa          	endbr64 
    2214:	e8 00 00 00 00       	callq  2219 <get_min_k+0x9>
    2219:	55                   	push   %rbp
    221a:	48 89 e5             	mov    %rsp,%rbp
    221d:	41 57                	push   %r15
    221f:	41 56                	push   %r14
    2221:	49 89 f6             	mov    %rsi,%r14
    2224:	41 55                	push   %r13
    2226:	41 8b 4e 0c          	mov    0xc(%r14),%ecx
    222a:	41 89 d5             	mov    %edx,%r13d
    222d:	41 54                	push   %r12
    222f:	45 31 e4             	xor    %r12d,%r12d
    2232:	53                   	push   %rbx
	unsigned int nvm_segments = sbi->nsbi->nsb->main_segment_nums;
    2233:	48 8b 87 48 07 00 00 	mov    0x748(%rdi),%rax
    223a:	48 89 fb             	mov    %rdi,%rbx
    223d:	8b 76 08             	mov    0x8(%rsi),%esi
    2240:	48 8b 00             	mov    (%rax),%rax
    2243:	44 8b 78 2c          	mov    0x2c(%rax),%r15d
	for (segoff = 0; segoff < len && mh->cur_num < mh->k; segoff++) {
    2247:	85 d2                	test   %edx,%edx
    2249:	0f 8e c0 00 00 00    	jle    230f <get_min_k+0xff>
    224f:	39 ce                	cmp    %ecx,%esi
    2251:	0f 83 dd 00 00 00    	jae    2334 <get_min_k+0x124>
	return nsbi->mpt[index] & rw_map;
    2257:	48 8b 93 48 07 00 00 	mov    0x748(%rbx),%rdx
    225e:	43 8d 04 27          	lea    (%r15,%r12,1),%eax
    2262:	48 98                	cltq   
    2264:	48 8b 52 50          	mov    0x50(%rdx),%rdx
		if (get_map_flag(sbi->nsbi, nvm_segments + segoff)) {
    2268:	f6 04 82 01          	testb  $0x1,(%rdx,%rax,4)
    226c:	0f 85 90 00 00 00    	jne    2302 <get_min_k+0xf2>
		count = calc_count(sbi, segoff);
    2272:	44 89 e6             	mov    %r12d,%esi
    2275:	48 89 df             	mov    %rbx,%rdi
    2278:	e8 00 00 00 00       	callq  227d <get_min_k+0x6d>
    227d:	41 89 c0             	mov    %eax,%r8d
		if (count == -1) {
    2280:	83 f8 ff             	cmp    $0xffffffff,%eax
    2283:	74 75                	je     22fa <get_min_k+0xea>
		secno = GET_SEC_FROM_SEG(sbi, segoff);
    2285:	8b 8b 28 04 00 00    	mov    0x428(%rbx),%ecx
    228b:	44 89 e0             	mov    %r12d,%eax
    228e:	31 d2                	xor    %edx,%edx
    2290:	f7 f1                	div    %ecx
    2292:	31 d2                	xor    %edx,%edx
    2294:	89 c6                	mov    %eax,%esi
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    2296:	48 8b 43 68          	mov    0x68(%rbx),%rax
    229a:	48 8b 78 18          	mov    0x18(%rax),%rdi
	if (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))
    229e:	8b 47 5c             	mov    0x5c(%rdi),%eax
    22a1:	f7 f1                	div    %ecx
    22a3:	39 c6                	cmp    %eax,%esi
    22a5:	74 53                	je     22fa <get_min_k+0xea>
    22a7:	8b 87 cc 00 00 00    	mov    0xcc(%rdi),%eax
    22ad:	31 d2                	xor    %edx,%edx
    22af:	f7 f1                	div    %ecx
    22b1:	39 c6                	cmp    %eax,%esi
    22b3:	74 45                	je     22fa <get_min_k+0xea>
    22b5:	8b 87 3c 01 00 00    	mov    0x13c(%rdi),%eax
    22bb:	31 d2                	xor    %edx,%edx
    22bd:	f7 f1                	div    %ecx
    22bf:	39 c6                	cmp    %eax,%esi
    22c1:	74 37                	je     22fa <get_min_k+0xea>
    22c3:	8b 87 ac 01 00 00    	mov    0x1ac(%rdi),%eax
    22c9:	31 d2                	xor    %edx,%edx
    22cb:	f7 f1                	div    %ecx
    22cd:	39 c6                	cmp    %eax,%esi
    22cf:	74 29                	je     22fa <get_min_k+0xea>
    22d1:	8b 87 1c 02 00 00    	mov    0x21c(%rdi),%eax
    22d7:	31 d2                	xor    %edx,%edx
    22d9:	f7 f1                	div    %ecx
    22db:	39 c6                	cmp    %eax,%esi
    22dd:	74 1b                	je     22fa <get_min_k+0xea>
    22df:	8b 87 8c 02 00 00    	mov    0x28c(%rdi),%eax
    22e5:	31 d2                	xor    %edx,%edx
    22e7:	f7 f1                	div    %ecx
    22e9:	39 c6                	cmp    %eax,%esi
    22eb:	74 0d                	je     22fa <get_min_k+0xea>
		if (count > 0) {
    22ed:	39 b3 68 05 00 00    	cmp    %esi,0x568(%rbx)
    22f3:	74 05                	je     22fa <get_min_k+0xea>
    22f5:	45 85 c0             	test   %r8d,%r8d
    22f8:	7f 2a                	jg     2324 <get_min_k+0x114>
    22fa:	41 8b 76 08          	mov    0x8(%r14),%esi
    22fe:	41 8b 4e 0c          	mov    0xc(%r14),%ecx
	for (segoff = 0; segoff < len && mh->cur_num < mh->k; segoff++) {
    2302:	41 83 c4 01          	add    $0x1,%r12d
    2306:	45 39 e5             	cmp    %r12d,%r13d
    2309:	0f 85 40 ff ff ff    	jne    224f <get_min_k+0x3f>
	if (mh->cur_num < mh->k) {
    230f:	39 ce                	cmp    %ecx,%esi
    2311:	0f 82 09 01 00 00    	jb     2420 <get_min_k+0x210>
	int ret = 0;
    2317:	31 c0                	xor    %eax,%eax
}
    2319:	5b                   	pop    %rbx
    231a:	41 5c                	pop    %r12
    231c:	41 5d                	pop    %r13
    231e:	41 5e                	pop    %r14
    2320:	41 5f                	pop    %r15
    2322:	5d                   	pop    %rbp
    2323:	c3                   	retq   
			insert_min_heap(mh, segoff, count);
    2324:	44 89 c2             	mov    %r8d,%edx
    2327:	44 89 e6             	mov    %r12d,%esi
    232a:	4c 89 f7             	mov    %r14,%rdi
    232d:	e8 00 00 00 00       	callq  2332 <get_min_k+0x122>
    2332:	eb c6                	jmp    22fa <get_min_k+0xea>
	for (; segoff < len; segoff++) {
    2334:	45 39 e5             	cmp    %r12d,%r13d
    2337:	7e de                	jle    2317 <get_min_k+0x107>
    2339:	48 8b 93 48 07 00 00 	mov    0x748(%rbx),%rdx
    2340:	43 8d 04 27          	lea    (%r15,%r12,1),%eax
    2344:	48 98                	cltq   
    2346:	48 8b 52 50          	mov    0x50(%rdx),%rdx
		if (get_map_flag(sbi->nsbi, nvm_segments + segoff)) {
    234a:	f6 04 82 01          	testb  $0x1,(%rdx,%rax,4)
    234e:	0f 85 99 00 00 00    	jne    23ed <get_min_k+0x1dd>
		count = calc_count(sbi, segoff);
    2354:	44 89 e6             	mov    %r12d,%esi
    2357:	48 89 df             	mov    %rbx,%rdi
    235a:	e8 00 00 00 00       	callq  235f <get_min_k+0x14f>
    235f:	48 63 f0             	movslq %eax,%rsi
		if (count == -1) {
    2362:	83 fe ff             	cmp    $0xffffffff,%esi
    2365:	0f 84 82 00 00 00    	je     23ed <get_min_k+0x1dd>
		secno = GET_SEC_FROM_SEG(sbi, segoff);
    236b:	8b 8b 28 04 00 00    	mov    0x428(%rbx),%ecx
    2371:	44 89 e0             	mov    %r12d,%eax
    2374:	31 d2                	xor    %edx,%edx
    2376:	f7 f1                	div    %ecx
    2378:	31 d2                	xor    %edx,%edx
    237a:	89 c7                	mov    %eax,%edi
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    237c:	48 8b 43 68          	mov    0x68(%rbx),%rax
    2380:	4c 8b 40 18          	mov    0x18(%rax),%r8
	if (IS_CURSEC(sbi, secno) || (sbi->cur_victim_sec == secno))
    2384:	41 8b 40 5c          	mov    0x5c(%r8),%eax
    2388:	f7 f1                	div    %ecx
    238a:	39 c7                	cmp    %eax,%edi
    238c:	74 5f                	je     23ed <get_min_k+0x1dd>
    238e:	41 8b 80 cc 00 00 00 	mov    0xcc(%r8),%eax
    2395:	31 d2                	xor    %edx,%edx
    2397:	f7 f1                	div    %ecx
    2399:	39 c7                	cmp    %eax,%edi
    239b:	74 50                	je     23ed <get_min_k+0x1dd>
    239d:	41 8b 80 3c 01 00 00 	mov    0x13c(%r8),%eax
    23a4:	31 d2                	xor    %edx,%edx
    23a6:	f7 f1                	div    %ecx
    23a8:	39 c7                	cmp    %eax,%edi
    23aa:	74 41                	je     23ed <get_min_k+0x1dd>
    23ac:	41 8b 80 ac 01 00 00 	mov    0x1ac(%r8),%eax
    23b3:	31 d2                	xor    %edx,%edx
    23b5:	f7 f1                	div    %ecx
    23b7:	39 c7                	cmp    %eax,%edi
    23b9:	74 32                	je     23ed <get_min_k+0x1dd>
    23bb:	41 8b 80 1c 02 00 00 	mov    0x21c(%r8),%eax
    23c2:	31 d2                	xor    %edx,%edx
    23c4:	f7 f1                	div    %ecx
    23c6:	39 c7                	cmp    %eax,%edi
    23c8:	74 23                	je     23ed <get_min_k+0x1dd>
    23ca:	41 8b 80 8c 02 00 00 	mov    0x28c(%r8),%eax
    23d1:	31 d2                	xor    %edx,%edx
    23d3:	f7 f1                	div    %ecx
    23d5:	39 c7                	cmp    %eax,%edi
    23d7:	74 14                	je     23ed <get_min_k+0x1dd>
		if (count > 0 && count > mh->nodes[0].count) {
    23d9:	39 bb 68 05 00 00    	cmp    %edi,0x568(%rbx)
    23df:	74 0c                	je     23ed <get_min_k+0x1dd>
    23e1:	85 f6                	test   %esi,%esi
    23e3:	7e 08                	jle    23ed <get_min_k+0x1dd>
    23e5:	49 8b 06             	mov    (%r14),%rax
    23e8:	48 3b 30             	cmp    (%rax),%rsi
    23eb:	77 1f                	ja     240c <get_min_k+0x1fc>
	for (; segoff < len; segoff++) {
    23ed:	41 83 c4 01          	add    $0x1,%r12d
    23f1:	45 39 e5             	cmp    %r12d,%r13d
    23f4:	0f 85 3f ff ff ff    	jne    2339 <get_min_k+0x129>
    23fa:	41 8b 76 08          	mov    0x8(%r14),%esi
    23fe:	41 8b 4e 0c          	mov    0xc(%r14),%ecx
	if (mh->cur_num < mh->k) {
    2402:	39 ce                	cmp    %ecx,%esi
    2404:	0f 83 0d ff ff ff    	jae    2317 <get_min_k+0x107>
    240a:	eb 14                	jmp    2420 <get_min_k+0x210>
			mh->nodes[0].count = count;
    240c:	48 89 30             	mov    %rsi,(%rax)
			mh->nodes[0].seg_off = segoff;
    240f:	49 8b 06             	mov    (%r14),%rax
			min_heap_adjust_down(mh);
    2412:	4c 89 f7             	mov    %r14,%rdi
			mh->nodes[0].seg_off = segoff;
    2415:	44 89 60 08          	mov    %r12d,0x8(%rax)
			min_heap_adjust_down(mh);
    2419:	e8 00 00 00 00       	callq  241e <get_min_k+0x20e>
    241e:	eb cd                	jmp    23ed <get_min_k+0x1dd>
    2420:	f3 0f 1e fa          	endbr64 
		ret = -ENOHOT;
    2424:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	return ret;
    2429:	e9 eb fe ff ff       	jmpq   2319 <get_min_k+0x109>
    242e:	66 90                	xchg   %ax,%ax

0000000000002430 <print_max_heap>:
void print_max_heap(struct max_heap *mh, struct f2fs_sb_info *sbi) {
    2430:	f3 0f 1e fa          	endbr64 
    2434:	e8 00 00 00 00       	callq  2439 <print_max_heap+0x9>
    2439:	55                   	push   %rbp
    243a:	48 89 e5             	mov    %rsp,%rbp
}
    243d:	5d                   	pop    %rbp
    243e:	c3                   	retq   
    243f:	90                   	nop

0000000000002440 <nvm_destory_nsbi_modules>:
void nvm_destory_nsbi_modules(struct f2fs_sb_info *sbi) {
    2440:	f3 0f 1e fa          	endbr64 
    2444:	e8 00 00 00 00       	callq  2449 <nvm_destory_nsbi_modules+0x9>
    2449:	55                   	push   %rbp
    244a:	48 89 e5             	mov    %rsp,%rbp
    244d:	41 56                	push   %r14
    244f:	41 55                	push   %r13
    2451:	49 89 fd             	mov    %rdi,%r13
    2454:	41 54                	push   %r12
    2456:	53                   	push   %rbx
	struct nvm_sb_info *nsbi = sbi->nsbi;
    2457:	4c 8b a7 48 07 00 00 	mov    0x748(%rdi),%r12
	kvfree(nsbi->mpt);
    245e:	49 8b 7c 24 50       	mov    0x50(%r12),%rdi
    2463:	49 8d 9c 24 98 00 00 	lea    0x98(%r12),%rbx
    246a:	00 
    246b:	4d 8d b4 24 b8 00 00 	lea    0xb8(%r12),%r14
    2472:	00 
    2473:	e8 00 00 00 00       	callq  2478 <nvm_destory_nsbi_modules+0x38>
	kvfree(nsbi->mpt_dirty_map);
    2478:	49 8b 7c 24 58       	mov    0x58(%r12),%rdi
    247d:	e8 00 00 00 00       	callq  2482 <nvm_destory_nsbi_modules+0x42>
	kvfree(nsbi->ckpt_segment_map);
    2482:	49 8b bc 24 80 00 00 	mov    0x80(%r12),%rdi
    2489:	00 
    248a:	e8 00 00 00 00       	callq  248f <nvm_destory_nsbi_modules+0x4f>
	kvfree(nsbi->segment_map);
    248f:	49 8b 7c 24 78       	mov    0x78(%r12),%rdi
    2494:	e8 00 00 00 00       	callq  2499 <nvm_destory_nsbi_modules+0x59>
	kvfree(nsbi->mpt_ver_map);
    2499:	49 8b 7c 24 68       	mov    0x68(%r12),%rdi
    249e:	e8 00 00 00 00       	callq  24a3 <nvm_destory_nsbi_modules+0x63>
		kvfree(nsbi->lfu_count[i]);
    24a3:	48 8b 3b             	mov    (%rbx),%rdi
    24a6:	48 83 c3 08          	add    $0x8,%rbx
    24aa:	e8 00 00 00 00       	callq  24af <nvm_destory_nsbi_modules+0x6f>
	for (i = 0; i < LFU_LEVELS; i++) {
    24af:	4c 39 f3             	cmp    %r14,%rbx
    24b2:	75 ef                	jne    24a3 <nvm_destory_nsbi_modules+0x63>
	clear_heap(nsbi->mh);// 释放基于LFU访问计数的top-k max-heap
    24b4:	4d 8b b4 24 c0 00 00 	mov    0xc0(%r12),%r14
    24bb:	00 
	kvfree(mh->nodes);
    24bc:	49 8b 3e             	mov    (%r14),%rdi
    24bf:	e8 00 00 00 00       	callq  24c4 <nvm_destory_nsbi_modules+0x84>
	kvfree(mh);
    24c4:	4c 89 f7             	mov    %r14,%rdi
    24c7:	e8 00 00 00 00       	callq  24cc <nvm_destory_nsbi_modules+0x8c>
	clear_min_heap(nsbi->minh);
    24cc:	4d 8b b4 24 c8 00 00 	mov    0xc8(%r12),%r14
    24d3:	00 
	kvfree(mh->nodes);
    24d4:	49 8b 3e             	mov    (%r14),%rdi
    24d7:	e8 00 00 00 00       	callq  24dc <nvm_destory_nsbi_modules+0x9c>
	kvfree(mh);
    24dc:	4c 89 f7             	mov    %r14,%rdi
    24df:	e8 00 00 00 00       	callq  24e4 <nvm_destory_nsbi_modules+0xa4>
	__free_pages(nsbi->nvm_gc_start_page, sbi->log_blocks_per_seg);// 释放用于NVM-GC段迁移的连续物理内存页
    24e4:	41 8b b5 20 04 00 00 	mov    0x420(%r13),%esi
    24eb:	49 8b bc 24 d0 00 00 	mov    0xd0(%r12),%rdi
    24f2:	00 
    24f3:	e8 00 00 00 00       	callq  24f8 <nvm_destory_nsbi_modules+0xb8>
	__free_pages(nsbi->ssd_to_nvm_start_page, sbi->log_blocks_per_seg);
    24f8:	41 8b b5 20 04 00 00 	mov    0x420(%r13),%esi
    24ff:	49 8b bc 24 d8 00 00 	mov    0xd8(%r12),%rdi
    2506:	00 
    2507:	e8 00 00 00 00       	callq  250c <nvm_destory_nsbi_modules+0xcc>
	kfree(nsbi->nsb);
    250c:	49 8b 3c 24          	mov    (%r12),%rdi
    2510:	e8 00 00 00 00       	callq  2515 <nvm_destory_nsbi_modules+0xd5>
	kfree(nsbi);
    2515:	4c 89 e7             	mov    %r12,%rdi
    2518:	e8 00 00 00 00       	callq  251d <nvm_destory_nsbi_modules+0xdd>
}
    251d:	5b                   	pop    %rbx
    251e:	41 5c                	pop    %r12
	sbi->nsbi = NULL;
    2520:	49 c7 85 48 07 00 00 	movq   $0x0,0x748(%r13)
    2527:	00 00 00 00 
}
    252b:	41 5d                	pop    %r13
    252d:	41 5e                	pop    %r14
    252f:	5d                   	pop    %rbp
    2530:	c3                   	retq   
    2531:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    2538:	00 00 00 00 
    253c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002540 <get_real_page>:
void get_real_page(struct f2fs_sb_info *sbi, struct page *real_page, struct block_device *bdev, block_t blkno) {
    2540:	f3 0f 1e fa          	endbr64 
    2544:	e8 00 00 00 00       	callq  2549 <get_real_page+0x9>
    2549:	55                   	push   %rbp
    254a:	48 89 e5             	mov    %rsp,%rbp
    254d:	41 57                	push   %r15
    254f:	49 89 f7             	mov    %rsi,%r15

extern struct bio_set fs_bio_set;

static inline struct bio *bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
	return bio_alloc_bioset(gfp_mask, nr_iovecs, &fs_bio_set);
    2552:	be 01 00 00 00       	mov    $0x1,%esi
    2557:	41 56                	push   %r14
    2559:	49 89 d6             	mov    %rdx,%r14
    255c:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    2563:	41 55                	push   %r13
    2565:	49 89 fd             	mov    %rdi,%r13
    2568:	bf 00 00 60 00       	mov    $0x600000,%edi
    256d:	41 54                	push   %r12
    256f:	53                   	push   %rbx
    2570:	89 cb                	mov    %ecx,%ebx
    2572:	e8 00 00 00 00       	callq  2577 <get_real_page+0x37>
		if (!bio)
    2577:	49 89 c4             	mov    %rax,%r12
    257a:	48 85 c0             	test   %rax,%rax
    257d:	0f 84 83 00 00 00    	je     2606 <get_real_page+0xc6>
	bio_set_dev(read_bio, bdev);
    2583:	49 8b 86 80 00 00 00 	mov    0x80(%r14),%rax
    258a:	49 39 44 24 08       	cmp    %rax,0x8(%r12)
    258f:	74 0f                	je     25a0 <get_real_page+0x60>
	bio->bi_flags &= ~(1U << bit);
    2591:	66 41 81 64 24 14 ff 	andw   $0xfdff,0x14(%r12)
    2598:	fd 
    2599:	49 8b 86 80 00 00 00 	mov    0x80(%r14),%rax
    25a0:	49 89 44 24 08       	mov    %rax,0x8(%r12)
    25a5:	41 0f b6 46 6c       	movzbl 0x6c(%r14),%eax
	read_bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blkno);
    25aa:	48 c1 e3 03          	shl    $0x3,%rbx
	if (bio_add_page(read_bio, real_page, PAGE_SIZE, 0) < PAGE_SIZE) {
    25ae:	31 c9                	xor    %ecx,%ecx
	read_bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blkno);
    25b0:	49 89 5c 24 28       	mov    %rbx,0x28(%r12)
	if (bio_add_page(read_bio, real_page, PAGE_SIZE, 0) < PAGE_SIZE) {
    25b5:	ba 00 10 00 00       	mov    $0x1000,%edx
    25ba:	4c 89 fe             	mov    %r15,%rsi
    25bd:	4c 89 e7             	mov    %r12,%rdi
	bio_set_dev(read_bio, bdev);
    25c0:	41 88 44 24 1b       	mov    %al,0x1b(%r12)
	read_bio->bi_private = NULL;
    25c5:	49 c7 44 24 50 00 00 	movq   $0x0,0x50(%r12)
    25cc:	00 00 
	if (bio_add_page(read_bio, real_page, PAGE_SIZE, 0) < PAGE_SIZE) {
    25ce:	e8 00 00 00 00       	callq  25d3 <get_real_page+0x93>
    25d3:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    25d8:	77 08                	ja     25e2 <get_real_page+0xa2>
		f2fs_bug_on(sbi, 1);
    25da:	0f 0b                	ud2    
    25dc:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)

/* obsolete, don't use in new code */
static inline void bio_set_op_attrs(struct bio *bio, unsigned op,
		unsigned op_flags)
{
	bio->bi_opf = op | op_flags;
    25e2:	41 c7 44 24 10 00 00 	movl   $0x0,0x10(%r12)
    25e9:	00 00 
	submit_bio_wait(read_bio);
    25eb:	4c 89 e7             	mov    %r12,%rdi
    25ee:	e8 00 00 00 00       	callq  25f3 <get_real_page+0xb3>
	bio_put(read_bio);
    25f3:	4c 89 e7             	mov    %r12,%rdi
    25f6:	e8 00 00 00 00       	callq  25fb <get_real_page+0xbb>
}
    25fb:	5b                   	pop    %rbx
    25fc:	41 5c                	pop    %r12
    25fe:	41 5d                	pop    %r13
    2600:	41 5e                	pop    %r14
    2602:	41 5f                	pop    %r15
    2604:	5d                   	pop    %rbp
    2605:	c3                   	retq   
	return bio_alloc_bioset(gfp_mask, nr_iovecs, &fs_bio_set);
    2606:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    260d:	be 01 00 00 00       	mov    $0x1,%esi
    2612:	bf 00 08 60 00       	mov    $0x600800,%edi
    2617:	e8 00 00 00 00       	callq  261c <get_real_page+0xdc>
    261c:	49 89 c4             	mov    %rax,%r12
    261f:	e9 5f ff ff ff       	jmpq   2583 <get_real_page+0x43>
    2624:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    262b:	00 00 00 00 
    262f:	90                   	nop

0000000000002630 <update_aqu_sz_now>:

//即时调用
int update_aqu_sz_now(void *data) {
    2630:	f3 0f 1e fa          	endbr64 
    2634:	e8 00 00 00 00       	callq  2639 <update_aqu_sz_now+0x9>
    2639:	55                   	push   %rbp
	unsigned int ssd_rq_ticks = 0, nvm_rq_ticks = 0;
	struct f2fs_sb_info *sbi = (struct f2fs_sb_info *) data;
	struct block_device *ssd_bdev = sbi->sb->s_bdev;
	struct block_device *nvm_bdev = sbi->nsbi->nbdev;

	if ((fp = filp_open(DISKSTATS, O_RDONLY, 0644)) == NULL)
    263a:	31 f6                	xor    %esi,%esi
    263c:	ba a4 01 00 00       	mov    $0x1a4,%edx
int update_aqu_sz_now(void *data) {
    2641:	48 89 e5             	mov    %rsp,%rbp
    2644:	41 57                	push   %r15
    2646:	41 56                	push   %r14
    2648:	41 55                	push   %r13
    264a:	41 54                	push   %r12
    264c:	53                   	push   %rbx
    264d:	48 81 ec 98 01 00 00 	sub    $0x198,%rsp
    2654:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    265b:	00 00 
    265d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    2661:	31 c0                	xor    %eax,%eax
	struct block_device *ssd_bdev = sbi->sb->s_bdev;
    2663:	48 8b 07             	mov    (%rdi),%rax
    2666:	4c 8b a8 d0 00 00 00 	mov    0xd0(%rax),%r13
	struct block_device *nvm_bdev = sbi->nsbi->nbdev;
    266d:	48 8b 87 48 07 00 00 	mov    0x748(%rdi),%rax
	if ((fp = filp_open(DISKSTATS, O_RDONLY, 0644)) == NULL)
    2674:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	struct block_device *nvm_bdev = sbi->nsbi->nbdev;
    267b:	4c 8b 78 08          	mov    0x8(%rax),%r15
	if ((fp = filp_open(DISKSTATS, O_RDONLY, 0644)) == NULL)
    267f:	e8 00 00 00 00       	callq  2684 <update_aqu_sz_now+0x54>
    2684:	48 85 c0             	test   %rax,%rax
    2687:	0f 84 71 01 00 00    	je     27fe <update_aqu_sz_now+0x1ce>
    268d:	49 89 c4             	mov    %rax,%r12
	unsigned int ssd_rq_ticks = 0, nvm_rq_ticks = 0;
    2690:	31 db                	xor    %ebx,%ebx
    2692:	45 31 f6             	xor    %r14d,%r14d
		return 1;

	while (read_line(line, sizeof(line), fp) != NULL) {
    2695:	4c 89 e6             	mov    %r12,%rsi
    2698:	48 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%rdi
    269f:	e8 5c d9 ff ff       	callq  0 <read_line.constprop.0>
    26a4:	48 85 c0             	test   %rax,%rax
    26a7:	0f 84 ef 00 00 00    	je     279c <update_aqu_sz_now+0x16c>

		/* major minor name rio rmerge rsect ruse wio wmerge wsect wuse running use aveq dcio dcmerge dcsect dcuse*/
		sscanf(line, "%u %u %s %lu %lu %lu %lu %lu %lu %lu %u %u %u %u %lu %lu %lu %lu",
    26ad:	48 8d 85 a8 fe ff ff 	lea    -0x158(%rbp),%rax
    26b4:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    26bb:	48 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%rdi
    26c2:	50                   	push   %rax
    26c3:	48 8d 85 a0 fe ff ff 	lea    -0x160(%rbp),%rax
    26ca:	4c 8d 8d 58 fe ff ff 	lea    -0x1a8(%rbp),%r9
    26d1:	50                   	push   %rax
    26d2:	48 8d 85 98 fe ff ff 	lea    -0x168(%rbp),%rax
    26d9:	4c 8d 85 b0 fe ff ff 	lea    -0x150(%rbp),%r8
    26e0:	50                   	push   %rax
    26e1:	48 8d 85 90 fe ff ff 	lea    -0x170(%rbp),%rax
    26e8:	48 8d 8d 54 fe ff ff 	lea    -0x1ac(%rbp),%rcx
    26ef:	50                   	push   %rax
    26f0:	48 8d 85 48 fe ff ff 	lea    -0x1b8(%rbp),%rax
    26f7:	48 8d 95 50 fe ff ff 	lea    -0x1b0(%rbp),%rdx
    26fe:	50                   	push   %rax
    26ff:	48 8d 85 44 fe ff ff 	lea    -0x1bc(%rbp),%rax
    2706:	50                   	push   %rax
    2707:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
    270e:	50                   	push   %rax
    270f:	48 8d 85 4c fe ff ff 	lea    -0x1b4(%rbp),%rax
    2716:	50                   	push   %rax
    2717:	48 8d 85 88 fe ff ff 	lea    -0x178(%rbp),%rax
    271e:	50                   	push   %rax
    271f:	48 8d 85 78 fe ff ff 	lea    -0x188(%rbp),%rax
    2726:	50                   	push   %rax
    2727:	48 8d 85 70 fe ff ff 	lea    -0x190(%rbp),%rax
    272e:	50                   	push   %rax
    272f:	48 8d 85 68 fe ff ff 	lea    -0x198(%rbp),%rax
    2736:	50                   	push   %rax
    2737:	48 8d 85 80 fe ff ff 	lea    -0x180(%rbp),%rax
    273e:	50                   	push   %rax
    273f:	48 8d 85 60 fe ff ff 	lea    -0x1a0(%rbp),%rax
    2746:	50                   	push   %rax
    2747:	e8 00 00 00 00       	callq  274c <update_aqu_sz_now+0x11c>
			   &major, &minor, dev_name,
			   &rd_ios, &rd_merges_or_rd_sec, &rd_sec_or_wr_ios, &rd_ticks_or_wr_sec,
			   &wr_ios, &wr_merges, &wr_sec, &wr_ticks, &ios_pgr, &tot_ticks, &rq_ticks,
			   &dc_ios, &dc_merges, &dc_sec, &dc_ticks);

		if (strcmp(ssd_bdev->bd_disk->disk_name, dev_name) == 0) {
    274c:	49 8b 85 80 00 00 00 	mov    0x80(%r13),%rax
    2753:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
    275a:	48 83 c4 70          	add    $0x70,%rsp
    275e:	48 8d 78 0c          	lea    0xc(%rax),%rdi
    2762:	e8 00 00 00 00       	callq  2767 <update_aqu_sz_now+0x137>
    2767:	85 c0                	test   %eax,%eax
    2769:	75 0c                	jne    2777 <update_aqu_sz_now+0x147>
			ssd_rq_ticks = rq_ticks;
    276b:	44 8b b5 48 fe ff ff 	mov    -0x1b8(%rbp),%r14d
    2772:	e9 1e ff ff ff       	jmpq   2695 <update_aqu_sz_now+0x65>

		} else if (strcmp(nvm_bdev->bd_disk->disk_name, dev_name) == 0) {
    2777:	49 8b 87 80 00 00 00 	mov    0x80(%r15),%rax
    277e:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
    2785:	48 8d 78 0c          	lea    0xc(%rax),%rdi
    2789:	e8 00 00 00 00       	callq  278e <update_aqu_sz_now+0x15e>
			nvm_rq_ticks = rq_ticks;
    278e:	85 c0                	test   %eax,%eax
    2790:	0f 44 9d 48 fe ff ff 	cmove  -0x1b8(%rbp),%ebx
    2797:	e9 f9 fe ff ff       	jmpq   2695 <update_aqu_sz_now+0x65>
		}

	}
	filp_close(fp, NULL);
    279c:	31 f6                	xor    %esi,%esi
    279e:	4c 89 e7             	mov    %r12,%rdi
    27a1:	e8 00 00 00 00       	callq  27a6 <update_aqu_sz_now+0x176>

	//更新aqu_sz
	ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
    27a6:	44 89 f2             	mov    %r14d,%edx
	nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
    27a9:	89 d8                	mov    %ebx,%eax
	ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
    27ab:	2b 15 00 00 00 00    	sub    0x0(%rip),%edx        # 27b1 <update_aqu_sz_now+0x181>
	nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
    27b1:	2b 05 00 00 00 00    	sub    0x0(%rip),%eax        # 27b7 <update_aqu_sz_now+0x187>
	ssd_aqu_sz = (ssd_rq_ticks - pre_ssd_rq_ticks);
    27b7:	89 15 00 00 00 00    	mov    %edx,0x0(%rip)        # 27bd <update_aqu_sz_now+0x18d>
	nvm_aqu_sz = (nvm_rq_ticks - pre_nvm_rq_ticks);
    27bd:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 27c3 <update_aqu_sz_now+0x193>
	if (ssd_aqu_sz != 0)
    27c3:	85 d2                	test   %edx,%edx
    27c5:	74 07                	je     27ce <update_aqu_sz_now+0x19e>
		pre_ssd_rq_ticks = ssd_rq_ticks;
    27c7:	44 89 35 00 00 00 00 	mov    %r14d,0x0(%rip)        # 27ce <update_aqu_sz_now+0x19e>
	if (nvm_aqu_sz != 0)
		pre_nvm_rq_ticks = nvm_rq_ticks;

	return 0;
    27ce:	45 31 c0             	xor    %r8d,%r8d
	if (nvm_aqu_sz != 0)
    27d1:	85 c0                	test   %eax,%eax
    27d3:	75 21                	jne    27f6 <update_aqu_sz_now+0x1c6>
}
    27d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    27d9:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    27e0:	00 00 
    27e2:	75 22                	jne    2806 <update_aqu_sz_now+0x1d6>
    27e4:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    27e8:	44 89 c0             	mov    %r8d,%eax
    27eb:	5b                   	pop    %rbx
    27ec:	41 5c                	pop    %r12
    27ee:	41 5d                	pop    %r13
    27f0:	41 5e                	pop    %r14
    27f2:	41 5f                	pop    %r15
    27f4:	5d                   	pop    %rbp
    27f5:	c3                   	retq   
		pre_nvm_rq_ticks = nvm_rq_ticks;
    27f6:	89 1d 00 00 00 00    	mov    %ebx,0x0(%rip)        # 27fc <update_aqu_sz_now+0x1cc>
    27fc:	eb d7                	jmp    27d5 <update_aqu_sz_now+0x1a5>
		return 1;
    27fe:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    2804:	eb cf                	jmp    27d5 <update_aqu_sz_now+0x1a5>
}
    2806:	e8 00 00 00 00       	callq  280b <update_aqu_sz_now+0x1db>
    280b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000002810 <init_aqu_sz_thread>:

/**
 * 定时更新aqu_sz
 */
int init_aqu_sz_thread(struct f2fs_sb_info *sbi) {
    2810:	f3 0f 1e fa          	endbr64 
    2814:	e8 00 00 00 00       	callq  2819 <init_aqu_sz_thread+0x9>
    2819:	55                   	push   %rbp
	int err;
	struct task_struct *aqu_sz_task;
	aqu_sz_task = kthread_create(update_aqu_sz, sbi, "aqu_sz_task");
    281a:	48 89 fe             	mov    %rdi,%rsi
    281d:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    2824:	ba ff ff ff ff       	mov    $0xffffffff,%edx
int init_aqu_sz_thread(struct f2fs_sb_info *sbi) {
    2829:	48 89 e5             	mov    %rsp,%rbp
    282c:	53                   	push   %rbx
    282d:	48 89 fb             	mov    %rdi,%rbx
	aqu_sz_task = kthread_create(update_aqu_sz, sbi, "aqu_sz_task");
    2830:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2837:	e8 00 00 00 00       	callq  283c <init_aqu_sz_thread+0x2c>
    283c:	48 89 c7             	mov    %rax,%rdi
	if (IS_ERR(aqu_sz_task)) {
    283f:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    2845:	77 12                	ja     2859 <init_aqu_sz_thread+0x49>
		nvm_debug(NVM_ERR, "Unable to start kernel thread.");
		err = PTR_ERR(aqu_sz_task);
		return err;
	}
	sbi->nsbi->aqu_sz_task = aqu_sz_task;
    2847:	48 8b 83 48 07 00 00 	mov    0x748(%rbx),%rax
    284e:	48 89 78 20          	mov    %rdi,0x20(%rax)
	wake_up_process(aqu_sz_task);
    2852:	e8 00 00 00 00       	callq  2857 <init_aqu_sz_thread+0x47>
	return 0;
    2857:	31 c0                	xor    %eax,%eax
}
    2859:	5b                   	pop    %rbx
    285a:	5d                   	pop    %rbp
    285b:	c3                   	retq   
    285c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000002860 <nvm_alloc>:

bool nvm_alloc(struct f2fs_sb_info *sbi, int type) {
    2860:	f3 0f 1e fa          	endbr64 
    2864:	e8 00 00 00 00       	callq  2869 <nvm_alloc+0x9>
	unsigned int real_low_boundary = 0, real_high_boundary = 0;
	unsigned int local_ssd_aqu_sz = 0;
	unsigned int local_nvm_aqu_sz = 0;

	//优先考虑根据冷热数据分配
	if (type == CURSEG_HOT_DATA || type == CURSEG_HOT_NODE) {
    2869:	85 f6                	test   %esi,%esi
    286b:	0f 94 c0             	sete   %al
    286e:	83 fe 03             	cmp    $0x3,%esi
    2871:	0f 94 c2             	sete   %dl
    2874:	08 d0                	or     %dl,%al
    2876:	74 01                	je     2879 <nvm_alloc+0x19>
		alloc = false;
	}
//	nvm_debug(NVM_ERR, "alloc=%d,ratio=%d,ssd_aqu_sz=%d,nvm_aqu_sz=%d,nvm_used_ratio=%d", alloc, ratio, ssd_aqu_sz,
//			  nvm_aqu_sz, 100 * used / all);
	return alloc;
}
    2878:	c3                   	retq   
bool nvm_alloc(struct f2fs_sb_info *sbi, int type) {
    2879:	55                   	push   %rbp
    287a:	48 89 e5             	mov    %rsp,%rbp
    287d:	41 55                	push   %r13
    287f:	41 54                	push   %r12
    2881:	53                   	push   %rbx
    2882:	48 89 fb             	mov    %rdi,%rbx
	__le32 all = sbi->nsbi->nsb->main_segment_nums;
    2885:	48 8b bf 48 07 00 00 	mov    0x748(%rdi),%rdi
    288c:	48 8b 07             	mov    (%rdi),%rax
	return raw_spin_trylock(&lock->rlock);
    288f:	48 81 c7 00 01 00 00 	add    $0x100,%rdi
    2896:	44 8b 68 2c          	mov    0x2c(%rax),%r13d
	__le32 used = all - sbi->nsbi->nsb->main_segment_free_nums;
    289a:	44 8b 60 30          	mov    0x30(%rax),%r12d
    289e:	e8 00 00 00 00       	callq  28a3 <nvm_alloc+0x43>
		local_ssd_aqu_sz = ssd_aqu_sz;
    28a3:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 28a9 <nvm_alloc+0x49>
		local_nvm_aqu_sz = nvm_aqu_sz;
    28a9:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 28af <nvm_alloc+0x4f>
	if (spin_trylock(&sbi->nsbi->aqusz_lock)) {
    28af:	85 c0                	test   %eax,%eax
    28b1:	75 47                	jne    28fa <nvm_alloc+0x9a>
	if (local_nvm_aqu_sz == 0) {
    28b3:	be 01 00 00 00       	mov    $0x1,%esi
    28b8:	85 d2                	test   %edx,%edx
		real_low_boundary = low_boundary;
    28ba:	bf 21 00 00 00       	mov    $0x21,%edi
    28bf:	0f 44 d6             	cmove  %esi,%edx
	ratio = 100 * local_nvm_aqu_sz / (local_ssd_aqu_sz + local_nvm_aqu_sz);
    28c2:	6b c2 64             	imul   $0x64,%edx,%eax
    28c5:	85 c9                	test   %ecx,%ecx
    28c7:	0f 44 ce             	cmove  %esi,%ecx
    28ca:	01 d1                	add    %edx,%ecx
    28cc:	31 d2                	xor    %edx,%edx
    28ce:	f7 f1                	div    %ecx
	__le32 used = all - sbi->nsbi->nsb->main_segment_free_nums;
    28d0:	44 89 e9             	mov    %r13d,%ecx
    28d3:	44 29 e1             	sub    %r12d,%ecx
	if (2 * used > all) {//使用率超过一半才考虑剩余空间对分配的影响
    28d6:	01 c9                	add    %ecx,%ecx
	ratio = 100 * local_nvm_aqu_sz / (local_ssd_aqu_sz + local_nvm_aqu_sz);
    28d8:	89 c6                	mov    %eax,%esi
	if (2 * used > all) {//使用率超过一半才考虑剩余空间对分配的影响
    28da:	44 39 e9             	cmp    %r13d,%ecx
    28dd:	76 0f                	jbe    28ee <nvm_alloc+0x8e>
		real_low_boundary = low_boundary - space_weight * (2 * used - all) / all;
    28df:	89 c8                	mov    %ecx,%eax
    28e1:	31 d2                	xor    %edx,%edx
    28e3:	44 29 e8             	sub    %r13d,%eax
    28e6:	c1 e0 04             	shl    $0x4,%eax
    28e9:	41 f7 f5             	div    %r13d
    28ec:	29 c7                	sub    %eax,%edi
	if (ratio < real_low_boundary) {
    28ee:	39 f7                	cmp    %esi,%edi
}
    28f0:	5b                   	pop    %rbx
    28f1:	41 5c                	pop    %r12
	if (ratio < real_low_boundary) {
    28f3:	0f 97 c0             	seta   %al
}
    28f6:	41 5d                	pop    %r13
    28f8:	5d                   	pop    %rbp
    28f9:	c3                   	retq   
		update_aqu_sz_now(sbi);
    28fa:	48 89 df             	mov    %rbx,%rdi
    28fd:	e8 00 00 00 00       	callq  2902 <nvm_alloc+0xa2>
	arch_spin_unlock(&lock->raw_lock);
    2902:	48 8b bb 48 07 00 00 	mov    0x748(%rbx),%rdi
		local_ssd_aqu_sz = ssd_aqu_sz;
    2909:	8b 0d 00 00 00 00    	mov    0x0(%rip),%ecx        # 290f <nvm_alloc+0xaf>
		local_nvm_aqu_sz = nvm_aqu_sz;
    290f:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 2915 <nvm_alloc+0xb5>
    2915:	48 81 c7 00 01 00 00 	add    $0x100,%rdi
    291c:	ff 14 25 00 00 00 00 	callq  *0x0
}
    2923:	eb 8e                	jmp    28b3 <nvm_alloc+0x53>

Disassembly of section .text.unlikely:

0000000000000000 <get_next_mpt_page>:
struct page *get_next_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
   0:	f3 0f 1e fa          	endbr64 
   4:	e8 00 00 00 00       	callq  9 <get_next_mpt_page+0x9>
   9:	55                   	push   %rbp
   a:	48 89 e5             	mov    %rsp,%rbp
   d:	41 55                	push   %r13
	block_addr = nsbi->nsb->mpt_blkaddr + mpt_pgoff;/* ZN：这是在NVM上的物理地址 */
   f:	41 89 f5             	mov    %esi,%r13d
struct page *get_next_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
  12:	41 54                	push   %r12
	struct nvm_sb_info *nsbi = sbi->nsbi;
  14:	48 8b 97 48 07 00 00 	mov    0x748(%rdi),%rdx
struct page *get_next_mpt_page(struct f2fs_sb_info *sbi, int mpt_pgoff) {
  1b:	49 89 fc             	mov    %rdi,%r12
	block_addr = nsbi->nsb->mpt_blkaddr + mpt_pgoff;/* ZN：这是在NVM上的物理地址 */
  1e:	48 8b 02             	mov    (%rdx),%rax
  21:	44 03 68 10          	add    0x10(%rax),%r13d
	addr += (nr >> 3);
  25:	89 f0                	mov    %esi,%eax
	mask = 1 << (7 - (nr & 0x07));
  27:	f7 d6                	not    %esi
  29:	89 f1                	mov    %esi,%ecx
	addr += (nr >> 3);
  2b:	c1 e8 03             	shr    $0x3,%eax
  2e:	48 03 42 68          	add    0x68(%rdx),%rax
	mask = 1 << (7 - (nr & 0x07));
  32:	ba 01 00 00 00       	mov    $0x1,%edx
  37:	83 e1 07             	and    $0x7,%ecx
	return mask & *addr;
  3a:	0f be 30             	movsbl (%rax),%esi
	mask = 1 << (7 - (nr & 0x07));
  3d:	d3 e2                	shl    %cl,%edx
  3f:	89 d1                	mov    %edx,%ecx
	return mask & *addr;
  41:	89 f2                	mov    %esi,%edx
	if (!f2fs_test_bit(mpt_pgoff, nsbi->mpt_ver_map))
  43:	85 ce                	test   %ecx,%esi
  45:	75 09                	jne    50 <get_next_mpt_page+0x50>
		block_addr += sbi->blocks_per_seg;
  47:	8b b7 24 04 00 00    	mov    0x424(%rdi),%esi
  4d:	49 01 f5             	add    %rsi,%r13
{
	int mask;

	addr += (nr >> 3);
	mask = 1 << (7 - (nr & 0x07));
	*addr ^= mask;
  50:	31 ca                	xor    %ecx,%edx
	printk(KERN_INFO"ZN trap: f2fs grab mpt page");
  52:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  59:	88 10                	mov    %dl,(%rax)
  5b:	e8 00 00 00 00       	callq  60 <get_next_mpt_page+0x60>
	dst_page = f2fs_grab_meta_page(sbi, block_addr);
  60:	4c 89 ee             	mov    %r13,%rsi
  63:	4c 89 e7             	mov    %r12,%rdi
  66:	e8 00 00 00 00       	callq  6b <get_next_mpt_page+0x6b>
}
  6b:	41 5c                	pop    %r12
  6d:	41 5d                	pop    %r13
  6f:	5d                   	pop    %rbp
  70:	c3                   	retq   

0000000000000071 <nvm_flush_mpt_pages.cold>:
			nsbi->nvm_flag |= NVM_NSB_DIRTY;
  71:	41 80 4e 10 01       	orb    $0x1,0x10(%r14)
		src_addr = nsbi->mpt + (PAGE_SIZE * mpt_pgoff / sizeof(unsigned int));
  76:	49 8b 4e 50          	mov    0x50(%r14),%rcx
  7a:	49 63 c7             	movslq %r15d,%rax
		mpt_page = get_next_mpt_page(sbi, mpt_pgoff);
  7d:	44 89 fe             	mov    %r15d,%esi
  80:	48 89 df             	mov    %rbx,%rdi
		src_addr = nsbi->mpt + (PAGE_SIZE * mpt_pgoff / sizeof(unsigned int));
  83:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  87:	48 c1 e0 0c          	shl    $0xc,%rax
  8b:	48 01 c1             	add    %rax,%rcx
  8e:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
		mpt_page = get_next_mpt_page(sbi, mpt_pgoff);
  92:	e8 00 00 00 00       	callq  97 <nvm_flush_mpt_pages.cold+0x26>
  97:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  9b:	49 89 c0             	mov    %rax,%r8
	return page_to_virt(page);
  9e:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # a5 <nvm_flush_mpt_pages.cold+0x34>
  a5:	48 8b 31             	mov    (%rcx),%rsi
  a8:	48 c1 f8 06          	sar    $0x6,%rax
  ac:	48 c1 e0 0c          	shl    $0xc,%rax
  b0:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # b7 <nvm_flush_mpt_pages.cold+0x46>
  b7:	48 89 30             	mov    %rsi,(%rax)
  ba:	48 8d 78 08          	lea    0x8(%rax),%rdi
  be:	48 8b b1 f8 0f 00 00 	mov    0xff8(%rcx),%rsi
  c5:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  c9:	48 89 b0 f8 0f 00 00 	mov    %rsi,0xff8(%rax)
  d0:	48 29 f8             	sub    %rdi,%rax
  d3:	48 29 c1             	sub    %rax,%rcx
  d6:	05 00 10 00 00       	add    $0x1000,%eax
  db:	c1 e8 03             	shr    $0x3,%eax
  de:	48 89 ce             	mov    %rcx,%rsi
  e1:	89 c1                	mov    %eax,%ecx
  e3:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
  e6:	49 8b 40 08          	mov    0x8(%r8),%rax
	if (unlikely(head & 1))
  ea:	a8 01                	test   $0x1,%al
  ec:	74 45                	je     133 <nvm_flush_mpt_pages.cold+0xc2>
		return (struct page *) (head - 1);
  ee:	48 83 e8 01          	sub    $0x1,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
  f2:	48 8b 00             	mov    (%rax),%rax
		if (!PageDirty(mpt_page))
  f5:	a8 10                	test   $0x10,%al
  f7:	75 10                	jne    109 <nvm_flush_mpt_pages.cold+0x98>
			set_page_dirty(mpt_page);
  f9:	4c 89 c7             	mov    %r8,%rdi
  fc:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
 100:	e8 00 00 00 00       	callq  105 <nvm_flush_mpt_pages.cold+0x94>
 105:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
	if (!page)
 109:	4d 85 c0             	test   %r8,%r8
 10c:	75 2a                	jne    138 <nvm_flush_mpt_pages.cold+0xc7>
		clear_bit(mpt_pgoff, nsbi->mpt_dirty_map);
 10e:	49 8b 46 58          	mov    0x58(%r14),%rax
		asm volatile(LOCK_PREFIX __ASM_SIZE(btr) " %1,%0"
 112:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
 116:	f0 48 0f b3 08       	lock btr %rcx,(%rax)
		if (flush_all) {
 11b:	41 83 c7 01          	add    $0x1,%r15d
 11f:	45 85 ed             	test   %r13d,%r13d
 122:	74 75                	je     199 <nvm_flush_mpt_pages.cold+0x128>
	while (mpt_pgoff != nsbi->mpt_dirty_map_bits) {
 124:	45 39 7e 60          	cmp    %r15d,0x60(%r14)
 128:	0f 84 00 00 00 00    	je     12e <nvm_flush_mpt_pages.cold+0xbd>
 12e:	e9 43 ff ff ff       	jmpq   76 <nvm_flush_mpt_pages.cold+0x5>
		mpt_page = get_next_mpt_page(sbi, mpt_pgoff);
 133:	4c 89 c0             	mov    %r8,%rax
 136:	eb ba                	jmp    f2 <nvm_flush_mpt_pages.cold+0x81>
 138:	49 8b 40 08          	mov    0x8(%r8),%rax
	if (unlikely(head & 1))
 13c:	a8 01                	test   $0x1,%al
 13e:	74 71                	je     1b1 <nvm_flush_mpt_pages.cold+0x140>
		return (struct page *) (head - 1);
 140:	48 83 e8 01          	sub    $0x1,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
 144:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
 147:	a8 01                	test   $0x1,%al
 149:	75 19                	jne    164 <nvm_flush_mpt_pages.cold+0xf3>
 14b:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
 14d:	49 8b 40 18          	mov    0x18(%r8),%rax
	return F2FS_SB(inode->i_sb);
 151:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
 154:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
 158:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
 15f:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
		unlock_page(page);
 164:	4c 89 c7             	mov    %r8,%rdi
 167:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
 16b:	e8 00 00 00 00       	callq  170 <nvm_flush_mpt_pages.cold+0xff>
 170:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
 174:	49 8b 40 08          	mov    0x8(%r8),%rax
	if (unlikely(head & 1))
 178:	a8 01                	test   $0x1,%al
 17a:	74 04                	je     180 <nvm_flush_mpt_pages.cold+0x10f>
		return (struct page *) (head - 1);
 17c:	4c 8d 40 ff          	lea    -0x1(%rax),%r8
 180:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 185:	f0 41 ff 48 34       	lock decl 0x34(%r8)
	if (put_page_testzero(page))
 18a:	75 82                	jne    10e <nvm_flush_mpt_pages.cold+0x9d>
		__put_page(page);
 18c:	4c 89 c7             	mov    %r8,%rdi
 18f:	e8 00 00 00 00       	callq  194 <nvm_flush_mpt_pages.cold+0x123>
 194:	e9 75 ff ff ff       	jmpq   10e <nvm_flush_mpt_pages.cold+0x9d>
			mpt_pgoff = find_next_bit(nsbi->mpt_dirty_map, nsbi->mpt_dirty_map_bits, ++mpt_pgoff);
 199:	41 8b 76 60          	mov    0x60(%r14),%esi
 19d:	49 8b 7e 58          	mov    0x58(%r14),%rdi
 1a1:	49 63 d7             	movslq %r15d,%rdx
 1a4:	e8 00 00 00 00       	callq  1a9 <nvm_flush_mpt_pages.cold+0x138>
 1a9:	41 89 c7             	mov    %eax,%r15d
 1ac:	e9 73 ff ff ff       	jmpq   124 <nvm_flush_mpt_pages.cold+0xb3>
 1b1:	4c 89 c0             	mov    %r8,%rax
 1b4:	eb 8e                	jmp    144 <nvm_flush_mpt_pages.cold+0xd3>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
 1b6:	49 8b 00             	mov    (%r8),%rax
 1b9:	48 c1 e8 33          	shr    $0x33,%rax
 1bd:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
 1c0:	83 f8 04             	cmp    $0x4,%eax
 1c3:	75 c0                	jne    185 <nvm_flush_mpt_pages.cold+0x114>
	switch (page->pgmap->type) {
 1c5:	49 8b 40 08          	mov    0x8(%r8),%rax
 1c9:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
 1cf:	83 e8 01             	sub    $0x1,%eax
 1d2:	83 f8 02             	cmp    $0x2,%eax
 1d5:	77 ae                	ja     185 <nvm_flush_mpt_pages.cold+0x114>
		__put_devmap_managed_page(page);
 1d7:	4c 89 c7             	mov    %r8,%rdi
 1da:	e8 00 00 00 00       	callq  1df <nvm_flush_mpt_pages.cold+0x16e>
		return;
 1df:	e9 2a ff ff ff       	jmpq   10e <nvm_flush_mpt_pages.cold+0x9d>

00000000000001e4 <nvm_redirect_dio>:
int nvm_redirect_dio(struct f2fs_sb_info *sbi, struct buffer_head *bh, unsigned int blk_nums, int write) {
 1e4:	f3 0f 1e fa          	endbr64 
 1e8:	e8 00 00 00 00       	callq  1ed <nvm_redirect_dio+0x9>
 1ed:	55                   	push   %rbp
 1ee:	48 89 e5             	mov    %rsp,%rbp
 1f1:	41 56                	push   %r14
 1f3:	41 89 ce             	mov    %ecx,%r14d
 1f6:	41 55                	push   %r13
 1f8:	41 89 d5             	mov    %edx,%r13d
 1fb:	41 54                	push   %r12
 1fd:	49 89 f4             	mov    %rsi,%r12
 200:	53                   	push   %rbx
	printk(KERN_INFO"ZN trap: sbi->nsbi %p",sbi->nsbi);
 201:	48 8b b7 48 07 00 00 	mov    0x748(%rdi),%rsi
int nvm_redirect_dio(struct f2fs_sb_info *sbi, struct buffer_head *bh, unsigned int blk_nums, int write) {
 208:	48 89 fb             	mov    %rdi,%rbx
	printk(KERN_INFO"ZN trap: sbi->nsbi %p",sbi->nsbi);
 20b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 212:	e8 00 00 00 00       	callq  217 <nvm_redirect_dio+0x33>
	struct nvm_sb_info *nsbi = sbi->nsbi;
 217:	48 8b bb 48 07 00 00 	mov    0x748(%rbx),%rdi
	return (struct f2fs_sm_info *)(sbi->sm_info);
 21e:	48 8b 4b 68          	mov    0x68(%rbx),%rcx
	ssd_blk_addr = bh->b_blocknr;
 222:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
	nr_nvm_main_segs = nsbi->nsb->main_segment_nums;
 227:	4c 8b 53 10          	mov    0x10(%rbx),%r10
 22b:	48 8b 07             	mov    (%rdi),%rax
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
 22e:	48 85 c9             	test   %rcx,%rcx
	nr_nvm_main_segs = nsbi->nsb->main_segment_nums;
 231:	8b 70 2c             	mov    0x2c(%rax),%esi
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
 234:	74 06                	je     23c <nvm_redirect_dio+0x58>
 236:	44 8b 49 48          	mov    0x48(%rcx),%r9d
 23a:	eb 04                	jmp    240 <nvm_redirect_dio+0x5c>
 23c:	45 8b 4a 48          	mov    0x48(%r10),%r9d
 240:	44 89 c0             	mov    %r8d,%eax
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
 243:	45 8b 42 5c          	mov    0x5c(%r10),%r8d
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
 247:	8b 8b 20 04 00 00    	mov    0x420(%rbx),%ecx
 24d:	44 29 c8             	sub    %r9d,%eax
 250:	89 c2                	mov    %eax,%edx
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
 252:	45 29 c8             	sub    %r9d,%r8d
 255:	41 d3 e8             	shr    %cl,%r8d
	ssd_segno = GET_SEGNO_FROM_SEG0(sbi, ssd_blk_addr);
 258:	d3 ea                	shr    %cl,%edx
	offset = GET_BLKOFF_FROM_SEG0(sbi, ssd_blk_addr);
 25a:	8b 8b 24 04 00 00    	mov    0x424(%rbx),%ecx
	ssd_main_segoff = ssd_segno - GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
 260:	44 29 c2             	sub    %r8d,%edx
	offset = GET_BLKOFF_FROM_SEG0(sbi, ssd_blk_addr);
 263:	44 8d 41 ff          	lea    -0x1(%rcx),%r8d
	index = nr_nvm_main_segs + ssd_main_segoff;
 267:	8d 0c 16             	lea    (%rsi,%rdx,1),%ecx
	offset = GET_BLKOFF_FROM_SEG0(sbi, ssd_blk_addr);
 26a:	41 21 c0             	and    %eax,%r8d
	return nsbi->mpt[index] & rw_redirect;
 26d:	48 8b 47 50          	mov    0x50(%rdi),%rax
 271:	48 63 c9             	movslq %ecx,%rcx
 274:	8b 04 88             	mov    (%rax,%rcx,4),%eax
 277:	83 e0 02             	and    $0x2,%eax
	if (!write) {
 27a:	45 85 f6             	test   %r14d,%r14d
 27d:	75 36                	jne    2b5 <nvm_redirect_dio+0xd1>
	if (size < 4)return size1;
 27f:	be 05 00 00 00       	mov    $0x5,%esi
 284:	41 83 fd 03          	cmp    $0x3,%r13d
 288:	7e 17                	jle    2a1 <nvm_redirect_dio+0xbd>
	else if (size < 8)return size2;
 28a:	be 03 00 00 00       	mov    $0x3,%esi
 28f:	41 83 fd 07          	cmp    $0x7,%r13d
 293:	7e 0c                	jle    2a1 <nvm_redirect_dio+0xbd>
	else return size4;
 295:	31 f6                	xor    %esi,%esi
 297:	41 83 fd 10          	cmp    $0x10,%r13d
 29b:	40 0f 9c c6          	setl   %sil
 29f:	ff c6                	inc    %esi
		atomic_add(size_count,&nsbi->lfu_count[nsbi->now_lfu_counter][ssd_main_segoff]);
 2a1:	44 8b 8f 90 00 00 00 	mov    0x90(%rdi),%r9d
 2a8:	4e 8b 8c cf 98 00 00 	mov    0x98(%rdi,%r9,8),%r9
 2af:	00 
	asm volatile(LOCK_PREFIX "addl %1,%0"
 2b0:	f0 41 01 34 91       	lock add %esi,(%r9,%rdx,4)
	if (!redirect_flag) {
 2b5:	85 c0                	test   %eax,%eax
 2b7:	74 30                	je     2e9 <nvm_redirect_dio+0x105>
	return nsbi->mpt[index] >> rw_bits;
 2b9:	48 8b 83 48 07 00 00 	mov    0x748(%rbx),%rax
	nvm_blk_addr = nsbi->nsb->main_blkaddr + nvm_main_segoff * sbi->blocks_per_seg + offset;
 2c0:	48 8b 17             	mov    (%rdi),%rdx
 2c3:	48 8b 40 50          	mov    0x50(%rax),%rax
 2c7:	44 03 42 18          	add    0x18(%rdx),%r8d
 2cb:	8b 04 88             	mov    (%rax,%rcx,4),%eax
 2ce:	c1 e8 03             	shr    $0x3,%eax
 2d1:	0f af 83 24 04 00 00 	imul   0x424(%rbx),%eax
 2d8:	44 01 c0             	add    %r8d,%eax
	bh->b_blocknr = nvm_blk_addr;
 2db:	49 89 44 24 18       	mov    %rax,0x18(%r12)
	bh->b_bdev = nsbi->nbdev;
 2e0:	48 8b 47 08          	mov    0x8(%rdi),%rax
 2e4:	49 89 44 24 30       	mov    %rax,0x30(%r12)
}
 2e9:	5b                   	pop    %rbx
 2ea:	31 c0                	xor    %eax,%eax
 2ec:	41 5c                	pop    %r12
 2ee:	41 5d                	pop    %r13
 2f0:	41 5e                	pop    %r14
 2f2:	5d                   	pop    %rbp
 2f3:	c3                   	retq   

00000000000002f4 <__nvm_debug.cold>:
	va_start(args, fmt);
 2f4:	48 8d 45 10          	lea    0x10(%rbp),%rax
	vaf.fmt = fmt;
 2f8:	48 89 0c 24          	mov    %rcx,(%rsp)
	printk(KERN_ERR "(%s, %u): %pV", func, line, &vaf);
 2fc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 303:	48 89 e1             	mov    %rsp,%rcx
	va_start(args, fmt);
 306:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
 30b:	48 8d 44 24 30       	lea    0x30(%rsp),%rax
 310:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
	vaf.va = &args;
 315:	48 8d 44 24 10       	lea    0x10(%rsp),%rax
	va_start(args, fmt);
 31a:	c7 44 24 10 20 00 00 	movl   $0x20,0x10(%rsp)
 321:	00 
	vaf.va = &args;
 322:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
	printk(KERN_ERR "(%s, %u): %pV", func, line, &vaf);
 327:	e8 00 00 00 00       	callq  32c <__nvm_debug.cold+0x38>
 32c:	e9 00 00 00 00       	jmpq   331 <__nvm_debug.cold+0x3d>
