
data.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <__is_cp_guaranteed>:
#define NUM_PREALLOC_POST_READ_CTXS    128

static struct kmem_cache *bio_post_read_ctx_cache;
static mempool_t *bio_post_read_ctx_pool;

static bool __is_cp_guaranteed(struct page *page) {
       0:	e8 00 00 00 00       	callq  5 <__is_cp_guaranteed+0x5>
       5:	55                   	push   %rbp
	struct address_space *mapping = page->mapping;
       6:	48 8b 47 18          	mov    0x18(%rdi),%rax
static bool __is_cp_guaranteed(struct page *page) {
       a:	48 89 e5             	mov    %rsp,%rbp
	struct inode *inode;
	struct f2fs_sb_info *sbi;

	if (!mapping)
       d:	48 85 c0             	test   %rax,%rax
      10:	74 50                	je     62 <__is_cp_guaranteed+0x62>
		return false;

	inode = mapping->host;
      12:	48 8b 10             	mov    (%rax),%rdx
	return container_of(inode, struct f2fs_inode_info, vfs_inode);
}

static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)
{
	return sb->s_fs_info;
      15:	48 8b 42 28          	mov    0x28(%rdx),%rax
	sbi = F2FS_I_SB(inode);

	if (inode->i_ino == F2FS_META_INO(sbi) ||
      19:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
      1d:	48 8b b0 08 04 00 00 	mov    0x408(%rax),%rsi
		inode->i_ino == F2FS_NODE_INO(sbi) ||
		S_ISDIR(inode->i_mode) ||
		(S_ISREG(inode->i_mode) &&
		 is_inode_flag_set(inode, FI_ATOMIC_FILE)) ||
		is_cold_data(page))
		return true;
      24:	b8 01 00 00 00       	mov    $0x1,%eax
	if (inode->i_ino == F2FS_META_INO(sbi) ||
      29:	44 8b 86 1c 04 00 00 	mov    0x41c(%rsi),%r8d
      30:	4c 39 c1             	cmp    %r8,%rcx
      33:	74 2b                	je     60 <__is_cp_guaranteed+0x60>
		inode->i_ino == F2FS_NODE_INO(sbi) ||
      35:	8b b6 18 04 00 00    	mov    0x418(%rsi),%esi
	if (inode->i_ino == F2FS_META_INO(sbi) ||
      3b:	48 39 f1             	cmp    %rsi,%rcx
      3e:	74 20                	je     60 <__is_cp_guaranteed+0x60>
      40:	0f b7 0a             	movzwl (%rdx),%ecx
      43:	66 81 e1 00 f0       	and    $0xf000,%cx
		inode->i_ino == F2FS_NODE_INO(sbi) ||
      48:	66 81 f9 00 40       	cmp    $0x4000,%cx
      4d:	74 11                	je     60 <__is_cp_guaranteed+0x60>
		S_ISDIR(inode->i_mode) ||
      4f:	66 81 f9 00 80       	cmp    $0x8000,%cx
      54:	74 10                	je     66 <__is_cp_guaranteed+0x66>
}

static __always_inline bool constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
      56:	48 8b 07             	mov    (%rdi),%rax
      59:	48 c1 e8 09          	shr    $0x9,%rax
      5d:	83 e0 01             	and    $0x1,%eax
	return false;
}
      60:	5d                   	pop    %rbp
      61:	c3                   	retq   
		return false;
      62:	31 c0                	xor    %eax,%eax
}
      64:	5d                   	pop    %rbp
      65:	c3                   	retq   
      66:	48 8b 82 78 02 00 00 	mov    0x278(%rdx),%rax
      6d:	48 c1 e8 0f          	shr    $0xf,%rax
		(S_ISREG(inode->i_mode) &&
      71:	83 e0 01             	and    $0x1,%eax
      74:	74 e0                	je     56 <__is_cp_guaranteed+0x56>
}
      76:	5d                   	pop    %rbp
      77:	c3                   	retq   
      78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
      7f:	00 

0000000000000080 <__set_data_blkaddr>:
	}
	__submit_bio(F2FS_I_SB(inode), bio, DATA);
	return 0;
}

static void __set_data_blkaddr(struct dnode_of_data *dn) {
      80:	e8 00 00 00 00       	callq  85 <__set_data_blkaddr+0x5>
      85:	55                   	push   %rbp
 */
#include <linux/vmstat.h>

static __always_inline void *lowmem_page_address(const struct page *page)
{
	return page_to_virt(page);
      86:	48 8b 47 10          	mov    0x10(%rdi),%rax
			(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;
}

static inline __le32 *blkaddr_in_node(struct f2fs_node *node)
{
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
      8a:	31 d2                	xor    %edx,%edx
      8c:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 93 <__set_data_blkaddr+0x13>
      93:	48 c1 f8 06          	sar    $0x6,%rax
      97:	48 c1 e0 0c          	shl    $0xc,%rax
      9b:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # a2 <__set_data_blkaddr+0x22>
      a2:	48 89 e5             	mov    %rsp,%rbp
	struct f2fs_node *rn = F2FS_NODE(dn->node_page);
	__le32 *addr_array;
	int base = 0;

	if (IS_INODE(dn->node_page) && f2fs_has_extra_attr(dn->inode))
      a5:	8b b0 ec 0f 00 00    	mov    0xfec(%rax),%esi
      ab:	48 89 c1             	mov    %rax,%rcx
      ae:	39 b0 e8 0f 00 00    	cmp    %esi,0xfe8(%rax)
      b4:	74 0b                	je     c1 <__set_data_blkaddr+0x41>
		base = get_extra_isize(dn->inode);

	/* Get physical address of data block */
	addr_array = blkaddr_in_node(rn);
	addr_array[base + dn->ofs_in_node] = cpu_to_le32(dn->data_blkaddr);
      b6:	8b 47 24             	mov    0x24(%rdi),%eax
      b9:	03 57 1c             	add    0x1c(%rdi),%edx
      bc:	89 04 91             	mov    %eax,(%rcx,%rdx,4)
}
      bf:	5d                   	pop    %rbp
      c0:	c3                   	retq   
	if (IS_INODE(dn->node_page) && f2fs_has_extra_attr(dn->inode))
      c1:	48 8b 0f             	mov    (%rdi),%rcx
      c4:	48 8b b1 78 02 00 00 	mov    0x278(%rcx),%rsi
      cb:	f7 c6 00 00 00 04    	test   $0x4000000,%esi
      d1:	74 0b                	je     de <__set_data_blkaddr+0x5e>
	return f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);
}

static inline int get_extra_isize(struct inode *inode)
{
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
      d3:	48 63 91 08 04 00 00 	movslq 0x408(%rcx),%rdx
      da:	48 c1 ea 02          	shr    $0x2,%rdx
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
      de:	48 8d 88 68 01 00 00 	lea    0x168(%rax),%rcx
	addr_array[base + dn->ofs_in_node] = cpu_to_le32(dn->data_blkaddr);
      e5:	8b 47 24             	mov    0x24(%rdi),%eax
      e8:	03 57 1c             	add    0x1c(%rdi),%edx
      eb:	89 04 91             	mov    %eax,(%rcx,%rdx,4)
}
      ee:	5d                   	pop    %rbp
      ef:	c3                   	retq   

00000000000000f0 <__submit_merged_bio>:
static void __submit_merged_bio(struct f2fs_bio_info *io) {
      f0:	e8 00 00 00 00       	callq  f5 <__submit_merged_bio+0x5>
	if (!io->bio)
      f5:	48 8b 57 08          	mov    0x8(%rdi),%rdx
      f9:	48 85 d2             	test   %rdx,%rdx
      fc:	0f 84 63 03 00 00    	je     465 <__submit_merged_bio+0x375>
static void __submit_merged_bio(struct f2fs_bio_info *io) {
     102:	55                   	push   %rbp
     103:	48 89 e5             	mov    %rsp,%rbp
     106:	41 57                	push   %r15
     108:	41 56                	push   %r14
     10a:	41 55                	push   %r13
     10c:	41 54                	push   %r12
     10e:	53                   	push   %rbx
     10f:	48 89 fb             	mov    %rdi,%rbx
     112:	48 83 ec 08          	sub    $0x8,%rsp

/* obsolete, don't use in new code */
static inline void bio_set_op_attrs(struct bio *bio, unsigned op,
		unsigned op_flags)
{
	bio->bi_opf = op | op_flags;
     116:	8b 47 30             	mov    0x30(%rdi),%eax
     119:	0b 47 2c             	or     0x2c(%rdi),%eax
     11c:	89 42 10             	mov    %eax,0x10(%rdx)
	if (is_read_io(fio->op))
     11f:	8b 47 2c             	mov    0x2c(%rdi),%eax
		trace_f2fs_prepare_read_bio(io->sbi->sb, fio->type, io->bio);
     122:	4c 8b 2f             	mov    (%rdi),%r13
     125:	4c 8b 67 08          	mov    0x8(%rdi),%r12
	if (is_read_io(fio->op))
     129:	85 c0                	test   %eax,%eax
		trace_f2fs_prepare_read_bio(io->sbi->sb, fio->type, io->bio);
     12b:	44 8b 77 24          	mov    0x24(%rdi),%r14d
     12f:	49 8b 45 00          	mov    0x0(%r13),%rax
	if (is_read_io(fio->op))
     133:	75 4f                	jne    184 <__submit_merged_bio+0x94>
#include <linux/stringify.h>
#include <linux/types.h>

static __always_inline bool arch_static_branch(struct static_key *key, bool branch)
{
	asm_volatile_goto("1:"
     135:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	if (!is_read_io(bio_op(bio))) {
     13a:	41 0f b6 54 24 10    	movzbl 0x10(%r12),%edx
		if (type != DATA && type != NODE)
     140:	41 83 fe 01          	cmp    $0x1,%r14d
     144:	0f 87 13 01 00 00    	ja     25d <__submit_merged_bio+0x16d>
     14a:	85 d2                	test   %edx,%edx
     14c:	0f 85 e1 01 00 00    	jne    333 <__submit_merged_bio+0x243>
     152:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
     157:	44 89 f2             	mov    %r14d,%edx
     15a:	4c 89 e6             	mov    %r12,%rsi
     15d:	4c 89 ef             	mov    %r13,%rdi
     160:	e8 00 00 00 00       	callq  165 <__submit_merged_bio+0x75>
	submit_bio(bio);//提交进行io操作
     165:	4c 89 e7             	mov    %r12,%rdi
     168:	e8 00 00 00 00       	callq  16d <__submit_merged_bio+0x7d>
	io->bio = NULL;
     16d:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
     174:	00 
}
     175:	48 83 c4 08          	add    $0x8,%rsp
     179:	5b                   	pop    %rbx
     17a:	41 5c                	pop    %r12
     17c:	41 5d                	pop    %r13
     17e:	41 5e                	pop    %r14
     180:	41 5f                	pop    %r15
     182:	5d                   	pop    %rbp
     183:	c3                   	retq   
     184:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     189:	eb af                	jmp    13a <__submit_merged_bio+0x4a>
	TP_ARGS(sb, type, bio),

	TP_CONDITION(bio)
);

DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
     18b:	65 8b 15 00 00 00 00 	mov    %gs:0x0(%rip),%edx        # 192 <__submit_merged_bio+0xa2>
 *
 * Returns 1 if @cpu is set in @cpumask, else returns 0
 */
static inline int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)
{
	return test_bit(cpumask_check(cpu), cpumask_bits((cpumask)));
     192:	89 d2                	mov    %edx,%edx

static __always_inline bool variable_test_bit(long nr, volatile const unsigned long *addr)
{
	bool oldbit;

	asm volatile(__ASM_SIZE(bt) " %2,%1"
     194:	48 0f a3 15 00 00 00 	bt     %rdx,0x0(%rip)        # 19c <__submit_merged_bio+0xac>
     19b:	00 
     19c:	0f 92 c2             	setb   %dl
     19f:	4d 85 e4             	test   %r12,%r12
     1a2:	74 b3                	je     157 <__submit_merged_bio+0x67>
     1a4:	84 d2                	test   %dl,%dl
     1a6:	74 af                	je     157 <__submit_merged_bio+0x67>
})

static __always_inline
void __read_once_size(const volatile void *p, void *res, int size)
{
	__READ_ONCE_SIZE;
     1a8:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # 1af <__submit_merged_bio+0xbf>
     1af:	4d 85 ff             	test   %r15,%r15
     1b2:	74 29                	je     1dd <__submit_merged_bio+0xed>
     1b4:	4d 8b 07             	mov    (%r15),%r8
     1b7:	49 8b 7f 08          	mov    0x8(%r15),%rdi
     1bb:	49 83 c7 18          	add    $0x18,%r15
     1bf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     1c3:	48 89 c6             	mov    %rax,%rsi
     1c6:	4c 89 e1             	mov    %r12,%rcx
     1c9:	44 89 f2             	mov    %r14d,%edx
     1cc:	e8 00 00 00 00       	callq  1d1 <__submit_merged_bio+0xe1>
     1d1:	4d 8b 07             	mov    (%r15),%r8
     1d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     1d8:	4d 85 c0             	test   %r8,%r8
     1db:	75 da                	jne    1b7 <__submit_merged_bio+0xc7>
/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */
static inline notrace void rcu_read_unlock_sched_notrace(void)
{
	__release(RCU_SCHED);
	preempt_enable_notrace();
}
     1dd:	e9 75 ff ff ff       	jmpq   157 <__submit_merged_bio+0x67>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_prepare_write_bio,
     1e2:	65 8b 15 00 00 00 00 	mov    %gs:0x0(%rip),%edx        # 1e9 <__submit_merged_bio+0xf9>
     1e9:	89 d2                	mov    %edx,%edx
     1eb:	48 0f a3 15 00 00 00 	bt     %rdx,0x0(%rip)        # 1f3 <__submit_merged_bio+0x103>
     1f2:	00 
     1f3:	0f 92 c2             	setb   %dl
     1f6:	4d 85 e4             	test   %r12,%r12
     1f9:	0f 84 3b ff ff ff    	je     13a <__submit_merged_bio+0x4a>
     1ff:	84 d2                	test   %dl,%dl
     201:	0f 84 33 ff ff ff    	je     13a <__submit_merged_bio+0x4a>
     207:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 20e <__submit_merged_bio+0x11e>
     20e:	4d 85 ed             	test   %r13,%r13
     211:	74 2b                	je     23e <__submit_merged_bio+0x14e>
     213:	4d 8b 45 00          	mov    0x0(%r13),%r8
     217:	49 8b 7d 08          	mov    0x8(%r13),%rdi
     21b:	49 83 c5 18          	add    $0x18,%r13
     21f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     223:	48 89 c6             	mov    %rax,%rsi
     226:	4c 89 e1             	mov    %r12,%rcx
     229:	44 89 f2             	mov    %r14d,%edx
     22c:	e8 00 00 00 00       	callq  231 <__submit_merged_bio+0x141>
     231:	4d 8b 45 00          	mov    0x0(%r13),%r8
     235:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     239:	4d 85 c0             	test   %r8,%r8
     23c:	75 d9                	jne    217 <__submit_merged_bio+0x127>
	preempt_enable_notrace();
     23e:	4c 8b 63 08          	mov    0x8(%rbx),%r12
     242:	4c 8b 2b             	mov    (%rbx),%r13
     245:	44 8b 73 24          	mov    0x24(%rbx),%r14d
     249:	49 8b 45 00          	mov    0x0(%r13),%rax
	if (!is_read_io(bio_op(bio))) {
     24d:	41 0f b6 54 24 10    	movzbl 0x10(%r12),%edx
		if (type != DATA && type != NODE)
     253:	41 83 fe 01          	cmp    $0x1,%r14d
     257:	0f 86 ed fe ff ff    	jbe    14a <__submit_merged_bio+0x5a>
	if (is_read_io(bio_op(bio)))
     25d:	85 d2                	test   %edx,%edx
     25f:	0f 84 ed fe ff ff    	je     152 <__submit_merged_bio+0x62>
     265:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     26a:	e9 e8 fe ff ff       	jmpq   157 <__submit_merged_bio+0x67>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_prepare_read_bio,
     26f:	65 8b 15 00 00 00 00 	mov    %gs:0x0(%rip),%edx        # 276 <__submit_merged_bio+0x186>
     276:	89 d2                	mov    %edx,%edx
     278:	48 0f a3 15 00 00 00 	bt     %rdx,0x0(%rip)        # 280 <__submit_merged_bio+0x190>
     27f:	00 
     280:	0f 92 c2             	setb   %dl
     283:	4d 85 e4             	test   %r12,%r12
     286:	0f 84 ae fe ff ff    	je     13a <__submit_merged_bio+0x4a>
     28c:	84 d2                	test   %dl,%dl
     28e:	0f 84 a6 fe ff ff    	je     13a <__submit_merged_bio+0x4a>
     294:	4c 8b 2d 00 00 00 00 	mov    0x0(%rip),%r13        # 29b <__submit_merged_bio+0x1ab>
     29b:	4d 85 ed             	test   %r13,%r13
     29e:	74 9e                	je     23e <__submit_merged_bio+0x14e>
     2a0:	4d 8b 45 00          	mov    0x0(%r13),%r8
     2a4:	49 8b 7d 08          	mov    0x8(%r13),%rdi
     2a8:	49 83 c5 18          	add    $0x18,%r13
     2ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     2b0:	48 89 c6             	mov    %rax,%rsi
     2b3:	4c 89 e1             	mov    %r12,%rcx
     2b6:	44 89 f2             	mov    %r14d,%edx
     2b9:	e8 00 00 00 00       	callq  2be <__submit_merged_bio+0x1ce>
     2be:	4d 8b 45 00          	mov    0x0(%r13),%r8
     2c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     2c6:	4d 85 c0             	test   %r8,%r8
     2c9:	75 d9                	jne    2a4 <__submit_merged_bio+0x1b4>
     2cb:	e9 6e ff ff ff       	jmpq   23e <__submit_merged_bio+0x14e>
	TP_ARGS(sb, type, bio),

	TP_CONDITION(bio)
);

DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
     2d0:	65 8b 15 00 00 00 00 	mov    %gs:0x0(%rip),%edx        # 2d7 <__submit_merged_bio+0x1e7>
     2d7:	89 d2                	mov    %edx,%edx
     2d9:	48 0f a3 15 00 00 00 	bt     %rdx,0x0(%rip)        # 2e1 <__submit_merged_bio+0x1f1>
     2e0:	00 
     2e1:	0f 92 c2             	setb   %dl
     2e4:	4d 85 e4             	test   %r12,%r12
     2e7:	0f 84 6a fe ff ff    	je     157 <__submit_merged_bio+0x67>
     2ed:	84 d2                	test   %dl,%dl
     2ef:	0f 84 62 fe ff ff    	je     157 <__submit_merged_bio+0x67>
     2f5:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # 2fc <__submit_merged_bio+0x20c>
     2fc:	4d 85 ff             	test   %r15,%r15
     2ff:	0f 84 d8 fe ff ff    	je     1dd <__submit_merged_bio+0xed>
     305:	4d 8b 07             	mov    (%r15),%r8
     308:	49 8b 7f 08          	mov    0x8(%r15),%rdi
     30c:	49 83 c7 18          	add    $0x18,%r15
     310:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     314:	48 89 c6             	mov    %rax,%rsi
     317:	4c 89 e1             	mov    %r12,%rcx
     31a:	44 89 f2             	mov    %r14d,%edx
     31d:	e8 00 00 00 00       	callq  322 <__submit_merged_bio+0x232>
     322:	4d 8b 07             	mov    (%r15),%r8
     325:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     329:	4d 85 c0             	test   %r8,%r8
     32c:	75 da                	jne    308 <__submit_merged_bio+0x218>
     32e:	e9 24 fe ff ff       	jmpq   157 <__submit_merged_bio+0x67>
{ \
	return F2FS_HAS_FEATURE(sb, F2FS_FEATURE_##flagname); \
}

F2FS_FEATURE_FUNCS(encrypt, ENCRYPT);
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
     333:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
     33a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
     33e:	f6 82 84 08 00 00 02 	testb  $0x2,0x884(%rdx)
     345:	0f 85 d2 00 00 00    	jne    41d <__submit_merged_bio+0x32d>
		start %= F2FS_IO_SIZE(sbi);
     34b:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
     352:	41 8b 74 24 30       	mov    0x30(%r12),%esi
		start %= F2FS_IO_SIZE(sbi);
     357:	ba 01 00 00 00       	mov    $0x1,%edx
     35c:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
     35e:	c1 ee 0c             	shr    $0xc,%esi
		start %= F2FS_IO_SIZE(sbi);
     361:	44 8d 7a ff          	lea    -0x1(%rdx),%r15d
		if (start == 0)
     365:	41 21 f7             	and    %esi,%r15d
     368:	0f 84 f7 fe ff ff    	je     265 <__submit_merged_bio+0x175>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
     36e:	44 39 fa             	cmp    %r15d,%edx
     371:	0f 86 8b 00 00 00    	jbe    402 <__submit_merged_bio+0x312>
					mempool_alloc(sbi->write_io_dummy,
     377:	49 8b bd 70 01 00 00 	mov    0x170(%r13),%rdi
     37e:	be 00 88 60 00       	mov    $0x608800,%esi
     383:	e8 00 00 00 00       	callq  388 <__submit_merged_bio+0x298>
     388:	48 89 c6             	mov    %rax,%rsi
			f2fs_bug_on(sbi, !page);
     38b:	48 85 c0             	test   %rax,%rax
     38e:	0f 84 e7 00 00 00    	je     47b <__submit_merged_bio+0x38b>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     394:	f0 80 4e 01 10       	lock orb $0x10,0x1(%rsi)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
     399:	48 c7 46 28 fe ff ff 	movq   $0xfffffffffffffffe,0x28(%rsi)
     3a0:	ff 
     3a1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
/*
 * lock_page may only be called if we have the page's inode pinned.
 */
static inline void lock_page(struct page *page)
{
	might_sleep();
     3a5:	e8 00 00 00 00       	callq  3aa <__submit_merged_bio+0x2ba>
     3aa:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     3ae:	48 8b 56 08          	mov    0x8(%rsi),%rdx
static inline struct page *compound_head(struct page *page)
{
	unsigned long head = READ_ONCE(page->compound_head);

	if (unlikely(head & 1))
		return (struct page *) (head - 1);
     3b2:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     3b6:	83 e2 01             	and    $0x1,%edx
     3b9:	48 0f 44 c6          	cmove  %rsi,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
     3bd:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
     3c3:	0f 82 9d 00 00 00    	jb     466 <__submit_merged_bio+0x376>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
     3c9:	31 c9                	xor    %ecx,%ecx
     3cb:	ba 00 10 00 00       	mov    $0x1000,%edx
     3d0:	4c 89 e7             	mov    %r12,%rdi
     3d3:	e8 00 00 00 00       	callq  3d8 <__submit_merged_bio+0x2e8>
     3d8:	3d ff 0f 00 00       	cmp    $0xfff,%eax
     3dd:	77 08                	ja     3e7 <__submit_merged_bio+0x2f7>
				f2fs_bug_on(sbi, 1);
     3df:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
     3e1:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
     3e7:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
     3ee:	b8 01 00 00 00       	mov    $0x1,%eax
     3f3:	41 83 c7 01          	add    $0x1,%r15d
     3f7:	d3 e0                	shl    %cl,%eax
     3f9:	41 39 c7             	cmp    %eax,%r15d
     3fc:	0f 82 75 ff ff ff    	jb     377 <__submit_merged_bio+0x287>
		if (type == NODE)
     402:	41 83 fe 01          	cmp    $0x1,%r14d
     406:	75 06                	jne    40e <__submit_merged_bio+0x31e>
     408:	f0 41 80 4d 48 20    	lock orb $0x20,0x48(%r13)
     40e:	41 0f b6 54 24 10    	movzbl 0x10(%r12),%edx
     414:	49 8b 45 00          	mov    0x0(%r13),%rax
}
     418:	e9 40 fe ff ff       	jmpq   25d <__submit_merged_bio+0x16d>

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
     41d:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
     424:	00 00 
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
     426:	48 83 ba 48 0b 00 00 	cmpq   $0x0,0xb48(%rdx)
     42d:	00 
     42e:	0f 84 17 ff ff ff    	je     34b <__submit_merged_bio+0x25b>
			blk_finish_plug(current->plug);
     434:	48 8b ba 48 0b 00 00 	mov    0xb48(%rdx),%rdi
     43b:	e8 00 00 00 00       	callq  440 <__submit_merged_bio+0x350>
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
     440:	41 8b 44 24 30       	mov    0x30(%r12),%eax
		start %= F2FS_IO_SIZE(sbi);
     445:	ba 01 00 00 00       	mov    $0x1,%edx
     44a:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
     451:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
     453:	c1 e8 0c             	shr    $0xc,%eax
		start %= F2FS_IO_SIZE(sbi);
     456:	44 8d 7a ff          	lea    -0x1(%rdx),%r15d
		if (start == 0)
     45a:	41 21 c7             	and    %eax,%r15d
     45d:	0f 85 0b ff ff ff    	jne    36e <__submit_merged_bio+0x27e>
     463:	eb a9                	jmp    40e <__submit_merged_bio+0x31e>
     465:	c3                   	retq   
		__lock_page(page);
     466:	48 89 f7             	mov    %rsi,%rdi
     469:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
     46d:	e8 00 00 00 00       	callq  472 <__submit_merged_bio+0x382>
     472:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     476:	e9 4e ff ff ff       	jmpq   3c9 <__submit_merged_bio+0x2d9>
			f2fs_bug_on(sbi, !page);
     47b:	0f 0b                	ud2    
     47d:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
     483:	e9 0c ff ff ff       	jmpq   394 <__submit_merged_bio+0x2a4>
     488:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     48f:	00 

0000000000000490 <__read_end_io>:
static void __read_end_io(struct bio *bio) {
     490:	e8 00 00 00 00       	callq  495 <__read_end_io+0x5>
     495:	55                   	push   %rbp
     496:	48 89 e5             	mov    %rsp,%rbp
     499:	41 55                	push   %r13
     49b:	49 89 fd             	mov    %rdi,%r13
     49e:	41 54                	push   %r12
     4a0:	53                   	push   %rbx
     4a1:	31 db                	xor    %ebx,%ebx
	bio_for_each_segment_all(bv, bio, i) {
     4a3:	66 83 7f 70 00       	cmpw   $0x0,0x70(%rdi)
     4a8:	4c 8b 67 78          	mov    0x78(%rdi),%r12
     4ac:	75 22                	jne    4d0 <__read_end_io+0x40>
     4ae:	eb 44                	jmp    4f4 <__read_end_io+0x64>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     4b0:	48 8b 07             	mov    (%rdi),%rax
		if (bio->bi_status || PageError(page)) {
     4b3:	a8 02                	test   $0x2,%al
     4b5:	75 24                	jne    4db <__read_end_io+0x4b>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     4b7:	f0 80 0f 08          	lock orb $0x8,(%rdi)
		unlock_page(page);
     4bb:	e8 00 00 00 00       	callq  4c0 <__read_end_io+0x30>
	bio_for_each_segment_all(bv, bio, i) {
     4c0:	41 0f b7 45 70       	movzwl 0x70(%r13),%eax
     4c5:	83 c3 01             	add    $0x1,%ebx
     4c8:	49 83 c4 10          	add    $0x10,%r12
     4cc:	39 d8                	cmp    %ebx,%eax
     4ce:	7e 24                	jle    4f4 <__read_end_io+0x64>
		if (bio->bi_status || PageError(page)) {
     4d0:	41 80 7d 1a 00       	cmpb   $0x0,0x1a(%r13)
		page = bv->bv_page;
     4d5:	49 8b 3c 24          	mov    (%r12),%rdi
		if (bio->bi_status || PageError(page)) {
     4d9:	74 d5                	je     4b0 <__read_end_io+0x20>
     4db:	48 8b 57 08          	mov    0x8(%rdi),%rdx
     4df:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     4e3:	83 e2 01             	and    $0x1,%edx
     4e6:	48 0f 44 c7          	cmove  %rdi,%rax
		asm volatile(LOCK_PREFIX "andb %1,%0"
     4ea:	f0 80 20 f7          	lock andb $0xf7,(%rax)
		asm volatile(LOCK_PREFIX "orb %1,%0"
     4ee:	f0 80 0f 02          	lock orb $0x2,(%rdi)
#define TESTSCFLAG_FALSE(uname)						\
	TESTSETFLAG_FALSE(uname) TESTCLEARFLAG_FALSE(uname)

__PAGEFLAG(Locked, locked, PF_NO_TAIL)
PAGEFLAG(Waiters, waiters, PF_ONLY_HEAD) __CLEARPAGEFLAG(Waiters, waiters, PF_ONLY_HEAD)
PAGEFLAG(Error, error, PF_NO_COMPOUND) TESTCLEARFLAG(Error, error, PF_NO_COMPOUND)
     4f2:	eb c7                	jmp    4bb <__read_end_io+0x2b>
	if (bio->bi_private)
     4f4:	49 8b 7d 50          	mov    0x50(%r13),%rdi
     4f8:	48 85 ff             	test   %rdi,%rdi
     4fb:	74 0c                	je     509 <__read_end_io+0x79>
		mempool_free(bio->bi_private, bio_post_read_ctx_pool);
     4fd:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 504 <__read_end_io+0x74>
     504:	e8 00 00 00 00       	callq  509 <__read_end_io+0x79>
	bio_put(bio);
     509:	4c 89 ef             	mov    %r13,%rdi
     50c:	e8 00 00 00 00       	callq  511 <__read_end_io+0x81>
}
     511:	5b                   	pop    %rbx
     512:	41 5c                	pop    %r12
     514:	41 5d                	pop    %r13
     516:	5d                   	pop    %rbp
     517:	c3                   	retq   
     518:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     51f:	00 

0000000000000520 <f2fs_write_end_io>:
static void f2fs_write_end_io(struct bio *bio) {
     520:	f3 0f 1e fa          	endbr64 
     524:	e8 00 00 00 00       	callq  529 <f2fs_write_end_io+0x9>
     529:	55                   	push   %rbp
     52a:	48 89 e5             	mov    %rsp,%rbp
     52d:	41 57                	push   %r15
     52f:	49 89 ff             	mov    %rdi,%r15
     532:	41 56                	push   %r14
     534:	41 55                	push   %r13
     536:	45 31 ed             	xor    %r13d,%r13d
     539:	41 54                	push   %r12
     53b:	53                   	push   %rbx
     53c:	48 83 ec 10          	sub    $0x10,%rsp
	bio_for_each_segment_all(bvec, bio, i) {
     540:	66 83 7f 70 00       	cmpw   $0x0,0x70(%rdi)
	struct f2fs_sb_info *sbi = bio->bi_private;
     545:	48 8b 5f 50          	mov    0x50(%rdi),%rbx
	bio_for_each_segment_all(bvec, bio, i) {
     549:	4c 8b 77 78          	mov    0x78(%rdi),%r14
     54d:	75 4c                	jne    59b <f2fs_write_end_io+0x7b>
     54f:	e9 a2 00 00 00       	jmpq   5f6 <f2fs_write_end_io+0xd6>
		if (unlikely(bio->bi_status)) {
     554:	41 80 7f 1a 00       	cmpb   $0x0,0x1a(%r15)
     559:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
     55e:	0f 85 1b 01 00 00    	jne    67f <f2fs_write_end_io+0x15f>
	return sbi->node_inode->i_mapping;
     564:	48 8b 4b 60          	mov    0x60(%rbx),%rcx
		f2fs_bug_on(sbi, page->mapping == NODE_MAPPING(sbi) &&
     568:	48 39 51 30          	cmp    %rdx,0x30(%rcx)
     56c:	0f 84 d6 00 00 00    	je     648 <f2fs_write_end_io+0x128>
 *
 * Atomically decrements @v by 1.
 */
static __always_inline void arch_atomic_dec(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "decl %0"
     572:	f0 ff 8c 83 74 04 00 	lock decl 0x474(%rbx,%rax,4)
     579:	00 
		asm volatile(LOCK_PREFIX "andb %1,%0"
     57a:	f0 41 80 64 24 01 fd 	lock andb $0xfd,0x1(%r12)
		end_page_writeback(page);
     581:	4c 89 e7             	mov    %r12,%rdi
     584:	e8 00 00 00 00       	callq  589 <f2fs_write_end_io+0x69>
	bio_for_each_segment_all(bvec, bio, i) {
     589:	41 0f b7 47 70       	movzwl 0x70(%r15),%eax
     58e:	41 83 c5 01          	add    $0x1,%r13d
     592:	49 83 c6 10          	add    $0x10,%r14
     596:	44 39 e8             	cmp    %r13d,%eax
     599:	7e 5b                	jle    5f6 <f2fs_write_end_io+0xd6>
		struct page *page = bvec->bv_page;
     59b:	4d 8b 26             	mov    (%r14),%r12
		enum count_type type = WB_DATA_TYPE(page);
     59e:	4c 89 e7             	mov    %r12,%rdi
     5a1:	e8 5a fa ff ff       	callq  0 <__is_cp_guaranteed>
     5a6:	84 c0                	test   %al,%al
     5a8:	0f 94 c0             	sete   %al
     5ab:	0f b6 c0             	movzbl %al,%eax
     5ae:	83 c0 07             	add    $0x7,%eax
		if (IS_DUMMY_WRITTEN_PAGE(page)) {
     5b1:	49 83 7c 24 28 fe    	cmpq   $0xfffffffffffffffe,0x28(%r12)
     5b7:	75 9b                	jne    554 <f2fs_write_end_io+0x34>
			set_page_private(page, (unsigned long) NULL);
     5b9:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
     5c0:	00 00 
     5c2:	f0 41 80 64 24 01 ef 	lock andb $0xef,0x1(%r12)
			unlock_page(page);
     5c9:	4c 89 e7             	mov    %r12,%rdi
     5cc:	e8 00 00 00 00       	callq  5d1 <f2fs_write_end_io+0xb1>
			mempool_free(page, sbi->write_io_dummy);
     5d1:	48 8b b3 70 01 00 00 	mov    0x170(%rbx),%rsi
     5d8:	4c 89 e7             	mov    %r12,%rdi
     5db:	e8 00 00 00 00       	callq  5e0 <f2fs_write_end_io+0xc0>
			if (unlikely(bio->bi_status))
     5e0:	41 80 7f 1a 00       	cmpb   $0x0,0x1a(%r15)
     5e5:	74 a2                	je     589 <f2fs_write_end_io+0x69>
				f2fs_stop_checkpoint(sbi, true);
     5e7:	be 01 00 00 00       	mov    $0x1,%esi
     5ec:	48 89 df             	mov    %rbx,%rdi
     5ef:	e8 00 00 00 00       	callq  5f4 <f2fs_write_end_io+0xd4>
     5f4:	eb 93                	jmp    589 <f2fs_write_end_io+0x69>
     5f6:	8b 83 90 04 00 00    	mov    0x490(%rbx),%eax
	if (!get_pages(sbi, F2FS_WB_CP_DATA) &&
     5fc:	85 c0                	test   %eax,%eax
     5fe:	75 31                	jne    631 <f2fs_write_end_io+0x111>
	 * add_wait_queue modifications to the wait queue.
	 *
	 * This memory barrier should be paired with one on the
	 * waiting side.
	 */
	smp_mb();
     600:	f0 83 44 24 fc 00    	lock addl $0x0,-0x4(%rsp)
     606:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
	return !list_empty(&wq_head->head);
     60d:	48 8d bb 28 02 00 00 	lea    0x228(%rbx),%rdi
     614:	48 81 c3 30 02 00 00 	add    $0x230,%rbx
     61b:	48 39 c3             	cmp    %rax,%rbx
     61e:	74 11                	je     631 <f2fs_write_end_io+0x111>
		wake_up(&sbi->cp_wait);
     620:	31 c9                	xor    %ecx,%ecx
     622:	ba 01 00 00 00       	mov    $0x1,%edx
     627:	be 03 00 00 00       	mov    $0x3,%esi
     62c:	e8 00 00 00 00       	callq  631 <f2fs_write_end_io+0x111>
	bio_put(bio);
     631:	4c 89 ff             	mov    %r15,%rdi
     634:	e8 00 00 00 00       	callq  639 <f2fs_write_end_io+0x119>
}
     639:	48 83 c4 10          	add    $0x10,%rsp
     63d:	5b                   	pop    %rbx
     63e:	41 5c                	pop    %r12
     640:	41 5d                	pop    %r13
     642:	41 5e                	pop    %r14
     644:	41 5f                	pop    %r15
     646:	5d                   	pop    %rbp
     647:	c3                   	retq   
     648:	4c 89 e2             	mov    %r12,%rdx
     64b:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # 652 <f2fs_write_end_io+0x132>
}

static inline nid_t nid_of_node(struct page *node_page)
{
	struct f2fs_node *rn = F2FS_NODE(node_page);
	return le32_to_cpu(rn->footer.nid);
     652:	48 8b 0d 00 00 00 00 	mov    0x0(%rip),%rcx        # 659 <f2fs_write_end_io+0x139>
     659:	48 c1 fa 06          	sar    $0x6,%rdx
     65d:	48 c1 e2 0c          	shl    $0xc,%rdx
		f2fs_bug_on(sbi, page->mapping == NODE_MAPPING(sbi) &&
     661:	8b 94 0a e8 0f 00 00 	mov    0xfe8(%rdx,%rcx,1),%edx
     668:	49 39 54 24 20       	cmp    %rdx,0x20(%r12)
     66d:	0f 84 ff fe ff ff    	je     572 <f2fs_write_end_io+0x52>
     673:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
     675:	f0 80 4b 48 04       	lock orb $0x4,0x48(%rbx)
}
     67a:	e9 f3 fe ff ff       	jmpq   572 <f2fs_write_end_io+0x52>
 */
static inline void filemap_set_wb_err(struct address_space *mapping, int err)
{
	/* Fastpath for common case of no error */
	if (unlikely(err))
		__filemap_set_wb_err(mapping, err);
     67f:	48 89 d7             	mov    %rdx,%rdi
     682:	be fb ff ff ff       	mov    $0xfffffffb,%esi
     687:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
     68b:	89 45 cc             	mov    %eax,-0x34(%rbp)
     68e:	e8 00 00 00 00       	callq  693 <f2fs_write_end_io+0x173>
     693:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
     697:	f0 80 4a 78 01       	lock orb $0x1,0x78(%rdx)
			if (type == F2FS_WB_CP_DATA)
     69c:	8b 45 cc             	mov    -0x34(%rbp),%eax
     69f:	83 f8 07             	cmp    $0x7,%eax
     6a2:	74 0a                	je     6ae <f2fs_write_end_io+0x18e>
     6a4:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
     6a9:	e9 b6 fe ff ff       	jmpq   564 <f2fs_write_end_io+0x44>
				f2fs_stop_checkpoint(sbi, true);
     6ae:	be 01 00 00 00       	mov    $0x1,%esi
     6b3:	48 89 df             	mov    %rbx,%rdi
     6b6:	89 45 d0             	mov    %eax,-0x30(%rbp)
     6b9:	e8 00 00 00 00       	callq  6be <f2fs_write_end_io+0x19e>
     6be:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
     6c3:	8b 45 d0             	mov    -0x30(%rbp),%eax
     6c6:	e9 99 fe ff ff       	jmpq   564 <f2fs_write_end_io+0x44>
     6cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000006d0 <f2fs_write_end>:
}

static int f2fs_write_end(struct file *file,
						  struct address_space *mapping,
						  loff_t pos, unsigned len, unsigned copied,
						  struct page *page, void *fsdata) {
     6d0:	f3 0f 1e fa          	endbr64 
     6d4:	e8 00 00 00 00       	callq  6d9 <f2fs_write_end+0x9>
     6d9:	55                   	push   %rbp
     6da:	48 89 e5             	mov    %rsp,%rbp
     6dd:	41 57                	push   %r15
     6df:	45 89 c7             	mov    %r8d,%r15d
     6e2:	41 56                	push   %r14
     6e4:	41 55                	push   %r13
     6e6:	49 89 d5             	mov    %rdx,%r13
     6e9:	41 54                	push   %r12
     6eb:	4d 89 cc             	mov    %r9,%r12
     6ee:	53                   	push   %rbx
     6ef:	48 83 ec 08          	sub    $0x8,%rsp
	struct inode *inode = page->mapping->host;
     6f3:	49 8b 41 18          	mov    0x18(%r9),%rax
     6f7:	4c 8b 30             	mov    (%rax),%r14
     6fa:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     6ff:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
     704:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     708:	83 e2 01             	and    $0x1,%edx
     70b:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     70f:	48 8b 00             	mov    (%rax),%rax
	 * We can skip the barrier if the page is not uptodate, because
	 * we wouldn't be reading anything from it.
	 *
	 * See SetPageUptodate() for the other side of the story.
	 */
	if (ret)
     712:	a8 08                	test   $0x8,%al
     714:	0f 84 84 00 00 00    	je     79e <f2fs_write_end+0xce>
		if (unlikely(copied != len))
			copied = 0;
		else
			SetPageUptodate(page);
	}
	if (!copied)
     71a:	45 85 ff             	test   %r15d,%r15d
     71d:	0f 85 8f 00 00 00    	jne    7b2 <f2fs_write_end+0xe2>
     723:	45 31 ff             	xor    %r15d,%r15d
	if (!page)
     726:	4d 85 e4             	test   %r12,%r12
     729:	74 48                	je     773 <f2fs_write_end+0xa3>
     72b:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
		return (struct page *) (head - 1);
     730:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
     734:	83 e1 01             	and    $0x1,%ecx
     737:	49 0f 44 d4          	cmove  %r12,%rdx
     73b:	48 8b 02             	mov    (%rdx),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     73e:	a8 01                	test   $0x1,%al
     740:	0f 84 56 01 00 00    	je     89c <f2fs_write_end+0x1cc>
		unlock_page(page);
     746:	4c 89 e7             	mov    %r12,%rdi
     749:	e8 00 00 00 00       	callq  74e <f2fs_write_end+0x7e>
     74e:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
     753:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     757:	83 e2 01             	and    $0x1,%edx
     75a:	4c 0f 45 e0          	cmovne %rax,%r12
     75e:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
 * returns true if the result is 0, or false for all other
 * cases.
 */
static __always_inline bool arch_atomic_dec_and_test(atomic_t *v)
{
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     763:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
     769:	75 08                	jne    773 <f2fs_write_end+0xa3>
		__put_page(page);
     76b:	4c 89 e7             	mov    %r12,%rdi
     76e:	e8 00 00 00 00       	callq  773 <f2fs_write_end+0xa3>
	return sb->s_fs_info;
     773:	49 8b 46 28          	mov    0x28(%r14),%rax
	sbi->last_time[type] = jiffies;
     777:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 77e <f2fs_write_end+0xae>
	return sb->s_fs_info;
     77e:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
	sbi->last_time[type] = jiffies;
     785:	48 89 90 48 02 00 00 	mov    %rdx,0x248(%rax)
		f2fs_i_size_write(inode, pos + copied);
	unlock_out:
	f2fs_put_page(page, 1);
	f2fs_update_time(F2FS_I_SB(inode), REQ_TIME);
	return copied;
}
     78c:	48 83 c4 08          	add    $0x8,%rsp
     790:	44 89 f8             	mov    %r15d,%eax
     793:	5b                   	pop    %rbx
     794:	41 5c                	pop    %r12
     796:	41 5d                	pop    %r13
     798:	41 5e                	pop    %r14
     79a:	41 5f                	pop    %r15
     79c:	5d                   	pop    %rbp
     79d:	c3                   	retq   
		if (unlikely(copied != len))
     79e:	44 39 f9             	cmp    %r15d,%ecx
     7a1:	75 80                	jne    723 <f2fs_write_end+0x53>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     7a3:	f0 41 80 0c 24 08    	lock orb $0x8,(%r12)
	if (!copied)
     7a9:	45 85 ff             	test   %r15d,%r15d
     7ac:	0f 84 71 ff ff ff    	je     723 <f2fs_write_end+0x53>
	set_page_dirty(page);
     7b2:	4c 89 e7             	mov    %r12,%rdi
     7b5:	e8 00 00 00 00       	callq  7ba <f2fs_write_end+0xea>
	if (pos + copied > i_size_read(inode))
     7ba:	44 89 fa             	mov    %r15d,%edx
     7bd:	4c 01 ea             	add    %r13,%rdx
     7c0:	49 3b 56 50          	cmp    0x50(%r14),%rdx
     7c4:	0f 8e 5c ff ff ff    	jle    726 <f2fs_write_end+0x56>
	inode->i_size = i_size;
     7ca:	49 89 56 50          	mov    %rdx,0x50(%r14)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     7ce:	49 8b 9e 78 02 00 00 	mov    0x278(%r14),%rbx
	f2fs_mark_inode_dirty_sync(inode, true);
     7d5:	be 01 00 00 00       	mov    $0x1,%esi
     7da:	4c 89 f7             	mov    %r14,%rdi
     7dd:	4d 8b ae 78 02 00 00 	mov    0x278(%r14),%r13
     7e4:	e8 00 00 00 00       	callq  7e9 <f2fs_write_end+0x119>
	if (clean || recover)
     7e9:	83 e3 02             	and    $0x2,%ebx
     7ec:	74 0a                	je     7f8 <f2fs_write_end+0x128>
     7ee:	41 83 e5 04          	and    $0x4,%r13d
     7f2:	0f 84 2e ff ff ff    	je     726 <f2fs_write_end+0x56>
     7f8:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
     7ff:	a8 04                	test   $0x4,%al
     801:	0f 85 1f ff ff ff    	jne    726 <f2fs_write_end+0x56>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     807:	f0 41 80 8e 78 02 00 	lock orb $0x4,0x278(%r14)
     80e:	00 04 
     810:	e9 11 ff ff ff       	jmpq   726 <f2fs_write_end+0x56>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     815:	49 8b 14 24          	mov    (%r12),%rdx
     819:	48 c1 ea 33          	shr    $0x33,%rdx
     81d:	83 e2 07             	and    $0x7,%edx
	if (!is_zone_device_page(page))
     820:	83 fa 04             	cmp    $0x4,%edx
     823:	0f 85 3a ff ff ff    	jne    763 <f2fs_write_end+0x93>
	switch (page->pgmap->type) {
     829:	49 8b 44 24 08       	mov    0x8(%r12),%rax
     82e:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     834:	83 e8 01             	sub    $0x1,%eax
     837:	83 f8 02             	cmp    $0x2,%eax
     83a:	0f 87 23 ff ff ff    	ja     763 <f2fs_write_end+0x93>
		__put_devmap_managed_page(page);
     840:	4c 89 e7             	mov    %r12,%rdi
     843:	e8 00 00 00 00       	callq  848 <f2fs_write_end+0x178>
		return;
     848:	e9 26 ff ff ff       	jmpq   773 <f2fs_write_end+0xa3>
		(unsigned long long)__entry->pos,
		__entry->len,
		__entry->flags)
);

TRACE_EVENT(f2fs_write_end,
     84d:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 854 <f2fs_write_end+0x184>
     854:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
     856:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 85e <f2fs_write_end+0x18e>
     85d:	00 
     85e:	0f 83 9b fe ff ff    	jae    6ff <f2fs_write_end+0x2f>
     864:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 86b <f2fs_write_end+0x19b>
     86b:	48 85 db             	test   %rbx,%rbx
     86e:	74 27                	je     897 <f2fs_write_end+0x1c7>
     870:	48 8b 03             	mov    (%rbx),%rax
     873:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
     877:	48 83 c3 18          	add    $0x18,%rbx
     87b:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
     87e:	45 89 f8             	mov    %r15d,%r8d
     881:	4c 89 ea             	mov    %r13,%rdx
     884:	4c 89 f6             	mov    %r14,%rsi
     887:	e8 00 00 00 00       	callq  88c <f2fs_write_end+0x1bc>
     88c:	48 8b 03             	mov    (%rbx),%rax
     88f:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
     892:	48 85 c0             	test   %rax,%rax
     895:	75 dc                	jne    873 <f2fs_write_end+0x1a3>
}
     897:	e9 63 fe ff ff       	jmpq   6ff <f2fs_write_end+0x2f>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     89c:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     89e:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
     8a3:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     8a6:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     8aa:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     8b1:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
     8b6:	e9 8b fe ff ff       	jmpq   746 <f2fs_write_end+0x76>
     8bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000008c0 <f2fs_invalidate_page>:

	return err;
}

void f2fs_invalidate_page(struct page *page, unsigned int offset,
						  unsigned int length) {
     8c0:	f3 0f 1e fa          	endbr64 
     8c4:	e8 00 00 00 00       	callq  8c9 <f2fs_invalidate_page+0x9>
     8c9:	55                   	push   %rbp
     8ca:	48 89 e5             	mov    %rsp,%rbp
     8cd:	41 55                	push   %r13
     8cf:	41 54                	push   %r12
	struct inode *inode = page->mapping->host;
     8d1:	48 8b 47 18          	mov    0x18(%rdi),%rax
						  unsigned int length) {
     8d5:	49 89 fc             	mov    %rdi,%r12
	struct inode *inode = page->mapping->host;
     8d8:	4c 8b 28             	mov    (%rax),%r13
	return sb->s_fs_info;
     8db:	49 8b 7d 28          	mov    0x28(%r13),%rdi
	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);

	if (inode->i_ino >= F2FS_ROOT_INO(sbi) &&
     8df:	49 8b 4d 40          	mov    0x40(%r13),%rcx
     8e3:	48 8b 87 08 04 00 00 	mov    0x408(%rdi),%rax
     8ea:	44 8b 80 14 04 00 00 	mov    0x414(%rax),%r8d
     8f1:	4c 39 c1             	cmp    %r8,%rcx
     8f4:	72 16                	jb     90c <f2fs_invalidate_page+0x4c>
		(offset % PAGE_SIZE || length != PAGE_SIZE))
     8f6:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
     8fc:	75 08                	jne    906 <f2fs_invalidate_page+0x46>
     8fe:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
     904:	74 06                	je     90c <f2fs_invalidate_page+0x4c>
	if (IS_ATOMIC_WRITTEN_PAGE(page))
		return f2fs_drop_inmem_page(inode, page);

	set_page_private(page, 0);
	ClearPagePrivate(page);
}
     906:	41 5c                	pop    %r12
     908:	41 5d                	pop    %r13
     90a:	5d                   	pop    %rbp
     90b:	c3                   	retq   
     90c:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
     911:	48 8d 56 ff          	lea    -0x1(%rsi),%rdx
     915:	83 e6 01             	and    $0x1,%esi
     918:	49 0f 44 d4          	cmove  %r12,%rdx
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     91c:	48 8b 12             	mov    (%rdx),%rdx
	if (PageDirty(page)) {
     91f:	83 e2 10             	and    $0x10,%edx
     922:	0f 84 87 00 00 00    	je     9af <f2fs_invalidate_page+0xef>
		if (inode->i_ino == F2FS_META_INO(sbi)) {
     928:	8b 90 1c 04 00 00    	mov    0x41c(%rax),%edx
     92e:	48 39 d1             	cmp    %rdx,%rcx
     931:	0f 84 9f 00 00 00    	je     9d6 <f2fs_invalidate_page+0x116>
		} else if (inode->i_ino == F2FS_NODE_INO(sbi)) {
     937:	8b 90 18 04 00 00    	mov    0x418(%rax),%edx
     93d:	48 39 d1             	cmp    %rdx,%rcx
     940:	0f 84 87 00 00 00    	je     9cd <f2fs_invalidate_page+0x10d>
	if (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&
     946:	41 0f b7 45 00       	movzwl 0x0(%r13),%eax
     94b:	89 c2                	mov    %eax,%edx
     94d:	66 81 e2 00 d0       	and    $0xd000,%dx
     952:	66 81 fa 00 80       	cmp    $0x8000,%dx
     957:	74 0e                	je     967 <f2fs_invalidate_page+0xa7>
     959:	89 c2                	mov    %eax,%edx
     95b:	66 81 e2 00 f0       	and    $0xf000,%dx
     960:	66 81 fa 00 40       	cmp    $0x4000,%dx
     965:	75 40                	jne    9a7 <f2fs_invalidate_page+0xe7>
	asm volatile(LOCK_PREFIX "decl %0"
     967:	f0 41 ff 8d a8 02 00 	lock decl 0x2a8(%r13)
     96e:	00 
	dec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?
     96f:	66 25 00 f0          	and    $0xf000,%ax
	atomic_dec(&sbi->nr_pages[count_type]);
     973:	48 8b 97 08 04 00 00 	mov    0x408(%rdi),%rdx
	dec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?
     97a:	66 3d 00 40          	cmp    $0x4000,%ax
     97e:	0f 95 c0             	setne  %al
     981:	0f b6 c0             	movzbl %al,%eax
	atomic_dec(&sbi->nr_pages[count_type]);
     984:	48 05 1d 01 00 00    	add    $0x11d,%rax
     98a:	f0 ff 0c 82          	lock decl (%rdx,%rax,4)
	if (IS_NOQUOTA(inode))
     98e:	41 f6 45 0c 20       	testb  $0x20,0xc(%r13)
     993:	74 12                	je     9a7 <f2fs_invalidate_page+0xe7>
	return sb->s_fs_info;
     995:	49 8b 45 28          	mov    0x28(%r13),%rax
	atomic_dec(&sbi->nr_pages[count_type]);
     999:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
     9a0:	f0 ff 88 7c 04 00 00 	lock decl 0x47c(%rax)
			f2fs_remove_dirty_inode(inode);
     9a7:	4c 89 ef             	mov    %r13,%rdi
     9aa:	e8 00 00 00 00       	callq  9af <f2fs_invalidate_page+0xef>
	if (IS_ATOMIC_WRITTEN_PAGE(page))
     9af:	49 83 7c 24 28 ff    	cmpq   $0xffffffffffffffff,0x28(%r12)
     9b5:	74 28                	je     9df <f2fs_invalidate_page+0x11f>
	set_page_private(page, 0);
     9b7:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
     9be:	00 00 
		asm volatile(LOCK_PREFIX "andb %1,%0"
     9c0:	f0 41 80 64 24 01 ef 	lock andb $0xef,0x1(%r12)
}
     9c7:	41 5c                	pop    %r12
     9c9:	41 5d                	pop    %r13
     9cb:	5d                   	pop    %rbp
     9cc:	c3                   	retq   
     9cd:	f0 ff 88 80 04 00 00 	lock decl 0x480(%rax)
}
     9d4:	eb d9                	jmp    9af <f2fs_invalidate_page+0xef>
     9d6:	f0 ff 88 84 04 00 00 	lock decl 0x484(%rax)
     9dd:	eb d0                	jmp    9af <f2fs_invalidate_page+0xef>
		return f2fs_drop_inmem_page(inode, page);
     9df:	4c 89 e6             	mov    %r12,%rsi
     9e2:	4c 89 ef             	mov    %r13,%rdi
     9e5:	e8 00 00 00 00       	callq  9ea <f2fs_invalidate_page+0x12a>
     9ea:	e9 17 ff ff ff       	jmpq   906 <f2fs_invalidate_page+0x46>
     9ef:	90                   	nop

00000000000009f0 <f2fs_migrate_page>:
#ifdef CONFIG_MIGRATION

#include <linux/migrate.h>

int f2fs_migrate_page(struct address_space *mapping,
					  struct page *newpage, struct page *page, enum migrate_mode mode) {
     9f0:	f3 0f 1e fa          	endbr64 
     9f4:	e8 00 00 00 00       	callq  9f9 <f2fs_migrate_page+0x9>
     9f9:	55                   	push   %rbp
     9fa:	48 89 e5             	mov    %rsp,%rbp
     9fd:	41 57                	push   %r15
     9ff:	41 56                	push   %r14
     a01:	41 55                	push   %r13
     a03:	41 54                	push   %r12
     a05:	49 89 d4             	mov    %rdx,%r12
     a08:	53                   	push   %rbx
     a09:	89 cb                	mov    %ecx,%ebx
     a0b:	48 83 ec 08          	sub    $0x8,%rsp
	int rc, extra_count;
	struct f2fs_inode_info *fi = F2FS_I(mapping->host);
	bool atomic_written = IS_ATOMIC_WRITTEN_PAGE(page);
     a0f:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
     a13:	48 8b 52 08          	mov    0x8(%rdx),%rdx
     a17:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     a1b:	83 e2 01             	and    $0x1,%edx
     a1e:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     a22:	48 8b 00             	mov    (%rax),%rax

	BUG_ON(PageWriteback(page));
     a25:	f6 c4 40             	test   $0x40,%ah
     a28:	0f 85 6e 01 00 00    	jne    b9c <f2fs_migrate_page+0x1ac>
     a2e:	49 89 f7             	mov    %rsi,%r15

	/* migrating an atomic written page is safe with the inmem_lock hold */
	if (atomic_written) {
     a31:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
     a35:	75 68                	jne    a9f <f2fs_migrate_page+0xaf>
		if (mode != MIGRATE_SYNC)
     a37:	83 fb 02             	cmp    $0x2,%ebx
     a3a:	0f 85 8d 01 00 00    	jne    bcd <f2fs_migrate_page+0x1dd>
	struct f2fs_inode_info *fi = F2FS_I(mapping->host);
     a40:	4c 8b 2f             	mov    (%rdi),%r13
     a43:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
			return -EBUSY;
		if (!mutex_trylock(&fi->inmem_lock))
     a47:	4d 8d b5 40 03 00 00 	lea    0x340(%r13),%r14
     a4e:	4c 89 f7             	mov    %r14,%rdi
     a51:	e8 00 00 00 00       	callq  a56 <f2fs_migrate_page+0x66>
     a56:	4c 8b 55 d0          	mov    -0x30(%rbp),%r10
     a5a:	85 c0                	test   %eax,%eax
     a5c:	0f 84 75 01 00 00    	je     bd7 <f2fs_migrate_page+0x1e7>
	 * A reference is expected if PagePrivate set when move mapping,
	 * however F2FS breaks this for maintaining dirty page counts when
	 * truncating pages. So here adjusting the 'extra_count' make it work.
	 */
	extra_count = (atomic_written ? 1 : 0) - page_has_private(page);
	rc = migrate_page_move_mapping(mapping, newpage,
     a62:	45 31 c9             	xor    %r9d,%r9d
     a65:	41 b8 02 00 00 00    	mov    $0x2,%r8d
     a6b:	4c 89 e2             	mov    %r12,%rdx
     a6e:	4c 89 fe             	mov    %r15,%rsi
     a71:	49 f7 04 24 00 30 00 	testq  $0x3000,(%r12)
     a78:	00 
     a79:	4c 89 d7             	mov    %r10,%rdi
     a7c:	41 0f 94 c1          	sete   %r9b
     a80:	31 c9                	xor    %ecx,%ecx
     a82:	e8 00 00 00 00       	callq  a87 <f2fs_migrate_page+0x97>
								   page, NULL, mode, extra_count);
	if (rc != MIGRATEPAGE_SUCCESS) {
     a87:	85 c0                	test   %eax,%eax
     a89:	0f 84 96 00 00 00    	je     b25 <f2fs_migrate_page+0x135>
		if (atomic_written)
			mutex_unlock(&fi->inmem_lock);
     a8f:	4c 89 f7             	mov    %r14,%rdi
     a92:	89 45 d0             	mov    %eax,-0x30(%rbp)
     a95:	e8 00 00 00 00       	callq  a9a <f2fs_migrate_page+0xaa>
     a9a:	8b 45 d0             	mov    -0x30(%rbp),%eax
     a9d:	eb 47                	jmp    ae6 <f2fs_migrate_page+0xf6>
 * Determine if a page has private stuff, indicating that release routines
 * should be invoked upon it.
 */
static inline int page_has_private(struct page *page)
{
	return !!(page->flags & PAGE_FLAGS_PRIVATE);
     a9f:	45 31 c9             	xor    %r9d,%r9d
     aa2:	49 f7 04 24 00 30 00 	testq  $0x3000,(%r12)
     aa9:	00 
	rc = migrate_page_move_mapping(mapping, newpage,
     aaa:	41 89 d8             	mov    %ebx,%r8d
     aad:	4c 89 e2             	mov    %r12,%rdx
     ab0:	41 0f 95 c1          	setne  %r9b
     ab4:	31 c9                	xor    %ecx,%ecx
     ab6:	41 f7 d9             	neg    %r9d
     ab9:	e8 00 00 00 00       	callq  abe <f2fs_migrate_page+0xce>
	if (rc != MIGRATEPAGE_SUCCESS) {
     abe:	85 c0                	test   %eax,%eax
     ac0:	75 24                	jne    ae6 <f2fs_migrate_page+0xf6>
     ac2:	49 8b 04 24          	mov    (%r12),%rax
		mutex_unlock(&fi->inmem_lock);
		put_page(page);
		get_page(newpage);
	}

	if (PagePrivate(page))
     ac6:	f6 c4 10             	test   $0x10,%ah
     ac9:	75 2a                	jne    af5 <f2fs_migrate_page+0x105>
		SetPagePrivate(newpage);
	set_page_private(newpage, page_private(page));
     acb:	49 8b 44 24 28       	mov    0x28(%r12),%rax
     ad0:	49 89 47 28          	mov    %rax,0x28(%r15)

	if (mode != MIGRATE_SYNC_NO_COPY)
     ad4:	83 fb 03             	cmp    $0x3,%ebx
     ad7:	74 30                	je     b09 <f2fs_migrate_page+0x119>
		migrate_page_copy(newpage, page);
     ad9:	4c 89 e6             	mov    %r12,%rsi
     adc:	4c 89 ff             	mov    %r15,%rdi
     adf:	e8 00 00 00 00       	callq  ae4 <f2fs_migrate_page+0xf4>
	else
		migrate_page_states(newpage, page);

	return MIGRATEPAGE_SUCCESS;
     ae4:	31 c0                	xor    %eax,%eax
}
     ae6:	48 83 c4 08          	add    $0x8,%rsp
     aea:	5b                   	pop    %rbx
     aeb:	41 5c                	pop    %r12
     aed:	41 5d                	pop    %r13
     aef:	41 5e                	pop    %r14
     af1:	41 5f                	pop    %r15
     af3:	5d                   	pop    %rbp
     af4:	c3                   	retq   
		asm volatile(LOCK_PREFIX "orb %1,%0"
     af5:	f0 41 80 4f 01 10    	lock orb $0x10,0x1(%r15)
	set_page_private(newpage, page_private(page));
     afb:	49 8b 44 24 28       	mov    0x28(%r12),%rax
     b00:	49 89 47 28          	mov    %rax,0x28(%r15)
	if (mode != MIGRATE_SYNC_NO_COPY)
     b04:	83 fb 03             	cmp    $0x3,%ebx
     b07:	75 d0                	jne    ad9 <f2fs_migrate_page+0xe9>
		migrate_page_states(newpage, page);
     b09:	4c 89 e6             	mov    %r12,%rsi
     b0c:	4c 89 ff             	mov    %r15,%rdi
     b0f:	e8 00 00 00 00       	callq  b14 <f2fs_migrate_page+0x124>
	return MIGRATEPAGE_SUCCESS;
     b14:	31 c0                	xor    %eax,%eax
}
     b16:	48 83 c4 08          	add    $0x8,%rsp
     b1a:	5b                   	pop    %rbx
     b1b:	41 5c                	pop    %r12
     b1d:	41 5d                	pop    %r13
     b1f:	41 5e                	pop    %r14
     b21:	41 5f                	pop    %r15
     b23:	5d                   	pop    %rbp
     b24:	c3                   	retq   
		list_for_each_entry(cur, &fi->inmem_pages, list) if (cur->page == page) {
     b25:	49 8b 85 28 03 00 00 	mov    0x328(%r13),%rax
     b2c:	49 81 c5 28 03 00 00 	add    $0x328,%r13
     b33:	4c 39 e8             	cmp    %r13,%rax
     b36:	75 0a                	jne    b42 <f2fs_migrate_page+0x152>
     b38:	eb 12                	jmp    b4c <f2fs_migrate_page+0x15c>
     b3a:	48 8b 00             	mov    (%rax),%rax
     b3d:	4c 39 e8             	cmp    %r13,%rax
     b40:	74 0a                	je     b4c <f2fs_migrate_page+0x15c>
     b42:	4c 39 60 10          	cmp    %r12,0x10(%rax)
     b46:	75 f2                	jne    b3a <f2fs_migrate_page+0x14a>
				cur->page = newpage;
     b48:	4c 89 78 10          	mov    %r15,0x10(%rax)
		mutex_unlock(&fi->inmem_lock);
     b4c:	4c 89 f7             	mov    %r14,%rdi
     b4f:	e8 00 00 00 00       	callq  b54 <f2fs_migrate_page+0x164>
     b54:	49 8b 44 24 08       	mov    0x8(%r12),%rax
		return (struct page *) (head - 1);
     b59:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
     b5d:	a8 01                	test   $0x1,%al
     b5f:	49 0f 44 fc          	cmove  %r12,%rdi
     b63:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     b68:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
     b6c:	74 58                	je     bc6 <f2fs_migrate_page+0x1d6>
     b6e:	49 8b 57 08          	mov    0x8(%r15),%rdx
     b72:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     b76:	83 e2 01             	and    $0x1,%edx
     b79:	49 0f 44 c7          	cmove  %r15,%rax
	asm volatile(LOCK_PREFIX "incl %0"
     b7d:	f0 ff 40 34          	lock incl 0x34(%rax)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     b81:	49 8b 04 24          	mov    (%r12),%rax
	if (PagePrivate(page))
     b85:	f6 c4 10             	test   $0x10,%ah
     b88:	0f 85 67 ff ff ff    	jne    af5 <f2fs_migrate_page+0x105>
	set_page_private(newpage, page_private(page));
     b8e:	49 8b 44 24 28       	mov    0x28(%r12),%rax
     b93:	49 89 47 28          	mov    %rax,0x28(%r15)
	if (mode != MIGRATE_SYNC_NO_COPY)
     b97:	e9 3d ff ff ff       	jmpq   ad9 <f2fs_migrate_page+0xe9>
	BUG_ON(PageWriteback(page));
     b9c:	0f 0b                	ud2    
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     b9e:	48 8b 07             	mov    (%rdi),%rax
     ba1:	48 c1 e8 33          	shr    $0x33,%rax
     ba5:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     ba8:	83 f8 04             	cmp    $0x4,%eax
     bab:	75 bb                	jne    b68 <f2fs_migrate_page+0x178>
	switch (page->pgmap->type) {
     bad:	48 8b 47 08          	mov    0x8(%rdi),%rax
     bb1:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     bb7:	83 e8 01             	sub    $0x1,%eax
     bba:	83 f8 02             	cmp    $0x2,%eax
     bbd:	77 a9                	ja     b68 <f2fs_migrate_page+0x178>
		__put_devmap_managed_page(page);
     bbf:	e8 00 00 00 00       	callq  bc4 <f2fs_migrate_page+0x1d4>
		return;
     bc4:	eb a8                	jmp    b6e <f2fs_migrate_page+0x17e>
		__put_page(page);
     bc6:	e8 00 00 00 00       	callq  bcb <f2fs_migrate_page+0x1db>
     bcb:	eb a1                	jmp    b6e <f2fs_migrate_page+0x17e>
			return -EBUSY;
     bcd:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
     bd2:	e9 0f ff ff ff       	jmpq   ae6 <f2fs_migrate_page+0xf6>
			return -EAGAIN;
     bd7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
     bdc:	e9 05 ff ff ff       	jmpq   ae6 <f2fs_migrate_page+0xf6>
     be1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     be8:	00 00 00 00 
     bec:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000000bf0 <f2fs_set_data_page_dirty>:
static int f2fs_set_data_page_dirty(struct page *page) {
     bf0:	f3 0f 1e fa          	endbr64 
     bf4:	e8 00 00 00 00       	callq  bf9 <f2fs_set_data_page_dirty+0x9>
     bf9:	55                   	push   %rbp
     bfa:	48 89 e5             	mov    %rsp,%rbp
     bfd:	41 55                	push   %r13
     bff:	41 54                	push   %r12
     c01:	49 89 fc             	mov    %rdi,%r12
     c04:	53                   	push   %rbx
	struct inode *inode = mapping->host;
     c05:	48 8b 47 18          	mov    0x18(%rdi),%rax
     c09:	4c 8b 28             	mov    (%rax),%r13
     c0c:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     c11:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
     c16:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     c1a:	83 e2 01             	and    $0x1,%edx
     c1d:	49 0f 44 c4          	cmove  %r12,%rax
     c21:	48 8b 00             	mov    (%rax),%rax
	if (ret)
     c24:	a8 08                	test   $0x8,%al
     c26:	74 3b                	je     c63 <f2fs_set_data_page_dirty+0x73>
     c28:	49 8b 85 78 02 00 00 	mov    0x278(%r13),%rax
	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
     c2f:	f6 c4 80             	test   $0x80,%ah
     c32:	74 0e                	je     c42 <f2fs_set_data_page_dirty+0x52>
     c34:	49 8b 85 78 02 00 00 	mov    0x278(%r13),%rax
     c3b:	a9 00 00 01 00       	test   $0x10000,%eax
     c40:	74 29                	je     c6b <f2fs_set_data_page_dirty+0x7b>
     c42:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
     c47:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     c4b:	83 e2 01             	and    $0x1,%edx
     c4e:	49 0f 44 c4          	cmove  %r12,%rax
     c52:	48 8b 10             	mov    (%rax),%rdx
		return 0;
     c55:	31 c0                	xor    %eax,%eax
	if (!PageDirty(page)) {
     c57:	83 e2 10             	and    $0x10,%edx
     c5a:	74 75                	je     cd1 <f2fs_set_data_page_dirty+0xe1>
}
     c5c:	5b                   	pop    %rbx
     c5d:	41 5c                	pop    %r12
     c5f:	41 5d                	pop    %r13
     c61:	5d                   	pop    %rbp
     c62:	c3                   	retq   
		asm volatile(LOCK_PREFIX "orb %1,%0"
     c63:	f0 41 80 0c 24 08    	lock orb $0x8,(%r12)
}
     c69:	eb bd                	jmp    c28 <f2fs_set_data_page_dirty+0x38>
		return 0;
     c6b:	31 c0                	xor    %eax,%eax
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
     c6d:	49 83 7c 24 28 ff    	cmpq   $0xffffffffffffffff,0x28(%r12)
     c73:	74 e7                	je     c5c <f2fs_set_data_page_dirty+0x6c>
			f2fs_register_inmem_page(inode, page);
     c75:	4c 89 e6             	mov    %r12,%rsi
     c78:	4c 89 ef             	mov    %r13,%rdi
     c7b:	e8 00 00 00 00       	callq  c80 <f2fs_set_data_page_dirty+0x90>
			return 1;
     c80:	b8 01 00 00 00       	mov    $0x1,%eax
}
     c85:	5b                   	pop    %rbx
     c86:	41 5c                	pop    %r12
     c88:	41 5d                	pop    %r13
     c8a:	5d                   	pop    %rbp
     c8b:	c3                   	retq   
	TP_PROTO(struct page *page, int type),

	TP_ARGS(page, type)
);

DEFINE_EVENT(f2fs__page, f2fs_set_page_dirty,
     c8c:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # c93 <f2fs_set_data_page_dirty+0xa3>
     c93:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
     c95:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # c9d <f2fs_set_data_page_dirty+0xad>
     c9c:	00 
     c9d:	0f 83 6e ff ff ff    	jae    c11 <f2fs_set_data_page_dirty+0x21>
     ca3:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # caa <f2fs_set_data_page_dirty+0xba>
     caa:	48 85 db             	test   %rbx,%rbx
     cad:	74 1d                	je     ccc <f2fs_set_data_page_dirty+0xdc>
     caf:	48 8b 03             	mov    (%rbx),%rax
     cb2:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
     cb6:	48 83 c3 18          	add    $0x18,%rbx
     cba:	31 d2                	xor    %edx,%edx
     cbc:	4c 89 e6             	mov    %r12,%rsi
     cbf:	e8 00 00 00 00       	callq  cc4 <f2fs_set_data_page_dirty+0xd4>
     cc4:	48 8b 03             	mov    (%rbx),%rax
     cc7:	48 85 c0             	test   %rax,%rax
     cca:	75 e6                	jne    cb2 <f2fs_set_data_page_dirty+0xc2>
     ccc:	e9 40 ff ff ff       	jmpq   c11 <f2fs_set_data_page_dirty+0x21>
		__set_page_dirty_nobuffers(page);
     cd1:	4c 89 e7             	mov    %r12,%rdi
     cd4:	e8 00 00 00 00       	callq  cd9 <f2fs_set_data_page_dirty+0xe9>
		f2fs_update_dirty_page(inode, page);
     cd9:	4c 89 e6             	mov    %r12,%rsi
     cdc:	4c 89 ef             	mov    %r13,%rdi
     cdf:	e8 00 00 00 00       	callq  ce4 <f2fs_set_data_page_dirty+0xf4>
		return 1;
     ce4:	b8 01 00 00 00       	mov    $0x1,%eax
}
     ce9:	5b                   	pop    %rbx
     cea:	41 5c                	pop    %r12
     cec:	41 5d                	pop    %r13
     cee:	5d                   	pop    %rbp
     cef:	c3                   	retq   

0000000000000cf0 <__submit_merged_write_cond>:
									   enum page_type type, bool force) {
     cf0:	e8 00 00 00 00       	callq  cf5 <__submit_merged_write_cond+0x5>
     cf5:	55                   	push   %rbp
     cf6:	48 89 e5             	mov    %rsp,%rbp
     cf9:	41 57                	push   %r15
     cfb:	41 56                	push   %r14
     cfd:	41 55                	push   %r13
     cff:	41 bd 02 00 00 00    	mov    $0x2,%r13d
     d05:	41 54                	push   %r12
     d07:	49 89 fc             	mov    %rdi,%r12
     d0a:	53                   	push   %rbx
     d0b:	44 89 c3             	mov    %r8d,%ebx
     d0e:	48 83 ec 28          	sub    $0x28,%rsp
     d12:	83 fb 02             	cmp    $0x2,%ebx
     d15:	4c 0f 46 eb          	cmovbe %rbx,%r13
	if (!force && !has_merged_page(sbi, inode, ino, idx, type))
     d19:	45 84 c9             	test   %r9b,%r9b
     d1c:	0f 84 a7 00 00 00    	je     dc9 <__submit_merged_write_cond+0xd9>
	struct f2fs_bio_info *io = sbi->write_io[btype] + temp;
     d22:	49 8d 45 0e          	lea    0xe(%r13),%rax
			target = fscrypt_control_page(bvec->bv_page);
     d26:	45 31 ff             	xor    %r15d,%r15d
	struct f2fs_bio_info *io = sbi->write_io[btype] + temp;
     d29:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     d2d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     d31:	4d 8b 34 c4          	mov    (%r12,%rax,8),%r14
     d35:	4d 01 fe             	add    %r15,%r14
	down_write(&io->io_rwsem);
     d38:	4d 8d 6e 78          	lea    0x78(%r14),%r13
     d3c:	4c 89 ef             	mov    %r13,%rdi
     d3f:	e8 00 00 00 00       	callq  d44 <__submit_merged_write_cond+0x54>
	if (type >= META_FLUSH) {
     d44:	83 fb 03             	cmp    $0x3,%ebx
     d47:	76 48                	jbe    d91 <__submit_merged_write_cond+0xa1>
		io->fio.op = REQ_OP_WRITE;
     d49:	48 b8 01 00 00 00 00 	movabs $0x380000000001,%rax
     d50:	38 00 00 
		io->fio.type = META_FLUSH;
     d53:	41 c7 46 24 04 00 00 	movl   $0x4,0x24(%r14)
     d5a:	00 
		io->fio.op = REQ_OP_WRITE;
     d5b:	49 89 46 2c          	mov    %rax,0x2c(%r14)
		if (!test_opt(sbi, NOBARRIER))
     d5f:	41 f6 84 24 f1 04 00 	testb  $0x8,0x4f1(%r12)
     d66:	00 08 
     d68:	75 08                	jne    d72 <__submit_merged_write_cond+0x82>
			io->fio.op_flags |= REQ_PREFLUSH | REQ_FUA;
     d6a:	41 c7 46 30 00 38 06 	movl   $0x63800,0x30(%r14)
     d71:	00 
	__submit_merged_bio(io);
     d72:	4c 89 f7             	mov    %r14,%rdi
     d75:	e8 76 f3 ff ff       	callq  f0 <__submit_merged_bio>
	up_write(&io->io_rwsem);
     d7a:	4c 89 ef             	mov    %r13,%rdi
     d7d:	e8 00 00 00 00       	callq  d82 <__submit_merged_write_cond+0x92>
}
     d82:	48 83 c4 28          	add    $0x28,%rsp
     d86:	5b                   	pop    %rbx
     d87:	41 5c                	pop    %r12
     d89:	41 5d                	pop    %r13
     d8b:	41 5e                	pop    %r14
     d8d:	41 5f                	pop    %r15
     d8f:	5d                   	pop    %rbp
     d90:	c3                   	retq   
	__submit_merged_bio(io);
     d91:	4c 89 f7             	mov    %r14,%rdi
     d94:	e8 57 f3 ff ff       	callq  f0 <__submit_merged_bio>
	up_write(&io->io_rwsem);
     d99:	4c 89 ef             	mov    %r13,%rdi
     d9c:	e8 00 00 00 00       	callq  da1 <__submit_merged_write_cond+0xb1>
		if (type >= META)
     da1:	83 fb 01             	cmp    $0x1,%ebx
     da4:	77 dc                	ja     d82 <__submit_merged_write_cond+0x92>
	for (temp = HOT; temp < NR_TEMP_TYPE; temp++) {
     da6:	49 81 c7 b8 00 00 00 	add    $0xb8,%r15
     dad:	49 81 ff 28 02 00 00 	cmp    $0x228,%r15
     db4:	0f 85 73 ff ff ff    	jne    d2d <__submit_merged_write_cond+0x3d>
}
     dba:	48 83 c4 28          	add    $0x28,%rsp
     dbe:	5b                   	pop    %rbx
     dbf:	41 5c                	pop    %r12
     dc1:	41 5d                	pop    %r13
     dc3:	41 5e                	pop    %r14
     dc5:	41 5f                	pop    %r15
     dc7:	5d                   	pop    %rbp
     dc8:	c3                   	retq   
		io = sbi->write_io[btype] + temp;
     dc9:	49 8d 45 0e          	lea    0xe(%r13),%rax
     dcd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
     dd1:	49 89 cf             	mov    %rcx,%r15
     dd4:	45 31 f6             	xor    %r14d,%r14d
     dd7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
     ddb:	89 5d c4             	mov    %ebx,-0x3c(%rbp)
     dde:	89 d3                	mov    %edx,%ebx
     de0:	4c 89 6d b0          	mov    %r13,-0x50(%rbp)
     de4:	49 89 f5             	mov    %rsi,%r13
     de7:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
     deb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
     def:	48 8b 04 d6          	mov    (%rsi,%rdx,8),%rax
     df3:	4c 01 f0             	add    %r14,%rax
		down_read(&io->io_rwsem);
     df6:	4c 8d 60 78          	lea    0x78(%rax),%r12
     dfa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     dfe:	4c 89 e7             	mov    %r12,%rdi
     e01:	e8 00 00 00 00       	callq  e06 <__submit_merged_write_cond+0x116>
		ret = __has_merged_page(io, inode, ino, idx);
     e06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     e0a:	48 8b 40 08          	mov    0x8(%rax),%rax
	if (!io->bio)
     e0e:	48 85 c0             	test   %rax,%rax
     e11:	74 24                	je     e37 <__submit_merged_write_cond+0x147>
	if (!inode && !ino)
     e13:	4d 85 ed             	test   %r13,%r13
     e16:	75 50                	jne    e68 <__submit_merged_write_cond+0x178>
     e18:	85 db                	test   %ebx,%ebx
     e1a:	75 4c                	jne    e68 <__submit_merged_write_cond+0x178>
     e1c:	4d 89 e1             	mov    %r12,%r9
     e1f:	8b 5d c4             	mov    -0x3c(%rbp),%ebx
     e22:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
		up_read(&io->io_rwsem);
     e26:	4c 89 cf             	mov    %r9,%rdi
     e29:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
     e2d:	e8 00 00 00 00       	callq  e32 <__submit_merged_write_cond+0x142>
	return ret;
     e32:	e9 eb fe ff ff       	jmpq   d22 <__submit_merged_write_cond+0x32>
		up_read(&io->io_rwsem);
     e37:	4c 89 e7             	mov    %r12,%rdi
     e3a:	e8 00 00 00 00       	callq  e3f <__submit_merged_write_cond+0x14f>
		if (ret || btype == META)
     e3f:	83 7d c4 01          	cmpl   $0x1,-0x3c(%rbp)
     e43:	0f 87 39 ff ff ff    	ja     d82 <__submit_merged_write_cond+0x92>
	for (temp = HOT; temp < NR_TEMP_TYPE; temp++) {
     e49:	49 81 c6 b8 00 00 00 	add    $0xb8,%r14
     e50:	49 81 fe 28 02 00 00 	cmp    $0x228,%r14
     e57:	75 8e                	jne    de7 <__submit_merged_write_cond+0xf7>
}
     e59:	48 83 c4 28          	add    $0x28,%rsp
     e5d:	5b                   	pop    %rbx
     e5e:	41 5c                	pop    %r12
     e60:	41 5d                	pop    %r13
     e62:	41 5e                	pop    %r14
     e64:	41 5f                	pop    %r15
     e66:	5d                   	pop    %rbp
     e67:	c3                   	retq   
	bio_for_each_segment_all(bvec, io->bio, i) {
     e68:	48 8b 48 78          	mov    0x78(%rax),%rcx
     e6c:	0f b7 40 70          	movzwl 0x70(%rax),%eax
     e70:	66 85 c0             	test   %ax,%ax
     e73:	74 c2                	je     e37 <__submit_merged_write_cond+0x147>
     e75:	8d 78 ff             	lea    -0x1(%rax),%edi
	return page_to_virt(page);
     e78:	4c 8b 1d 00 00 00 00 	mov    0x0(%rip),%r11        # e7f <__submit_merged_write_cond+0x18f>
     e7f:	4c 8b 15 00 00 00 00 	mov    0x0(%rip),%r10        # e86 <__submit_merged_write_cond+0x196>
     e86:	48 83 c7 01          	add    $0x1,%rdi
     e8a:	48 c1 e7 04          	shl    $0x4,%rdi
     e8e:	48 01 cf             	add    %rcx,%rdi
     e91:	eb 42                	jmp    ed5 <__submit_merged_write_cond+0x1e5>
		if (idx != target->index)
     e93:	4c 3b 78 20          	cmp    0x20(%rax),%r15
     e97:	75 2f                	jne    ec8 <__submit_merged_write_cond+0x1d8>
		if (inode && inode == target->mapping->host)
     e99:	4d 85 ed             	test   %r13,%r13
     e9c:	74 0d                	je     eab <__submit_merged_write_cond+0x1bb>
     e9e:	48 8b 50 18          	mov    0x18(%rax),%rdx
     ea2:	4c 3b 2a             	cmp    (%rdx),%r13
     ea5:	0f 84 71 ff ff ff    	je     e1c <__submit_merged_write_cond+0x12c>
		if (ino && ino == ino_of_node(target))
     eab:	85 db                	test   %ebx,%ebx
     ead:	74 19                	je     ec8 <__submit_merged_write_cond+0x1d8>
     eaf:	4c 29 d8             	sub    %r11,%rax
     eb2:	48 c1 f8 06          	sar    $0x6,%rax
     eb6:	48 c1 e0 0c          	shl    $0xc,%rax
     eba:	42 3b 9c 10 ec 0f 00 	cmp    0xfec(%rax,%r10,1),%ebx
     ec1:	00 
     ec2:	0f 84 54 ff ff ff    	je     e1c <__submit_merged_write_cond+0x12c>
	bio_for_each_segment_all(bvec, io->bio, i) {
     ec8:	48 83 c1 10          	add    $0x10,%rcx
     ecc:	48 39 f9             	cmp    %rdi,%rcx
     ecf:	0f 84 62 ff ff ff    	je     e37 <__submit_merged_write_cond+0x147>
		if (bvec->bv_page->mapping)
     ed5:	48 8b 01             	mov    (%rcx),%rax
     ed8:	48 83 78 18 00       	cmpq   $0x0,0x18(%rax)
     edd:	75 b4                	jne    e93 <__submit_merged_write_cond+0x1a3>
	return -EOPNOTSUPP;
}

static inline struct page *fscrypt_control_page(struct page *page)
{
	WARN_ON_ONCE(1);
     edf:	0f 0b                	ud2    
			target = fscrypt_control_page(bvec->bv_page);
     ee1:	48 c7 c0 ea ff ff ff 	mov    $0xffffffffffffffea,%rax
     ee8:	eb a9                	jmp    e93 <__submit_merged_write_cond+0x1a3>
     eea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000ef0 <f2fs_release_page>:
int f2fs_release_page(struct page *page, gfp_t wait) {
     ef0:	f3 0f 1e fa          	endbr64 
     ef4:	e8 00 00 00 00       	callq  ef9 <f2fs_release_page+0x9>
     ef9:	48 8b 57 08          	mov    0x8(%rdi),%rdx
     efd:	55                   	push   %rbp
		return (struct page *) (head - 1);
     efe:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
     f02:	83 e2 01             	and    $0x1,%edx
     f05:	48 0f 44 c7          	cmove  %rdi,%rax
     f09:	48 89 e5             	mov    %rsp,%rbp
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     f0c:	48 8b 10             	mov    (%rax),%rdx
		return 0;
     f0f:	31 c0                	xor    %eax,%eax
	if (PageDirty(page))
     f11:	83 e2 10             	and    $0x10,%edx
     f14:	75 19                	jne    f2f <f2fs_release_page+0x3f>
	if (IS_ATOMIC_WRITTEN_PAGE(page))
     f16:	48 83 7f 28 ff       	cmpq   $0xffffffffffffffff,0x28(%rdi)
     f1b:	74 12                	je     f2f <f2fs_release_page+0x3f>
	set_page_private(page, 0);
     f1d:	48 c7 47 28 00 00 00 	movq   $0x0,0x28(%rdi)
     f24:	00 
		asm volatile(LOCK_PREFIX "andb %1,%0"
     f25:	f0 80 67 01 ef       	lock andb $0xef,0x1(%rdi)
     f2a:	b8 01 00 00 00       	mov    $0x1,%eax
}
     f2f:	5d                   	pop    %rbp
     f30:	c3                   	retq   
     f31:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     f38:	00 00 00 00 
     f3c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000000f40 <f2fs_read_end_io>:
static void f2fs_read_end_io(struct bio *bio) {
     f40:	f3 0f 1e fa          	endbr64 
     f44:	e8 00 00 00 00       	callq  f49 <f2fs_read_end_io+0x9>
     f49:	55                   	push   %rbp
	return bio->bi_private && !bio->bi_status;
     f4a:	80 7f 1a 00          	cmpb   $0x0,0x1a(%rdi)
	if (f2fs_bio_post_read_required(bio)) {
     f4e:	48 8b 47 50          	mov    0x50(%rdi),%rax
static void f2fs_read_end_io(struct bio *bio) {
     f52:	48 89 e5             	mov    %rsp,%rbp
	return bio->bi_private && !bio->bi_status;
     f55:	75 23                	jne    f7a <f2fs_read_end_io+0x3a>
     f57:	48 85 c0             	test   %rax,%rax
     f5a:	74 1e                	je     f7a <f2fs_read_end_io+0x3a>
	switch (++ctx->cur_step) {
     f5c:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%rax)
			if (ctx->enabled_steps & (1 << STEP_DECRYPT)) {
     f63:	f6 40 2c 02          	testb  $0x2,0x2c(%rax)
     f67:	75 18                	jne    f81 <f2fs_read_end_io+0x41>
			ctx->cur_step++;
     f69:	c7 40 28 02 00 00 00 	movl   $0x2,0x28(%rax)
			__read_end_io(ctx->bio);
     f70:	48 8b 38             	mov    (%rax),%rdi
     f73:	e8 18 f5 ff ff       	callq  490 <__read_end_io>
}
     f78:	5d                   	pop    %rbp
     f79:	c3                   	retq   
	__read_end_io(bio);
     f7a:	e8 11 f5 ff ff       	callq  490 <__read_end_io>
}
     f7f:	5d                   	pop    %rbp
     f80:	c3                   	retq   
				INIT_WORK(&ctx->work, decrypt_work);
     f81:	48 8d 50 10          	lea    0x10(%rax),%rdx
     f85:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
     f8c:	00 
     f8d:	48 b9 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rcx
     f94:	00 00 00 
     f97:	48 89 48 08          	mov    %rcx,0x8(%rax)
{
	switch (size) {
	case 1: *(volatile __u8 *)p = *(__u8 *)res; break;
	case 2: *(volatile __u16 *)p = *(__u16 *)res; break;
	case 4: *(volatile __u32 *)p = *(__u32 *)res; break;
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
     f9b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	WRITE_ONCE(list->next, list);
	list->prev = list;
     f9f:	48 89 50 18          	mov    %rdx,0x18(%rax)
}
     fa3:	5d                   	pop    %rbp
     fa4:	c3                   	retq   
     fa5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
     fac:	00 00 00 00 

0000000000000fb0 <f2fs_write_failed.isra.0>:
static void f2fs_write_failed(struct address_space *mapping, loff_t to) {
     fb0:	e8 00 00 00 00       	callq  fb5 <f2fs_write_failed.isra.0+0x5>
     fb5:	55                   	push   %rbp
     fb6:	48 89 e5             	mov    %rsp,%rbp
     fb9:	41 56                	push   %r14
     fbb:	41 55                	push   %r13
     fbd:	41 54                	push   %r12
	return inode->i_size;
     fbf:	4c 8b 6f 50          	mov    0x50(%rdi),%r13
	if (to > i_size) {
     fc3:	49 39 f5             	cmp    %rsi,%r13
     fc6:	7c 08                	jl     fd0 <f2fs_write_failed.isra.0+0x20>
}
     fc8:	41 5c                	pop    %r12
     fca:	41 5d                	pop    %r13
     fcc:	41 5e                	pop    %r14
     fce:	5d                   	pop    %rbp
     fcf:	c3                   	retq   
		down_write(&F2FS_I(inode)->i_mmap_sem);
     fd0:	4c 8d b7 b8 03 00 00 	lea    0x3b8(%rdi),%r14
     fd7:	49 89 fc             	mov    %rdi,%r12
     fda:	4c 89 f7             	mov    %r14,%rdi
     fdd:	e8 00 00 00 00       	callq  fe2 <f2fs_write_failed.isra.0+0x32>
		truncate_pagecache(inode, i_size);
     fe2:	4c 89 ee             	mov    %r13,%rsi
     fe5:	4c 89 e7             	mov    %r12,%rdi
     fe8:	e8 00 00 00 00       	callq  fed <f2fs_write_failed.isra.0+0x3d>
		f2fs_truncate_blocks(inode, i_size, true);
     fed:	4c 89 ee             	mov    %r13,%rsi
     ff0:	4c 89 e7             	mov    %r12,%rdi
     ff3:	ba 01 00 00 00       	mov    $0x1,%edx
     ff8:	e8 00 00 00 00       	callq  ffd <f2fs_write_failed.isra.0+0x4d>
		up_write(&F2FS_I(inode)->i_mmap_sem);
     ffd:	4c 89 f7             	mov    %r14,%rdi
    1000:	e8 00 00 00 00       	callq  1005 <f2fs_write_failed.isra.0+0x55>
}
    1005:	41 5c                	pop    %r12
    1007:	41 5d                	pop    %r13
    1009:	41 5e                	pop    %r14
    100b:	5d                   	pop    %rbp
    100c:	c3                   	retq   
    100d:	0f 1f 00             	nopl   (%rax)

0000000000001010 <f2fs_direct_IO>:
static ssize_t f2fs_direct_IO(struct kiocb *iocb, struct iov_iter *iter) {
    1010:	f3 0f 1e fa          	endbr64 
    1014:	e8 00 00 00 00       	callq  1019 <f2fs_direct_IO+0x9>
    1019:	55                   	push   %rbp
    101a:	48 89 e5             	mov    %rsp,%rbp
    101d:	41 57                	push   %r15
    101f:	41 56                	push   %r14
    1021:	41 55                	push   %r13
    1023:	49 89 f5             	mov    %rsi,%r13
    1026:	41 54                	push   %r12
    1028:	53                   	push   %rbx
    1029:	48 83 ec 38          	sub    $0x38,%rsp
	struct address_space *mapping = iocb->ki_filp->f_mapping;
    102d:	48 8b 07             	mov    (%rdi),%rax

const void *dup_iter(struct iov_iter *new, struct iov_iter *old, gfp_t flags);

static inline size_t iov_iter_count(const struct iov_iter *i)
{
	return i->count;
    1030:	48 8b 4e 10          	mov    0x10(%rsi),%rcx
	loff_t offset = iocb->ki_pos;
    1034:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
	struct address_space *mapping = iocb->ki_filp->f_mapping;
    1038:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
    103f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
	int rw = iov_iter_rw(iter);
    1043:	8b 0e                	mov    (%rsi),%ecx
	enum rw_hint hint = iocb->ki_hint;
    1045:	0f b7 77 24          	movzwl 0x24(%rdi),%esi
	struct inode *inode = mapping->host;
    1049:	4c 8b 38             	mov    (%rax),%r15
	struct address_space *mapping = iocb->ki_filp->f_mapping;
    104c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	int rw = iov_iter_rw(iter);
    1050:	89 4d c0             	mov    %ecx,-0x40(%rbp)
	return F2FS_SB(inode->i_sb);
    1053:	49 8b 47 28          	mov    0x28(%r15),%rax
	enum rw_hint hint = iocb->ki_hint;
    1057:	66 89 75 ba          	mov    %si,-0x46(%rbp)
	int whint_mode = F2FS_OPTION(sbi).whint_mode;
    105b:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
	unsigned blocksize_mask = inode->i_sb->s_blocksize - 1;
    1062:	48 8b 40 18          	mov    0x18(%rax),%rax
	if (offset & blocksize_mask)
    1066:	44 8d 70 ff          	lea    -0x1(%rax),%r14d
	int whint_mode = F2FS_OPTION(sbi).whint_mode;
    106a:	8b 8a 2c 05 00 00    	mov    0x52c(%rdx),%ecx
	if (offset & blocksize_mask)
    1070:	4c 89 f0             	mov    %r14,%rax
    1073:	48 21 d8             	and    %rbx,%rax
	int whint_mode = F2FS_OPTION(sbi).whint_mode;
    1076:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	if (offset & blocksize_mask)
    1079:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    107d:	0f 85 13 03 00 00    	jne    1396 <f2fs_direct_IO+0x386>
    1083:	49 89 fc             	mov    %rdi,%r12
	if (iov_iter_alignment(iter) & blocksize_mask)
    1086:	4c 89 ef             	mov    %r13,%rdi
    1089:	e8 00 00 00 00       	callq  108e <f2fs_direct_IO+0x7e>
    108e:	49 85 c6             	test   %rax,%r14
    1091:	0f 85 ff 02 00 00    	jne    1396 <f2fs_direct_IO+0x386>
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    1097:	41 f6 87 60 02 00 00 	testb  $0x4,0x260(%r15)
    109e:	04 
    109f:	0f 85 91 00 00 00    	jne    1136 <f2fs_direct_IO+0x126>
    10a5:	49 8b 47 28          	mov    0x28(%r15),%rax
#endif
}

static inline bool f2fs_force_buffered_io(struct inode *inode, int rw)
{
	return (f2fs_post_read_required(inode) ||
    10a9:	44 8b 75 c0          	mov    -0x40(%rbp),%r14d
    10ad:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    10b4:	41 83 e6 01          	and    $0x1,%r14d
    10b8:	0f 85 c6 02 00 00    	jne    1384 <f2fs_direct_IO+0x374>
			(rw == WRITE && test_opt(F2FS_I_SB(inode), LFS)) ||
    10be:	44 8b 90 e8 06 00 00 	mov    0x6e8(%rax),%r10d
    10c5:	45 85 d2             	test   %r10d,%r10d
    10c8:	75 7e                	jne    1148 <f2fs_direct_IO+0x138>
    10ca:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	if (rw == WRITE && whint_mode == WHINT_MODE_OFF)
    10cf:	44 8b 4d bc          	mov    -0x44(%rbp),%r9d
    10d3:	45 85 c9             	test   %r9d,%r9d
    10d6:	75 0f                	jne    10e7 <f2fs_direct_IO+0xd7>
    10d8:	f6 45 c0 01          	testb  $0x1,-0x40(%rbp)
    10dc:	74 09                	je     10e7 <f2fs_direct_IO+0xd7>
		iocb->ki_hint = WRITE_LIFE_NOT_SET;
    10de:	45 31 c0             	xor    %r8d,%r8d
    10e1:	66 45 89 44 24 24    	mov    %r8w,0x24(%r12)
	if (!down_read_trylock(&F2FS_I(inode)->i_gc_rwsem[rw])) {
    10e7:	49 63 d6             	movslq %r14d,%rdx
    10ea:	48 8d 04 95 00 00 00 	lea    0x0(,%rdx,4),%rax
    10f1:	00 
    10f2:	48 01 d0             	add    %rdx,%rax
    10f5:	4d 8d 9c c7 68 03 00 	lea    0x368(%r15,%rax,8),%r11
    10fc:	00 
    10fd:	4c 89 df             	mov    %r11,%rdi
    1100:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
    1104:	e8 00 00 00 00       	callq  1109 <f2fs_direct_IO+0xf9>
    1109:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
    110d:	85 c0                	test   %eax,%eax
    110f:	75 5a                	jne    116b <f2fs_direct_IO+0x15b>
		if (iocb->ki_flags & IOCB_NOWAIT) {
    1111:	41 f6 44 24 20 80    	testb  $0x80,0x20(%r12)
    1117:	74 42                	je     115b <f2fs_direct_IO+0x14b>
			iocb->ki_hint = hint;
    1119:	0f b7 45 ba          	movzwl -0x46(%rbp),%eax
			goto out;
    111d:	48 c7 45 d0 f5 ff ff 	movq   $0xfffffffffffffff5,-0x30(%rbp)
    1124:	ff 
			err = -EAGAIN;
    1125:	41 bd f5 ff ff ff    	mov    $0xfffffff5,%r13d
			iocb->ki_hint = hint;
    112b:	66 41 89 44 24 24    	mov    %ax,0x24(%r12)
			goto out;
    1131:	e9 d5 01 00 00       	jmpq   130b <f2fs_direct_IO+0x2fb>
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    1136:	41 0f b7 07          	movzwl (%r15),%eax
    113a:	66 25 00 f0          	and    $0xf000,%ax
    113e:	66 3d 00 80          	cmp    $0x8000,%ax
    1142:	0f 85 5d ff ff ff    	jne    10a5 <f2fs_direct_IO+0x95>
}
    1148:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    114c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    1150:	5b                   	pop    %rbx
    1151:	41 5c                	pop    %r12
    1153:	41 5d                	pop    %r13
    1155:	41 5e                	pop    %r14
    1157:	41 5f                	pop    %r15
    1159:	5d                   	pop    %rbp
    115a:	c3                   	retq   
		down_read(&F2FS_I(inode)->i_gc_rwsem[rw]);
    115b:	4c 89 df             	mov    %r11,%rdi
    115e:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
    1162:	e8 00 00 00 00       	callq  1167 <f2fs_direct_IO+0x157>
    1167:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
	if (rw) {
    116b:	45 85 f6             	test   %r14d,%r14d
    116e:	0f 84 51 01 00 00    	je     12c5 <f2fs_direct_IO+0x2b5>
    1174:	4c 89 5d a8          	mov    %r11,-0x58(%rbp)
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1178:	f0 41 80 4f 02 80    	lock orb $0x80,0x2(%r15)
static inline ssize_t blockdev_direct_IO(struct kiocb *iocb,
					 struct inode *inode,
					 struct iov_iter *iter,
					 get_block_t get_block)
{
	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
    117e:	49 8b 47 28          	mov    0x28(%r15),%rax
    1182:	4c 89 e9             	mov    %r13,%rcx
    1185:	45 31 c9             	xor    %r9d,%r9d
    1188:	4c 89 fe             	mov    %r15,%rsi
    118b:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    1192:	4c 89 e7             	mov    %r12,%rdi
    1195:	48 8b 90 d0 00 00 00 	mov    0xd0(%rax),%rdx
    119c:	6a 03                	pushq  $0x3
    119e:	6a 00                	pushq  $0x0
    11a0:	e8 00 00 00 00       	callq  11a5 <f2fs_direct_IO+0x195>
	up_read(&F2FS_I(inode)->i_gc_rwsem[rw]);
    11a5:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
	err = blockdev_direct_IO(iocb, inode, iter, get_data_block_dio);
    11a9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    11ad:	41 89 c5             	mov    %eax,%r13d
	up_read(&F2FS_I(inode)->i_gc_rwsem[rw]);
    11b0:	4c 89 df             	mov    %r11,%rdi
    11b3:	e8 00 00 00 00       	callq  11b8 <f2fs_direct_IO+0x1a8>
		if (whint_mode == WHINT_MODE_OFF)
    11b8:	8b 7d bc             	mov    -0x44(%rbp),%edi
    11bb:	59                   	pop    %rcx
    11bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    11c0:	5e                   	pop    %rsi
    11c1:	85 ff                	test   %edi,%edi
    11c3:	75 0a                	jne    11cf <f2fs_direct_IO+0x1bf>
			iocb->ki_hint = hint;
    11c5:	0f b7 75 ba          	movzwl -0x46(%rbp),%esi
    11c9:	66 41 89 74 24 24    	mov    %si,0x24(%r12)
		if (err > 0) {
    11cf:	48 63 d0             	movslq %eax,%rdx
    11d2:	85 c0                	test   %eax,%eax
    11d4:	0f 8e 8e 01 00 00    	jle    1368 <f2fs_direct_IO+0x358>
	return sb->s_fs_info;
    11da:	49 8b 47 28          	mov    0x28(%r15),%rax
    11de:	4c 8b a0 08 04 00 00 	mov    0x408(%rax),%r12
	if (!sbi->iostat_enable)
    11e5:	41 80 bc 24 70 06 00 	cmpb   $0x0,0x670(%r12)
    11ec:	00 00 
    11ee:	74 4a                	je     123a <f2fs_direct_IO+0x22a>
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
    11f0:	49 8d bc 24 04 06 00 	lea    0x604(%r12),%rdi
    11f7:	00 
    11f8:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    11fc:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    1200:	e8 00 00 00 00       	callq  1205 <f2fs_direct_IO+0x1f5>
	sbi->write_iostat[type] += io_bytes;
    1205:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
	PVOP_VCALL2(pv_lock_ops.queued_spin_lock_slowpath, lock, val);
}

static __always_inline void pv_queued_spin_unlock(struct qspinlock *lock)
{
	PVOP_VCALLEE1(pv_lock_ops.queued_spin_unlock, lock);
    1209:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    120d:	49 8b 84 24 08 06 00 	mov    0x608(%r12),%rax
    1214:	00 
			sbi->write_iostat[APP_WRITE_IO] -
    1215:	49 8b b4 24 18 06 00 	mov    0x618(%r12),%rsi
    121c:	00 
	sbi->write_iostat[type] += io_bytes;
    121d:	48 01 d0             	add    %rdx,%rax
			sbi->write_iostat[APP_WRITE_IO] -
    1220:	48 29 c6             	sub    %rax,%rsi
	sbi->write_iostat[type] += io_bytes;
    1223:	49 89 84 24 08 06 00 	mov    %rax,0x608(%r12)
    122a:	00 
		sbi->write_iostat[APP_BUFFERED_IO] =
    122b:	49 89 b4 24 10 06 00 	mov    %rsi,0x610(%r12)
    1232:	00 
    1233:	ff 14 25 00 00 00 00 	callq  *0x0
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    123a:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
    1241:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    1245:	f6 c4 20             	test   $0x20,%ah
    1248:	0f 85 bd 00 00 00    	jne    130b <f2fs_direct_IO+0x2fb>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    124e:	f0 41 80 8f 79 02 00 	lock orb $0x20,0x279(%r15)
    1255:	00 20 
    1257:	e9 af 00 00 00       	jmpq   130b <f2fs_direct_IO+0x2fb>
TRACE_EVENT(f2fs_direct_IO_enter,
    125c:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 1263 <f2fs_direct_IO+0x253>
    1263:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    1265:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 126d <f2fs_direct_IO+0x25d>
    126c:	00 
    126d:	0f 83 5c fe ff ff    	jae    10cf <f2fs_direct_IO+0xbf>
	__READ_ONCE_SIZE;
    1273:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 127a <f2fs_direct_IO+0x26a>
    127a:	48 85 c0             	test   %rax,%rax
    127d:	74 41                	je     12c0 <f2fs_direct_IO+0x2b0>
    127f:	4c 89 65 a8          	mov    %r12,-0x58(%rbp)
    1283:	4c 8b 08             	mov    (%rax),%r9
    1286:	4c 8b 65 c8          	mov    -0x38(%rbp),%r12
    128a:	4c 89 6d a0          	mov    %r13,-0x60(%rbp)
    128e:	45 89 f5             	mov    %r14d,%r13d
    1291:	49 89 c6             	mov    %rax,%r14
    1294:	49 8b 7e 08          	mov    0x8(%r14),%rdi
    1298:	49 83 c6 18          	add    $0x18,%r14
    129c:	45 89 e8             	mov    %r13d,%r8d
    129f:	4c 89 e1             	mov    %r12,%rcx
    12a2:	48 89 da             	mov    %rbx,%rdx
    12a5:	4c 89 fe             	mov    %r15,%rsi
    12a8:	e8 00 00 00 00       	callq  12ad <f2fs_direct_IO+0x29d>
    12ad:	4d 8b 0e             	mov    (%r14),%r9
    12b0:	4d 85 c9             	test   %r9,%r9
    12b3:	75 df                	jne    1294 <f2fs_direct_IO+0x284>
    12b5:	45 89 ee             	mov    %r13d,%r14d
    12b8:	4c 8b 65 a8          	mov    -0x58(%rbp),%r12
    12bc:	4c 8b 6d a0          	mov    -0x60(%rbp),%r13
    12c0:	e9 0a fe ff ff       	jmpq   10cf <f2fs_direct_IO+0xbf>
    12c5:	49 8b 47 28          	mov    0x28(%r15),%rax
    12c9:	4c 89 5d d0          	mov    %r11,-0x30(%rbp)
    12cd:	4c 89 e9             	mov    %r13,%rcx
    12d0:	4c 89 e7             	mov    %r12,%rdi
    12d3:	45 31 c9             	xor    %r9d,%r9d
    12d6:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    12dd:	4c 89 fe             	mov    %r15,%rsi
    12e0:	48 8b 90 d0 00 00 00 	mov    0xd0(%rax),%rdx
    12e7:	6a 03                	pushq  $0x3
    12e9:	6a 00                	pushq  $0x0
    12eb:	e8 00 00 00 00       	callq  12f0 <f2fs_direct_IO+0x2e0>
	up_read(&F2FS_I(inode)->i_gc_rwsem[rw]);
    12f0:	4c 8b 5d d0          	mov    -0x30(%rbp),%r11
    12f4:	49 89 c4             	mov    %rax,%r12
	err = blockdev_direct_IO(iocb, inode, iter, get_data_block_dio);
    12f7:	41 89 c5             	mov    %eax,%r13d
	up_read(&F2FS_I(inode)->i_gc_rwsem[rw]);
    12fa:	4c 89 df             	mov    %r11,%rdi
    12fd:	e8 00 00 00 00       	callq  1302 <f2fs_direct_IO+0x2f2>
	if (rw == WRITE) {
    1302:	49 63 c4             	movslq %r12d,%rax
    1305:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1309:	58                   	pop    %rax
    130a:	5a                   	pop    %rdx
    130b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		_ASM_ALIGN "\n\t"
		_ASM_PTR "1b, %l[l_yes], %c0 + %c1 \n\t"
		".popsection \n\t"
		: :  "i" (key), "i" (branch) : : l_yes);

	return false;
    1310:	e9 33 fe ff ff       	jmpq   1148 <f2fs_direct_IO+0x138>
TRACE_EVENT(f2fs_direct_IO_exit,
    1315:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 131c <f2fs_direct_IO+0x30c>
    131c:	89 c0                	mov    %eax,%eax
    131e:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 1326 <f2fs_direct_IO+0x316>
    1325:	00 
    1326:	0f 83 1c fe ff ff    	jae    1148 <f2fs_direct_IO+0x138>
    132c:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 1333 <f2fs_direct_IO+0x323>
    1333:	4d 85 e4             	test   %r12,%r12
    1336:	74 2b                	je     1363 <f2fs_direct_IO+0x353>
    1338:	49 8b 04 24          	mov    (%r12),%rax
    133c:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    1341:	49 83 c4 18          	add    $0x18,%r12
    1345:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    1349:	45 89 e9             	mov    %r13d,%r9d
    134c:	45 89 f0             	mov    %r14d,%r8d
    134f:	48 89 da             	mov    %rbx,%rdx
    1352:	4c 89 fe             	mov    %r15,%rsi
    1355:	e8 00 00 00 00       	callq  135a <f2fs_direct_IO+0x34a>
    135a:	49 8b 04 24          	mov    (%r12),%rax
    135e:	48 85 c0             	test   %rax,%rax
    1361:	75 d9                	jne    133c <f2fs_direct_IO+0x32c>
    1363:	e9 e0 fd ff ff       	jmpq   1148 <f2fs_direct_IO+0x138>
		} else if (err < 0) {
    1368:	74 a1                	je     130b <f2fs_direct_IO+0x2fb>
			f2fs_write_failed(mapping, offset + count);
    136a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    136e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    1372:	48 8d 34 03          	lea    (%rbx,%rax,1),%rsi
    1376:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    137a:	48 8b 38             	mov    (%rax),%rdi
    137d:	e8 2e fc ff ff       	callq  fb0 <f2fs_write_failed.isra.0>
    1382:	eb 87                	jmp    130b <f2fs_direct_IO+0x2fb>
			(rw == WRITE && test_opt(F2FS_I_SB(inode), LFS)) ||
    1384:	f6 80 f2 04 00 00 04 	testb  $0x4,0x4f2(%rax)
    138b:	0f 85 b7 fd ff ff    	jne    1148 <f2fs_direct_IO+0x138>
    1391:	e9 28 fd ff ff       	jmpq   10be <f2fs_direct_IO+0xae>
		return err;
    1396:	48 c7 45 d0 ea ff ff 	movq   $0xffffffffffffffea,-0x30(%rbp)
    139d:	ff 
    139e:	e9 a5 fd ff ff       	jmpq   1148 <f2fs_direct_IO+0x138>
    13a3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    13aa:	00 00 00 00 
    13ae:	66 90                	xchg   %ax,%ax

00000000000013b0 <f2fs_bmap>:
static sector_t f2fs_bmap(struct address_space *mapping, sector_t block) {
    13b0:	f3 0f 1e fa          	endbr64 
    13b4:	e8 00 00 00 00       	callq  13b9 <f2fs_bmap+0x9>
	struct inode *inode = mapping->host;
    13b9:	48 8b 07             	mov    (%rdi),%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    13bc:	48 8b 90 78 02 00 00 	mov    0x278(%rax),%rdx
	if (f2fs_has_inline_data(inode))
    13c3:	80 e6 04             	and    $0x4,%dh
    13c6:	74 03                	je     13cb <f2fs_bmap+0x1b>
    13c8:	31 c0                	xor    %eax,%eax
}
    13ca:	c3                   	retq   
static sector_t f2fs_bmap(struct address_space *mapping, sector_t block) {
    13cb:	55                   	push   %rbp
    13cc:	48 89 e5             	mov    %rsp,%rbp
    13cf:	41 55                	push   %r13
    13d1:	49 89 f5             	mov    %rsi,%r13
	if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
    13d4:	31 f6                	xor    %esi,%esi
static sector_t f2fs_bmap(struct address_space *mapping, sector_t block) {
    13d6:	41 54                	push   %r12
    13d8:	49 89 fc             	mov    %rdi,%r12
	if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
    13db:	e8 00 00 00 00       	callq  13e0 <f2fs_bmap+0x30>
    13e0:	85 c0                	test   %eax,%eax
    13e2:	75 18                	jne    13fc <f2fs_bmap+0x4c>
	return generic_block_bmap(mapping, block, get_data_block_bmap);
    13e4:	4c 89 ee             	mov    %r13,%rsi
    13e7:	4c 89 e7             	mov    %r12,%rdi
    13ea:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    13f1:	e8 00 00 00 00       	callq  13f6 <f2fs_bmap+0x46>
}
    13f6:	41 5c                	pop    %r12
    13f8:	41 5d                	pop    %r13
    13fa:	5d                   	pop    %rbp
    13fb:	c3                   	retq   
		filemap_write_and_wait(mapping);
    13fc:	4c 89 e7             	mov    %r12,%rdi
    13ff:	e8 00 00 00 00       	callq  1404 <f2fs_bmap+0x54>
    1404:	eb de                	jmp    13e4 <f2fs_bmap+0x34>
    1406:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    140d:	00 00 00 

0000000000001410 <__same_bdev.isra.0>:
static bool __same_bdev(struct f2fs_sb_info *sbi,
    1410:	e8 00 00 00 00       	callq  1415 <__same_bdev.isra.0+0x5>
    1415:	55                   	push   %rbp
	struct block_device *bdev = sbi->sb->s_bdev;
    1416:	48 8b 07             	mov    (%rdi),%rax
	for (i = 0; i < sbi->s_ndevs; i++) {
    1419:	44 8b 87 e8 06 00 00 	mov    0x6e8(%rdi),%r8d
	struct block_device *bdev = sbi->sb->s_bdev;
    1420:	4c 8b 88 d0 00 00 00 	mov    0xd0(%rax),%r9
static bool __same_bdev(struct f2fs_sb_info *sbi,
    1427:	48 89 e5             	mov    %rsp,%rbp
	for (i = 0; i < sbi->s_ndevs; i++) {
    142a:	45 85 c0             	test   %r8d,%r8d
    142d:	7e 2b                	jle    145a <__same_bdev.isra.0+0x4a>
    142f:	48 8b 87 f0 06 00 00 	mov    0x6f0(%rdi),%rax
    1436:	41 8d 78 ff          	lea    -0x1(%r8),%edi
    143a:	48 8d 3c 7f          	lea    (%rdi,%rdi,2),%rdi
    143e:	48 c1 e7 05          	shl    $0x5,%rdi
    1442:	48 8d 7c 38 60       	lea    0x60(%rax,%rdi,1),%rdi
		if (FDEV(i).start_blk <= blk_addr &&
    1447:	39 70 4c             	cmp    %esi,0x4c(%rax)
    144a:	77 05                	ja     1451 <__same_bdev.isra.0+0x41>
    144c:	3b 70 50             	cmp    0x50(%rax),%esi
    144f:	76 25                	jbe    1476 <__same_bdev.isra.0+0x66>
	for (i = 0; i < sbi->s_ndevs; i++) {
    1451:	48 83 c0 60          	add    $0x60,%rax
    1455:	48 39 f8             	cmp    %rdi,%rax
    1458:	75 ed                	jne    1447 <__same_bdev.isra.0+0x37>
	return bio->bi_disk == b->bd_disk && bio->bi_partno == b->bd_partno;
    145a:	49 8b b1 80 00 00 00 	mov    0x80(%r9),%rsi
    1461:	31 c0                	xor    %eax,%eax
    1463:	48 39 32             	cmp    %rsi,(%rdx)
    1466:	74 02                	je     146a <__same_bdev.isra.0+0x5a>
}
    1468:	5d                   	pop    %rbp
    1469:	c3                   	retq   
	return bio->bi_disk == b->bd_disk && bio->bi_partno == b->bd_partno;
    146a:	41 0f b6 41 6c       	movzbl 0x6c(%r9),%eax
    146f:	38 01                	cmp    %al,(%rcx)
    1471:	0f 94 c0             	sete   %al
}
    1474:	5d                   	pop    %rbp
    1475:	c3                   	retq   
			bdev = FDEV(i).bdev;
    1476:	4c 8b 08             	mov    (%rax),%r9
	return bio->bi_disk == b->bd_disk && bio->bi_partno == b->bd_partno;
    1479:	31 c0                	xor    %eax,%eax
    147b:	49 8b b1 80 00 00 00 	mov    0x80(%r9),%rsi
    1482:	48 39 32             	cmp    %rsi,(%rdx)
    1485:	75 e1                	jne    1468 <__same_bdev.isra.0+0x58>
    1487:	eb e1                	jmp    146a <__same_bdev.isra.0+0x5a>
    1489:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000001490 <encrypt_one_page>:
static int encrypt_one_page(struct f2fs_io_info *fio) {
    1490:	e8 00 00 00 00       	callq  1495 <encrypt_one_page+0x5>
	struct inode *inode = fio->page->mapping->host;
    1495:	48 8b 47 28          	mov    0x28(%rdi),%rax
		return 0;
    1499:	45 31 c0             	xor    %r8d,%r8d
	struct inode *inode = fio->page->mapping->host;
    149c:	48 8b 40 18          	mov    0x18(%rax),%rax
    14a0:	48 8b 00             	mov    (%rax),%rax
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    14a3:	f6 80 60 02 00 00 04 	testb  $0x4,0x260(%rax)
    14aa:	74 0d                	je     14b9 <encrypt_one_page+0x29>
    14ac:	0f b7 00             	movzwl (%rax),%eax
    14af:	66 25 00 f0          	and    $0xf000,%ax
    14b3:	66 3d 00 80          	cmp    $0x8000,%ax
    14b7:	74 04                	je     14bd <encrypt_one_page+0x2d>
}
    14b9:	44 89 c0             	mov    %r8d,%eax
    14bc:	c3                   	retq   
static int encrypt_one_page(struct f2fs_io_info *fio) {
    14bd:	55                   	push   %rbp
    14be:	48 89 e5             	mov    %rsp,%rbp
    14c1:	53                   	push   %rbx
    14c2:	48 89 fb             	mov    %rdi,%rbx
	f2fs_wait_on_block_writeback(fio->sbi, fio->old_blkaddr);
    14c5:	8b 77 20             	mov    0x20(%rdi),%esi
    14c8:	48 8b 3f             	mov    (%rdi),%rdi
    14cb:	e8 00 00 00 00       	callq  14d0 <encrypt_one_page+0x40>
	fio->encrypted_page = fscrypt_encrypt_page(inode, fio->page,
    14d0:	41 b8 a1 ff ff ff    	mov    $0xffffffa1,%r8d
    14d6:	48 c7 43 30 a1 ff ff 	movq   $0xffffffffffffffa1,0x30(%rbx)
    14dd:	ff 
}
    14de:	5b                   	pop    %rbx
    14df:	44 89 c0             	mov    %r8d,%eax
    14e2:	5d                   	pop    %rbp
    14e3:	c3                   	retq   
    14e4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    14eb:	00 00 00 00 
    14ef:	90                   	nop

00000000000014f0 <f2fs_should_update_inplace.part.0>:
bool f2fs_should_update_inplace(struct inode *inode, struct f2fs_io_info *fio) {
    14f0:	e8 00 00 00 00       	callq  14f5 <f2fs_should_update_inplace.part.0+0x5>
    14f5:	55                   	push   %rbp
    14f6:	48 89 e5             	mov    %rsp,%rbp
    14f9:	41 56                	push   %r14
    14fb:	41 55                	push   %r13
    14fd:	41 54                	push   %r12
    14ff:	53                   	push   %rbx
	return sb->s_fs_info;
    1500:	48 8b 47 28          	mov    0x28(%rdi),%rax
    1504:	4c 8b a8 08 04 00 00 	mov    0x408(%rax),%r13
	unsigned int policy = SM_I(sbi)->ipu_policy;
    150b:	49 8b 45 68          	mov    0x68(%r13),%rax
    150f:	8b 98 80 00 00 00    	mov    0x80(%rax),%ebx
	if (policy & (0x1 << F2FS_IPU_FORCE))
    1515:	f6 c3 01             	test   $0x1,%bl
    1518:	0f 85 8f 00 00 00    	jne    15ad <f2fs_should_update_inplace.part.0+0xbd>
    151e:	49 89 fc             	mov    %rdi,%r12
    1521:	49 89 f6             	mov    %rsi,%r14
	if (policy & (0x1 << F2FS_IPU_SSR) && f2fs_need_SSR(sbi))
    1524:	f6 c3 02             	test   $0x2,%bl
    1527:	0f 85 bf 00 00 00    	jne    15ec <f2fs_should_update_inplace.part.0+0xfc>
	if (policy & (0x1 << F2FS_IPU_UTIL) &&
    152d:	f6 c3 04             	test   $0x4,%bl
    1530:	0f 85 85 00 00 00    	jne    15bb <f2fs_should_update_inplace.part.0+0xcb>
	if (policy & (0x1 << F2FS_IPU_SSR_UTIL) && f2fs_need_SSR(sbi) &&
    1536:	f6 c3 08             	test   $0x8,%bl
    1539:	75 3b                	jne    1576 <f2fs_should_update_inplace.part.0+0x86>
	if (policy & (0x1 << F2FS_IPU_ASYNC) &&
    153b:	f6 c3 20             	test   $0x20,%bl
    153e:	74 17                	je     1557 <f2fs_should_update_inplace.part.0+0x67>
    1540:	4d 85 f6             	test   %r14,%r14
    1543:	74 12                	je     1557 <f2fs_should_update_inplace.part.0+0x67>
		fio && fio->op == REQ_OP_WRITE &&
    1545:	41 83 7e 14 01       	cmpl   $0x1,0x14(%r14)
    154a:	75 0b                	jne    1557 <f2fs_should_update_inplace.part.0+0x67>
    154c:	41 f6 46 19 08       	testb  $0x8,0x19(%r14)
    1551:	0f 84 ab 00 00 00    	je     1602 <f2fs_should_update_inplace.part.0+0x112>
	return false;
    1557:	31 c0                	xor    %eax,%eax
	if (policy & (0x1 << F2FS_IPU_FSYNC) &&
    1559:	83 e3 10             	and    $0x10,%ebx
    155c:	74 54                	je     15b2 <f2fs_should_update_inplace.part.0+0xc2>
    155e:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    1565:	00 
}
    1566:	5b                   	pop    %rbx
    1567:	41 5c                	pop    %r12
    1569:	41 5d                	pop    %r13
    156b:	48 c1 e8 0e          	shr    $0xe,%rax
    156f:	41 5e                	pop    %r14
    1571:	5d                   	pop    %rbp
    1572:	83 e0 01             	and    $0x1,%eax
    1575:	c3                   	retq   
	if (policy & (0x1 << F2FS_IPU_SSR_UTIL) && f2fs_need_SSR(sbi) &&
    1576:	4c 89 ef             	mov    %r13,%rdi
    1579:	e8 00 00 00 00       	callq  157e <f2fs_should_update_inplace.part.0+0x8e>
    157e:	84 c0                	test   %al,%al
    1580:	74 b9                	je     153b <f2fs_should_update_inplace.part.0+0x4b>
	return prefree_segments(sbi) > SM_I(sbi)->rec_prefree_segments;
}

static inline int utilization(struct f2fs_sb_info *sbi)
{
	return div_u64((u64)valid_user_blocks(sbi) * 100,
    1582:	41 8b 85 58 04 00 00 	mov    0x458(%r13),%eax
 * This is commonly provided by 32bit archs to provide an optimized 64bit
 * divide.
 */
static inline u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)
{
	*remainder = dividend % divisor;
    1589:	41 8b 8d 54 04 00 00 	mov    0x454(%r13),%ecx
	return dividend / divisor;
    1590:	31 d2                	xor    %edx,%edx
    1592:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    1596:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    159a:	48 c1 e0 02          	shl    $0x2,%rax
    159e:	48 f7 f1             	div    %rcx
		utilization(sbi) > SM_I(sbi)->min_ipu_util)
    15a1:	49 8b 55 68          	mov    0x68(%r13),%rdx
	if (policy & (0x1 << F2FS_IPU_SSR_UTIL) && f2fs_need_SSR(sbi) &&
    15a5:	39 82 84 00 00 00    	cmp    %eax,0x84(%rdx)
    15ab:	73 8e                	jae    153b <f2fs_should_update_inplace.part.0+0x4b>
		return true;
    15ad:	b8 01 00 00 00       	mov    $0x1,%eax
}
    15b2:	5b                   	pop    %rbx
    15b3:	41 5c                	pop    %r12
    15b5:	41 5d                	pop    %r13
    15b7:	41 5e                	pop    %r14
    15b9:	5d                   	pop    %rbp
    15ba:	c3                   	retq   
    15bb:	41 8b 85 58 04 00 00 	mov    0x458(%r13),%eax
	*remainder = dividend % divisor;
    15c2:	41 8b 8d 54 04 00 00 	mov    0x454(%r13),%ecx
	return dividend / divisor;
    15c9:	31 d2                	xor    %edx,%edx
    15cb:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    15cf:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    15d3:	48 c1 e0 02          	shl    $0x2,%rax
    15d7:	48 f7 f1             	div    %rcx
		utilization(sbi) > SM_I(sbi)->min_ipu_util)
    15da:	49 8b 55 68          	mov    0x68(%r13),%rdx
	if (policy & (0x1 << F2FS_IPU_UTIL) &&
    15de:	39 82 84 00 00 00    	cmp    %eax,0x84(%rdx)
    15e4:	0f 83 4c ff ff ff    	jae    1536 <f2fs_should_update_inplace.part.0+0x46>
    15ea:	eb c1                	jmp    15ad <f2fs_should_update_inplace.part.0+0xbd>
	if (policy & (0x1 << F2FS_IPU_SSR) && f2fs_need_SSR(sbi))
    15ec:	4c 89 ef             	mov    %r13,%rdi
    15ef:	e8 00 00 00 00       	callq  15f4 <f2fs_should_update_inplace.part.0+0x104>
    15f4:	84 c0                	test   %al,%al
    15f6:	75 b5                	jne    15ad <f2fs_should_update_inplace.part.0+0xbd>
	if (policy & (0x1 << F2FS_IPU_UTIL) &&
    15f8:	f6 c3 04             	test   $0x4,%bl
    15fb:	75 be                	jne    15bb <f2fs_should_update_inplace.part.0+0xcb>
    15fd:	e9 34 ff ff ff       	jmpq   1536 <f2fs_should_update_inplace.part.0+0x46>
		!(fio->op_flags & REQ_SYNC) &&
    1602:	41 f6 84 24 60 02 00 	testb  $0x4,0x260(%r12)
    1609:	00 04 
    160b:	0f 85 46 ff ff ff    	jne    1557 <f2fs_should_update_inplace.part.0+0x67>
    1611:	eb 9a                	jmp    15ad <f2fs_should_update_inplace.part.0+0xbd>
    1613:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    161a:	00 00 00 00 
    161e:	66 90                	xchg   %ax,%ax

0000000000001620 <decrypt_work>:
static void decrypt_work(struct work_struct *work) {
    1620:	f3 0f 1e fa          	endbr64 
    1624:	e8 00 00 00 00       	callq  1629 <decrypt_work+0x9>
	switch (++ctx->cur_step) {
    1629:	8b 47 20             	mov    0x20(%rdi),%eax
    162c:	83 c0 01             	add    $0x1,%eax
    162f:	89 47 20             	mov    %eax,0x20(%rdi)
    1632:	83 f8 01             	cmp    $0x1,%eax
    1635:	75 0d                	jne    1644 <decrypt_work+0x24>
			if (ctx->enabled_steps & (1 << STEP_DECRYPT)) {
    1637:	f6 47 24 02          	testb  $0x2,0x24(%rdi)
    163b:	75 16                	jne    1653 <decrypt_work+0x33>
			ctx->cur_step++;
    163d:	c7 47 20 02 00 00 00 	movl   $0x2,0x20(%rdi)
static void decrypt_work(struct work_struct *work) {
    1644:	55                   	push   %rbp
			__read_end_io(ctx->bio);
    1645:	48 8b 7f f8          	mov    -0x8(%rdi),%rdi
static void decrypt_work(struct work_struct *work) {
    1649:	48 89 e5             	mov    %rsp,%rbp
			__read_end_io(ctx->bio);
    164c:	e8 3f ee ff ff       	callq  490 <__read_end_io>
}
    1651:	5d                   	pop    %rbp
    1652:	c3                   	retq   
				INIT_WORK(&ctx->work, decrypt_work);
    1653:	48 b8 e0 ff ff ff 0f 	movabs $0xfffffffe0,%rax
    165a:	00 00 00 
    165d:	48 c7 47 18 00 00 00 	movq   $0x0,0x18(%rdi)
    1664:	00 
    1665:	48 89 07             	mov    %rax,(%rdi)
    1668:	48 8d 47 08          	lea    0x8(%rdi),%rax
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
    166c:	48 89 47 08          	mov    %rax,0x8(%rdi)
    1670:	48 89 47 10          	mov    %rax,0x10(%rdi)
				return;
    1674:	c3                   	retq   
    1675:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    167c:	00 00 00 00 

0000000000001680 <f2fs_target_device>:
										block_t blk_addr, struct bio *bio) {
    1680:	f3 0f 1e fa          	endbr64 
    1684:	e8 00 00 00 00       	callq  1689 <f2fs_target_device+0x9>
    1689:	55                   	push   %rbp
	struct block_device *bdev = sbi->sb->s_bdev;
    168a:	48 8b 07             	mov    (%rdi),%rax
	for (i = 0; i < sbi->s_ndevs; i++) {
    168d:	8b 8f e8 06 00 00    	mov    0x6e8(%rdi),%ecx
	struct block_device *bdev = sbi->sb->s_bdev;
    1693:	4c 8b 80 d0 00 00 00 	mov    0xd0(%rax),%r8
										block_t blk_addr, struct bio *bio) {
    169a:	48 89 e5             	mov    %rsp,%rbp
	for (i = 0; i < sbi->s_ndevs; i++) {
    169d:	85 c9                	test   %ecx,%ecx
    169f:	7e 2c                	jle    16cd <f2fs_target_device+0x4d>
    16a1:	83 e9 01             	sub    $0x1,%ecx
    16a4:	48 8b 87 f0 06 00 00 	mov    0x6f0(%rdi),%rax
    16ab:	48 8d 0c 49          	lea    (%rcx,%rcx,2),%rcx
    16af:	48 c1 e1 05          	shl    $0x5,%rcx
    16b3:	48 8d 7c 08 60       	lea    0x60(%rax,%rcx,1),%rdi
		if (FDEV(i).start_blk <= blk_addr &&
    16b8:	8b 48 4c             	mov    0x4c(%rax),%ecx
    16bb:	39 f1                	cmp    %esi,%ecx
    16bd:	77 05                	ja     16c4 <f2fs_target_device+0x44>
    16bf:	39 70 50             	cmp    %esi,0x50(%rax)
    16c2:	73 43                	jae    1707 <f2fs_target_device+0x87>
	for (i = 0; i < sbi->s_ndevs; i++) {
    16c4:	48 83 c0 60          	add    $0x60,%rax
    16c8:	48 39 f8             	cmp    %rdi,%rax
    16cb:	75 eb                	jne    16b8 <f2fs_target_device+0x38>
	if (bio) {
    16cd:	48 85 d2             	test   %rdx,%rdx
    16d0:	74 30                	je     1702 <f2fs_target_device+0x82>
		bio_set_dev(bio, bdev);
    16d2:	49 8b 80 80 00 00 00 	mov    0x80(%r8),%rax
    16d9:	48 39 42 08          	cmp    %rax,0x8(%rdx)
    16dd:	74 0d                	je     16ec <f2fs_target_device+0x6c>
	bio->bi_flags |= (1U << bit);
}

static inline void bio_clear_flag(struct bio *bio, unsigned int bit)
{
	bio->bi_flags &= ~(1U << bit);
    16df:	66 81 62 14 ff fd    	andw   $0xfdff,0x14(%rdx)
    16e5:	49 8b 80 80 00 00 00 	mov    0x80(%r8),%rax
    16ec:	48 89 42 08          	mov    %rax,0x8(%rdx)
		bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);
    16f0:	89 f6                	mov    %esi,%esi
		bio_set_dev(bio, bdev);
    16f2:	41 0f b6 40 6c       	movzbl 0x6c(%r8),%eax
		bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);
    16f7:	48 c1 e6 03          	shl    $0x3,%rsi
		bio_set_dev(bio, bdev);
    16fb:	88 42 1b             	mov    %al,0x1b(%rdx)
		bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);
    16fe:	48 89 72 28          	mov    %rsi,0x28(%rdx)
}
    1702:	4c 89 c0             	mov    %r8,%rax
    1705:	5d                   	pop    %rbp
    1706:	c3                   	retq   
			bdev = FDEV(i).bdev;
    1707:	4c 8b 00             	mov    (%rax),%r8
			blk_addr -= FDEV(i).start_blk;
    170a:	29 ce                	sub    %ecx,%esi
			break;
    170c:	eb bf                	jmp    16cd <f2fs_target_device+0x4d>
    170e:	66 90                	xchg   %ax,%ax

0000000000001710 <__bio_alloc>:
							   enum page_type type, enum temp_type temp) {
    1710:	e8 00 00 00 00       	callq  1715 <__bio_alloc+0x5>
    1715:	55                   	push   %rbp
    1716:	48 89 e5             	mov    %rsp,%rbp
    1719:	41 57                	push   %r15
    171b:	41 89 f7             	mov    %esi,%r15d
    171e:	89 ce                	mov    %ecx,%esi
    1720:	41 56                	push   %r14
    1722:	45 89 c6             	mov    %r8d,%r14d
    1725:	41 55                	push   %r13
    1727:	49 89 fd             	mov    %rdi,%r13

extern struct bio_set fs_bio_set;

static inline struct bio *bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)
{
	return bio_alloc_bioset(gfp_mask, nr_iovecs, &fs_bio_set);
    172a:	bf 00 00 60 00       	mov    $0x600000,%edi
    172f:	41 54                	push   %r12
    1731:	53                   	push   %rbx
    1732:	48 89 d3             	mov    %rdx,%rbx
    1735:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    173c:	48 83 ec 08          	sub    $0x8,%rsp
    1740:	44 89 4d d0          	mov    %r9d,-0x30(%rbp)
    1744:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    1747:	e8 00 00 00 00       	callq  174c <__bio_alloc+0x3c>
		if (!bio)
    174c:	8b 75 d4             	mov    -0x2c(%rbp),%esi
    174f:	48 85 c0             	test   %rax,%rax
    1752:	49 89 c4             	mov    %rax,%r12
    1755:	74 78                	je     17cf <__bio_alloc+0xbf>
	f2fs_target_device(sbi, blk_addr, bio);
    1757:	4c 89 e2             	mov    %r12,%rdx
    175a:	44 89 fe             	mov    %r15d,%esi
    175d:	4c 89 ef             	mov    %r13,%rdi
    1760:	e8 00 00 00 00       	callq  1765 <__bio_alloc+0x55>
	if (is_read) {
    1765:	45 84 f6             	test   %r14b,%r14b
    1768:	74 41                	je     17ab <__bio_alloc+0x9b>
		bio->bi_end_io = f2fs_read_end_io;
    176a:	49 c7 44 24 48 00 00 	movq   $0x0,0x48(%r12)
    1771:	00 00 
		bio->bi_private = NULL;
    1773:	49 c7 44 24 50 00 00 	movq   $0x0,0x50(%r12)
    177a:	00 00 
	if (wbc)
    177c:	48 85 db             	test   %rbx,%rbx
    177f:	74 18                	je     1799 <__bio_alloc+0x89>
	 * pageout() path doesn't attach @wbc to the inode being written
	 * out.  This is intentional as we don't want the function to block
	 * behind a slow cgroup.  Ultimately, we want pageout() to kick off
	 * regular writeback instead of writing things out itself.
	 */
	if (wbc->wb)
    1781:	48 8b 43 28          	mov    0x28(%rbx),%rax
    1785:	48 85 c0             	test   %rax,%rax
    1788:	74 0f                	je     1799 <__bio_alloc+0x89>
		bio_associate_blkcg(bio, wbc->wb->blkcg_css);
    178a:	48 8b b0 70 02 00 00 	mov    0x270(%rax),%rsi
    1791:	4c 89 e7             	mov    %r12,%rdi
    1794:	e8 00 00 00 00       	callq  1799 <__bio_alloc+0x89>
}
    1799:	48 83 c4 08          	add    $0x8,%rsp
    179d:	4c 89 e0             	mov    %r12,%rax
    17a0:	5b                   	pop    %rbx
    17a1:	41 5c                	pop    %r12
    17a3:	41 5d                	pop    %r13
    17a5:	41 5e                	pop    %r14
    17a7:	41 5f                	pop    %r15
    17a9:	5d                   	pop    %rbp
    17aa:	c3                   	retq   
		bio->bi_write_hint = f2fs_io_type_to_rw_hint(sbi, type, temp);
    17ab:	8b 55 10             	mov    0x10(%rbp),%edx
    17ae:	8b 75 d0             	mov    -0x30(%rbp),%esi
		bio->bi_private = sbi;
    17b1:	4d 89 6c 24 50       	mov    %r13,0x50(%r12)
		bio->bi_write_hint = f2fs_io_type_to_rw_hint(sbi, type, temp);
    17b6:	4c 89 ef             	mov    %r13,%rdi
		bio->bi_end_io = f2fs_write_end_io;
    17b9:	49 c7 44 24 48 00 00 	movq   $0x0,0x48(%r12)
    17c0:	00 00 
		bio->bi_write_hint = f2fs_io_type_to_rw_hint(sbi, type, temp);
    17c2:	e8 00 00 00 00       	callq  17c7 <__bio_alloc+0xb7>
    17c7:	66 41 89 44 24 18    	mov    %ax,0x18(%r12)
    17cd:	eb ad                	jmp    177c <__bio_alloc+0x6c>
    17cf:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    17d6:	bf 00 08 60 00       	mov    $0x600800,%edi
    17db:	e8 00 00 00 00       	callq  17e0 <__bio_alloc+0xd0>
    17e0:	49 89 c4             	mov    %rax,%r12
    17e3:	e9 6f ff ff ff       	jmpq   1757 <__bio_alloc+0x47>
    17e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    17ef:	00 

00000000000017f0 <f2fs_grab_read_bio>:
									  unsigned nr_pages) {
    17f0:	e8 00 00 00 00       	callq  17f5 <f2fs_grab_read_bio+0x5>
    17f5:	55                   	push   %rbp
	bio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);
    17f6:	81 fa 00 02 00 00    	cmp    $0x200,%edx
									  unsigned nr_pages) {
    17fc:	48 89 e5             	mov    %rsp,%rbp
    17ff:	41 56                	push   %r14
    1801:	41 55                	push   %r13
    1803:	41 89 f5             	mov    %esi,%r13d
	bio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);
    1806:	be 00 02 00 00       	mov    $0x200,%esi
									  unsigned nr_pages) {
    180b:	41 54                	push   %r12
	bio = f2fs_bio_alloc(sbi, min_t(int, nr_pages, BIO_MAX_PAGES), false);
    180d:	0f 4e f2             	cmovle %edx,%esi
    1810:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
		return ERR_PTR(-ENOMEM);
    1817:	49 c7 c4 f4 ff ff ff 	mov    $0xfffffffffffffff4,%r12
									  unsigned nr_pages) {
    181e:	53                   	push   %rbx
	return sb->s_fs_info;
    181f:	48 8b 47 28          	mov    0x28(%rdi),%rax
    1823:	48 89 fb             	mov    %rdi,%rbx
    1826:	bf c0 00 60 00       	mov    $0x6000c0,%edi
    182b:	4c 8b b0 08 04 00 00 	mov    0x408(%rax),%r14
    1832:	e8 00 00 00 00       	callq  1837 <f2fs_grab_read_bio+0x47>
	if (!bio)
    1837:	48 85 c0             	test   %rax,%rax
    183a:	74 39                	je     1875 <f2fs_grab_read_bio+0x85>
    183c:	49 89 c4             	mov    %rax,%r12
	f2fs_target_device(sbi, blkaddr, bio);
    183f:	48 89 c2             	mov    %rax,%rdx
    1842:	44 89 ee             	mov    %r13d,%esi
    1845:	4c 89 f7             	mov    %r14,%rdi
    1848:	e8 00 00 00 00       	callq  184d <f2fs_grab_read_bio+0x5d>
	bio->bi_end_io = f2fs_read_end_io;
    184d:	49 c7 44 24 48 00 00 	movq   $0x0,0x48(%r12)
    1854:	00 00 
    1856:	41 c7 44 24 10 00 00 	movl   $0x0,0x10(%r12)
    185d:	00 00 
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    185f:	f6 83 60 02 00 00 04 	testb  $0x4,0x260(%rbx)
    1866:	74 0d                	je     1875 <f2fs_grab_read_bio+0x85>
    1868:	0f b7 03             	movzwl (%rbx),%eax
    186b:	66 25 00 f0          	and    $0xf000,%ax
    186f:	66 3d 00 80          	cmp    $0x8000,%ax
    1873:	74 0c                	je     1881 <f2fs_grab_read_bio+0x91>
}
    1875:	5b                   	pop    %rbx
    1876:	4c 89 e0             	mov    %r12,%rax
    1879:	41 5c                	pop    %r12
    187b:	41 5d                	pop    %r13
    187d:	41 5e                	pop    %r14
    187f:	5d                   	pop    %rbp
    1880:	c3                   	retq   
		ctx = mempool_alloc(bio_post_read_ctx_pool, GFP_NOFS);
    1881:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1888 <f2fs_grab_read_bio+0x98>
    1888:	be 40 00 60 00       	mov    $0x600040,%esi
    188d:	e8 00 00 00 00       	callq  1892 <f2fs_grab_read_bio+0xa2>
		if (!ctx) {
    1892:	48 85 c0             	test   %rax,%rax
    1895:	74 26                	je     18bd <f2fs_grab_read_bio+0xcd>
		ctx->bio = bio;
    1897:	4c 89 20             	mov    %r12,(%rax)
		f2fs_wait_on_block_writeback(sbi, blkaddr);
    189a:	44 89 ee             	mov    %r13d,%esi
    189d:	4c 89 f7             	mov    %r14,%rdi
		ctx->enabled_steps = post_read_steps;
    18a0:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%rax)
		bio->bi_private = ctx;
    18a7:	49 89 44 24 50       	mov    %rax,0x50(%r12)
		f2fs_wait_on_block_writeback(sbi, blkaddr);
    18ac:	e8 00 00 00 00       	callq  18b1 <f2fs_grab_read_bio+0xc1>
}
    18b1:	4c 89 e0             	mov    %r12,%rax
    18b4:	5b                   	pop    %rbx
    18b5:	41 5c                	pop    %r12
    18b7:	41 5d                	pop    %r13
    18b9:	41 5e                	pop    %r14
    18bb:	5d                   	pop    %rbp
    18bc:	c3                   	retq   
			bio_put(bio);
    18bd:	4c 89 e7             	mov    %r12,%rdi
			return ERR_PTR(-ENOMEM);
    18c0:	49 c7 c4 f4 ff ff ff 	mov    $0xfffffffffffffff4,%r12
			bio_put(bio);
    18c7:	e8 00 00 00 00       	callq  18cc <f2fs_grab_read_bio+0xdc>
			return ERR_PTR(-ENOMEM);
    18cc:	eb a7                	jmp    1875 <f2fs_grab_read_bio+0x85>
    18ce:	66 90                	xchg   %ax,%ax

00000000000018d0 <f2fs_submit_page_read>:
								 block_t blkaddr) {
    18d0:	e8 00 00 00 00       	callq  18d5 <f2fs_submit_page_read+0x5>
    18d5:	55                   	push   %rbp
    18d6:	48 89 e5             	mov    %rsp,%rbp
    18d9:	41 57                	push   %r15
    18db:	41 56                	push   %r14
    18dd:	41 55                	push   %r13
    18df:	41 54                	push   %r12
    18e1:	49 89 f4             	mov    %rsi,%r12
    18e4:	89 d6                	mov    %edx,%esi
	struct bio *bio = f2fs_grab_read_bio(inode, blkaddr, 1);
    18e6:	ba 01 00 00 00       	mov    $0x1,%edx
								 block_t blkaddr) {
    18eb:	53                   	push   %rbx
    18ec:	48 89 fb             	mov    %rdi,%rbx
	struct bio *bio = f2fs_grab_read_bio(inode, blkaddr, 1);
    18ef:	e8 fc fe ff ff       	callq  17f0 <f2fs_grab_read_bio>
    18f4:	49 89 c5             	mov    %rax,%r13
	if (IS_ERR(bio))
    18f7:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    18fd:	0f 87 4e 01 00 00    	ja     1a51 <f2fs_submit_page_read+0x181>
	if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {
    1903:	31 c9                	xor    %ecx,%ecx
    1905:	ba 00 10 00 00       	mov    $0x1000,%edx
    190a:	4c 89 e6             	mov    %r12,%rsi
    190d:	48 89 c7             	mov    %rax,%rdi
    1910:	e8 00 00 00 00       	callq  1915 <f2fs_submit_page_read+0x45>
    1915:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    191a:	0f 86 29 02 00 00    	jbe    1b49 <f2fs_submit_page_read+0x279>
	return sb->s_fs_info;
    1920:	48 8b 43 28          	mov    0x28(%rbx),%rax
	if (!is_read_io(bio_op(bio))) {
    1924:	41 80 7d 10 00       	cmpb   $0x0,0x10(%r13)
    1929:	4c 8b b0 08 04 00 00 	mov    0x408(%rax),%r14
    1930:	49 8b 06             	mov    (%r14),%rax
    1933:	49 89 c4             	mov    %rax,%r12
    1936:	0f 84 20 01 00 00    	je     1a5c <f2fs_submit_page_read+0x18c>
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
    193c:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
    1943:	48 8b 52 10          	mov    0x10(%rdx),%rdx
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    1947:	f6 82 84 08 00 00 02 	testb  $0x2,0x884(%rdx)
    194e:	0f 84 55 01 00 00    	je     1aa9 <f2fs_submit_page_read+0x1d9>
    1954:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    195b:	00 00 
    195d:	48 83 ba 48 0b 00 00 	cmpq   $0x0,0xb48(%rdx)
    1964:	00 
    1965:	0f 84 3e 01 00 00    	je     1aa9 <f2fs_submit_page_read+0x1d9>
			blk_finish_plug(current->plug);
    196b:	48 8b ba 48 0b 00 00 	mov    0xb48(%rdx),%rdi
    1972:	e8 00 00 00 00       	callq  1977 <f2fs_submit_page_read+0xa7>
		start %= F2FS_IO_SIZE(sbi);
    1977:	41 8b 8e f4 04 00 00 	mov    0x4f4(%r14),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    197e:	41 8b 45 30          	mov    0x30(%r13),%eax
		start %= F2FS_IO_SIZE(sbi);
    1982:	ba 01 00 00 00       	mov    $0x1,%edx
    1987:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1989:	c1 e8 0c             	shr    $0xc,%eax
		start %= F2FS_IO_SIZE(sbi);
    198c:	8d 5a ff             	lea    -0x1(%rdx),%ebx
		if (start == 0)
    198f:	21 c3                	and    %eax,%ebx
    1991:	0f 84 94 00 00 00    	je     1a2b <f2fs_submit_page_read+0x15b>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    1997:	39 d3                	cmp    %edx,%ebx
    1999:	0f 83 8c 00 00 00    	jae    1a2b <f2fs_submit_page_read+0x15b>
    199f:	41 bf 01 00 00 00    	mov    $0x1,%r15d
					mempool_alloc(sbi->write_io_dummy,
    19a5:	49 8b be 70 01 00 00 	mov    0x170(%r14),%rdi
    19ac:	be 00 88 60 00       	mov    $0x608800,%esi
    19b1:	e8 00 00 00 00       	callq  19b6 <f2fs_submit_page_read+0xe6>
    19b6:	49 89 c4             	mov    %rax,%r12
			f2fs_bug_on(sbi, !page);
    19b9:	48 85 c0             	test   %rax,%rax
    19bc:	0f 84 7a 01 00 00    	je     1b3c <f2fs_submit_page_read+0x26c>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    19c2:	f0 41 80 4c 24 01 10 	lock orb $0x10,0x1(%r12)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    19c9:	49 c7 44 24 28 fe ff 	movq   $0xfffffffffffffffe,0x28(%r12)
    19d0:	ff ff 
	might_sleep();
    19d2:	e8 00 00 00 00       	callq  19d7 <f2fs_submit_page_read+0x107>
	__READ_ONCE_SIZE;
    19d7:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    19dc:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    19e0:	83 e2 01             	and    $0x1,%edx
    19e3:	49 0f 44 c4          	cmove  %r12,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    19e7:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    19ed:	0f 82 3c 01 00 00    	jb     1b2f <f2fs_submit_page_read+0x25f>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    19f3:	31 c9                	xor    %ecx,%ecx
    19f5:	ba 00 10 00 00       	mov    $0x1000,%edx
    19fa:	4c 89 e6             	mov    %r12,%rsi
    19fd:	4c 89 ef             	mov    %r13,%rdi
    1a00:	e8 00 00 00 00       	callq  1a05 <f2fs_submit_page_read+0x135>
    1a05:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    1a0a:	77 08                	ja     1a14 <f2fs_submit_page_read+0x144>
				f2fs_bug_on(sbi, 1);
    1a0c:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1a0e:	f0 41 80 4e 48 04    	lock orb $0x4,0x48(%r14)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    1a14:	41 8b 8e f4 04 00 00 	mov    0x4f4(%r14),%ecx
    1a1b:	44 89 f8             	mov    %r15d,%eax
    1a1e:	83 c3 01             	add    $0x1,%ebx
    1a21:	d3 e0                	shl    %cl,%eax
    1a23:	39 c3                	cmp    %eax,%ebx
    1a25:	0f 82 7a ff ff ff    	jb     19a5 <f2fs_submit_page_read+0xd5>
	if (is_read_io(bio_op(bio)))
    1a2b:	41 80 7d 10 00       	cmpb   $0x0,0x10(%r13)
    1a30:	4d 8b 26             	mov    (%r14),%r12
    1a33:	74 27                	je     1a5c <f2fs_submit_page_read+0x18c>
	asm_volatile_goto("1:"
    1a35:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    1a3a:	31 d2                	xor    %edx,%edx
    1a3c:	4c 89 ee             	mov    %r13,%rsi
    1a3f:	4c 89 f7             	mov    %r14,%rdi
    1a42:	e8 00 00 00 00       	callq  1a47 <f2fs_submit_page_read+0x177>
	submit_bio(bio);//提交进行io操作
    1a47:	4c 89 ef             	mov    %r13,%rdi
    1a4a:	e8 00 00 00 00       	callq  1a4f <f2fs_submit_page_read+0x17f>
	return 0;
    1a4f:	31 c0                	xor    %eax,%eax
}
    1a51:	5b                   	pop    %rbx
    1a52:	41 5c                	pop    %r12
    1a54:	41 5d                	pop    %r13
    1a56:	41 5e                	pop    %r14
    1a58:	41 5f                	pop    %r15
    1a5a:	5d                   	pop    %rbp
    1a5b:	c3                   	retq   
    1a5c:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    1a61:	eb d7                	jmp    1a3a <f2fs_submit_page_read+0x16a>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    1a63:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 1a6a <f2fs_submit_page_read+0x19a>
    1a6a:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    1a6c:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 1a74 <f2fs_submit_page_read+0x1a4>
    1a73:	00 
    1a74:	73 c4                	jae    1a3a <f2fs_submit_page_read+0x16a>
    1a76:	4d 85 ed             	test   %r13,%r13
    1a79:	74 bf                	je     1a3a <f2fs_submit_page_read+0x16a>
    1a7b:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 1a82 <f2fs_submit_page_read+0x1b2>
    1a82:	48 85 db             	test   %rbx,%rbx
    1a85:	74 20                	je     1aa7 <f2fs_submit_page_read+0x1d7>
    1a87:	48 8b 03             	mov    (%rbx),%rax
    1a8a:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    1a8e:	48 83 c3 18          	add    $0x18,%rbx
    1a92:	4c 89 e9             	mov    %r13,%rcx
    1a95:	31 d2                	xor    %edx,%edx
    1a97:	4c 89 e6             	mov    %r12,%rsi
    1a9a:	e8 00 00 00 00       	callq  1a9f <f2fs_submit_page_read+0x1cf>
    1a9f:	48 8b 03             	mov    (%rbx),%rax
    1aa2:	48 85 c0             	test   %rax,%rax
    1aa5:	75 e3                	jne    1a8a <f2fs_submit_page_read+0x1ba>
    1aa7:	eb 91                	jmp    1a3a <f2fs_submit_page_read+0x16a>
		start %= F2FS_IO_SIZE(sbi);
    1aa9:	41 8b 8e f4 04 00 00 	mov    0x4f4(%r14),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1ab0:	41 8b 55 30          	mov    0x30(%r13),%edx
		start %= F2FS_IO_SIZE(sbi);
    1ab4:	be 01 00 00 00       	mov    $0x1,%esi
    1ab9:	d3 e6                	shl    %cl,%esi
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1abb:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    1abe:	8d 5e ff             	lea    -0x1(%rsi),%ebx
		if (start == 0)
    1ac1:	21 d3                	and    %edx,%ebx
    1ac3:	0f 84 6c ff ff ff    	je     1a35 <f2fs_submit_page_read+0x165>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    1ac9:	39 de                	cmp    %ebx,%esi
    1acb:	0f 87 ce fe ff ff    	ja     199f <f2fs_submit_page_read+0xcf>
	if (is_read_io(bio_op(bio)))
    1ad1:	49 89 c4             	mov    %rax,%r12
    1ad4:	e9 5c ff ff ff       	jmpq   1a35 <f2fs_submit_page_read+0x165>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    1ad9:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 1ae0 <f2fs_submit_page_read+0x210>
    1ae0:	89 c0                	mov    %eax,%eax
    1ae2:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 1aea <f2fs_submit_page_read+0x21a>
    1ae9:	00 
    1aea:	0f 92 c0             	setb   %al
    1aed:	4d 85 ed             	test   %r13,%r13
    1af0:	0f 84 44 ff ff ff    	je     1a3a <f2fs_submit_page_read+0x16a>
    1af6:	84 c0                	test   %al,%al
    1af8:	0f 84 3c ff ff ff    	je     1a3a <f2fs_submit_page_read+0x16a>
    1afe:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 1b05 <f2fs_submit_page_read+0x235>
    1b05:	48 85 db             	test   %rbx,%rbx
    1b08:	74 9d                	je     1aa7 <f2fs_submit_page_read+0x1d7>
    1b0a:	48 8b 03             	mov    (%rbx),%rax
    1b0d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    1b11:	48 83 c3 18          	add    $0x18,%rbx
    1b15:	4c 89 e9             	mov    %r13,%rcx
    1b18:	31 d2                	xor    %edx,%edx
    1b1a:	4c 89 e6             	mov    %r12,%rsi
    1b1d:	e8 00 00 00 00       	callq  1b22 <f2fs_submit_page_read+0x252>
    1b22:	48 8b 03             	mov    (%rbx),%rax
    1b25:	48 85 c0             	test   %rax,%rax
    1b28:	75 e3                	jne    1b0d <f2fs_submit_page_read+0x23d>
	preempt_enable_notrace();
    1b2a:	e9 0b ff ff ff       	jmpq   1a3a <f2fs_submit_page_read+0x16a>
		__lock_page(page);
    1b2f:	4c 89 e7             	mov    %r12,%rdi
    1b32:	e8 00 00 00 00       	callq  1b37 <f2fs_submit_page_read+0x267>
    1b37:	e9 b7 fe ff ff       	jmpq   19f3 <f2fs_submit_page_read+0x123>
			f2fs_bug_on(sbi, !page);
    1b3c:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1b3e:	f0 41 80 4e 48 04    	lock orb $0x4,0x48(%r14)
}
    1b44:	e9 79 fe ff ff       	jmpq   19c2 <f2fs_submit_page_read+0xf2>
		bio_put(bio);
    1b49:	4c 89 ef             	mov    %r13,%rdi
    1b4c:	e8 00 00 00 00       	callq  1b51 <f2fs_submit_page_read+0x281>
		return -EFAULT;
    1b51:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    1b56:	e9 f6 fe ff ff       	jmpq   1a51 <f2fs_submit_page_read+0x181>
    1b5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000001b60 <f2fs_target_device_index>:
int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr) {
    1b60:	f3 0f 1e fa          	endbr64 
    1b64:	e8 00 00 00 00       	callq  1b69 <f2fs_target_device_index+0x9>
    1b69:	55                   	push   %rbp
	for (i = 0; i < sbi->s_ndevs; i++)
    1b6a:	8b 97 e8 06 00 00    	mov    0x6e8(%rdi),%edx
int f2fs_target_device_index(struct f2fs_sb_info *sbi, block_t blkaddr) {
    1b70:	48 89 e5             	mov    %rsp,%rbp
	for (i = 0; i < sbi->s_ndevs; i++)
    1b73:	85 d2                	test   %edx,%edx
    1b75:	7e 24                	jle    1b9b <f2fs_target_device_index+0x3b>
    1b77:	48 8b 87 f0 06 00 00 	mov    0x6f0(%rdi),%rax
    1b7e:	45 31 c0             	xor    %r8d,%r8d
    1b81:	48 83 c0 4c          	add    $0x4c,%rax
		if (FDEV(i).start_blk <= blkaddr && FDEV(i).end_blk >= blkaddr)
    1b85:	39 30                	cmp    %esi,(%rax)
    1b87:	77 05                	ja     1b8e <f2fs_target_device_index+0x2e>
    1b89:	39 70 04             	cmp    %esi,0x4(%rax)
    1b8c:	73 10                	jae    1b9e <f2fs_target_device_index+0x3e>
	for (i = 0; i < sbi->s_ndevs; i++)
    1b8e:	41 83 c0 01          	add    $0x1,%r8d
    1b92:	48 83 c0 60          	add    $0x60,%rax
    1b96:	41 39 d0             	cmp    %edx,%r8d
    1b99:	75 ea                	jne    1b85 <f2fs_target_device_index+0x25>
	return 0;
    1b9b:	45 31 c0             	xor    %r8d,%r8d
}
    1b9e:	44 89 c0             	mov    %r8d,%eax
    1ba1:	5d                   	pop    %rbp
    1ba2:	c3                   	retq   
    1ba3:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1baa:	00 00 00 00 
    1bae:	66 90                	xchg   %ax,%ax

0000000000001bb0 <nvm_submit_bio>:
void nvm_submit_bio(struct f2fs_sb_info *sbi, struct bio *bio, enum page_type type) {
    1bb0:	f3 0f 1e fa          	endbr64 
    1bb4:	e8 00 00 00 00       	callq  1bb9 <nvm_submit_bio+0x9>
    1bb9:	55                   	push   %rbp
    1bba:	48 89 e5             	mov    %rsp,%rbp
    1bbd:	41 57                	push   %r15
    1bbf:	41 56                	push   %r14
    1bc1:	41 89 d6             	mov    %edx,%r14d
    1bc4:	41 55                	push   %r13
    1bc6:	49 89 f5             	mov    %rsi,%r13
    1bc9:	41 54                	push   %r12
    1bcb:	49 89 fc             	mov    %rdi,%r12
    1bce:	53                   	push   %rbx
	if (!is_read_io(bio_op(bio))) {
    1bcf:	0f b6 46 10          	movzbl 0x10(%rsi),%eax
		if (type != DATA && type != NODE)
    1bd3:	4c 8b 3f             	mov    (%rdi),%r15
    1bd6:	83 fa 01             	cmp    $0x1,%edx
    1bd9:	0f 87 2c 01 00 00    	ja     1d0b <nvm_submit_bio+0x15b>
    1bdf:	85 c0                	test   %eax,%eax
    1be1:	75 26                	jne    1c09 <nvm_submit_bio+0x59>
    1be3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    1be8:	44 89 f2             	mov    %r14d,%edx
    1beb:	4c 89 ee             	mov    %r13,%rsi
    1bee:	4c 89 e7             	mov    %r12,%rdi
    1bf1:	e8 00 00 00 00       	callq  1bf6 <nvm_submit_bio+0x46>
	submit_bio(bio);//提交进行io操作
    1bf6:	4c 89 ef             	mov    %r13,%rdi
    1bf9:	e8 00 00 00 00       	callq  1bfe <nvm_submit_bio+0x4e>
}
    1bfe:	5b                   	pop    %rbx
    1bff:	41 5c                	pop    %r12
    1c01:	41 5d                	pop    %r13
    1c03:	41 5e                	pop    %r14
    1c05:	41 5f                	pop    %r15
    1c07:	5d                   	pop    %rbp
    1c08:	c3                   	retq   
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
    1c09:	49 8b 87 08 04 00 00 	mov    0x408(%r15),%rax
    1c10:	48 8b 40 10          	mov    0x10(%rax),%rax
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    1c14:	f6 80 84 08 00 00 02 	testb  $0x2,0x884(%rax)
    1c1b:	0f 84 aa 01 00 00    	je     1dcb <nvm_submit_bio+0x21b>
    1c21:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    1c28:	00 00 
    1c2a:	48 83 b8 48 0b 00 00 	cmpq   $0x0,0xb48(%rax)
    1c31:	00 
    1c32:	0f 84 93 01 00 00    	je     1dcb <nvm_submit_bio+0x21b>
			blk_finish_plug(current->plug);
    1c38:	48 8b b8 48 0b 00 00 	mov    0xb48(%rax),%rdi
    1c3f:	e8 00 00 00 00       	callq  1c44 <nvm_submit_bio+0x94>
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1c44:	41 8b 55 30          	mov    0x30(%r13),%edx
		start %= F2FS_IO_SIZE(sbi);
    1c48:	b8 01 00 00 00       	mov    $0x1,%eax
    1c4d:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    1c54:	00 
    1c55:	d3 e0                	shl    %cl,%eax
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1c57:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    1c5a:	8d 58 ff             	lea    -0x1(%rax),%ebx
		if (start == 0)
    1c5d:	21 d3                	and    %edx,%ebx
    1c5f:	0f 84 9d 00 00 00    	je     1d02 <nvm_submit_bio+0x152>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    1c65:	39 d8                	cmp    %ebx,%eax
    1c67:	0f 86 88 00 00 00    	jbe    1cf5 <nvm_submit_bio+0x145>
					mempool_alloc(sbi->write_io_dummy,
    1c6d:	49 8b bc 24 70 01 00 	mov    0x170(%r12),%rdi
    1c74:	00 
    1c75:	be 00 88 60 00       	mov    $0x608800,%esi
    1c7a:	e8 00 00 00 00       	callq  1c7f <nvm_submit_bio+0xcf>
    1c7f:	49 89 c7             	mov    %rax,%r15
			f2fs_bug_on(sbi, !page);
    1c82:	48 85 c0             	test   %rax,%rax
    1c85:	0f 84 73 01 00 00    	je     1dfe <nvm_submit_bio+0x24e>
    1c8b:	f0 41 80 4f 01 10    	lock orb $0x10,0x1(%r15)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    1c91:	49 c7 47 28 fe ff ff 	movq   $0xfffffffffffffffe,0x28(%r15)
    1c98:	ff 
	might_sleep();
    1c99:	e8 00 00 00 00       	callq  1c9e <nvm_submit_bio+0xee>
    1c9e:	49 8b 57 08          	mov    0x8(%r15),%rdx
    1ca2:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    1ca6:	83 e2 01             	and    $0x1,%edx
    1ca9:	49 0f 44 c7          	cmove  %r15,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    1cad:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    1cb3:	0f 82 38 01 00 00    	jb     1df1 <nvm_submit_bio+0x241>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    1cb9:	31 c9                	xor    %ecx,%ecx
    1cbb:	ba 00 10 00 00       	mov    $0x1000,%edx
    1cc0:	4c 89 fe             	mov    %r15,%rsi
    1cc3:	4c 89 ef             	mov    %r13,%rdi
    1cc6:	e8 00 00 00 00       	callq  1ccb <nvm_submit_bio+0x11b>
    1ccb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    1cd0:	77 09                	ja     1cdb <nvm_submit_bio+0x12b>
				f2fs_bug_on(sbi, 1);
    1cd2:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1cd4:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    1cdb:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    1ce2:	00 
    1ce3:	b8 01 00 00 00       	mov    $0x1,%eax
    1ce8:	83 c3 01             	add    $0x1,%ebx
    1ceb:	d3 e0                	shl    %cl,%eax
    1ced:	39 c3                	cmp    %eax,%ebx
    1cef:	0f 82 78 ff ff ff    	jb     1c6d <nvm_submit_bio+0xbd>
		if (type == NODE)
    1cf5:	41 83 fe 01          	cmp    $0x1,%r14d
    1cf9:	75 07                	jne    1d02 <nvm_submit_bio+0x152>
    1cfb:	f0 41 80 4c 24 48 20 	lock orb $0x20,0x48(%r12)
    1d02:	41 0f b6 45 10       	movzbl 0x10(%r13),%eax
    1d07:	4d 8b 3c 24          	mov    (%r12),%r15
	if (is_read_io(bio_op(bio)))
    1d0b:	85 c0                	test   %eax,%eax
    1d0d:	0f 84 d0 fe ff ff    	je     1be3 <nvm_submit_bio+0x33>
    1d13:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    1d18:	e9 cb fe ff ff       	jmpq   1be8 <nvm_submit_bio+0x38>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    1d1d:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 1d24 <nvm_submit_bio+0x174>
    1d24:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    1d26:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 1d2e <nvm_submit_bio+0x17e>
    1d2d:	00 
    1d2e:	0f 92 c0             	setb   %al
    1d31:	4d 85 ed             	test   %r13,%r13
    1d34:	0f 84 ae fe ff ff    	je     1be8 <nvm_submit_bio+0x38>
    1d3a:	84 c0                	test   %al,%al
    1d3c:	0f 84 a6 fe ff ff    	je     1be8 <nvm_submit_bio+0x38>
    1d42:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 1d49 <nvm_submit_bio+0x199>
    1d49:	48 85 db             	test   %rbx,%rbx
    1d4c:	74 21                	je     1d6f <nvm_submit_bio+0x1bf>
    1d4e:	48 8b 03             	mov    (%rbx),%rax
    1d51:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    1d55:	48 83 c3 18          	add    $0x18,%rbx
    1d59:	4c 89 e9             	mov    %r13,%rcx
    1d5c:	44 89 f2             	mov    %r14d,%edx
    1d5f:	4c 89 fe             	mov    %r15,%rsi
    1d62:	e8 00 00 00 00       	callq  1d67 <nvm_submit_bio+0x1b7>
    1d67:	48 8b 03             	mov    (%rbx),%rax
    1d6a:	48 85 c0             	test   %rax,%rax
    1d6d:	75 e2                	jne    1d51 <nvm_submit_bio+0x1a1>
}
    1d6f:	e9 74 fe ff ff       	jmpq   1be8 <nvm_submit_bio+0x38>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    1d74:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 1d7b <nvm_submit_bio+0x1cb>
    1d7b:	89 c0                	mov    %eax,%eax
    1d7d:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 1d85 <nvm_submit_bio+0x1d5>
    1d84:	00 
    1d85:	0f 92 c0             	setb   %al
    1d88:	4d 85 ed             	test   %r13,%r13
    1d8b:	0f 84 57 fe ff ff    	je     1be8 <nvm_submit_bio+0x38>
    1d91:	84 c0                	test   %al,%al
    1d93:	0f 84 4f fe ff ff    	je     1be8 <nvm_submit_bio+0x38>
    1d99:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 1da0 <nvm_submit_bio+0x1f0>
    1da0:	48 85 db             	test   %rbx,%rbx
    1da3:	74 ca                	je     1d6f <nvm_submit_bio+0x1bf>
    1da5:	48 8b 03             	mov    (%rbx),%rax
    1da8:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    1dac:	48 83 c3 18          	add    $0x18,%rbx
    1db0:	4c 89 e9             	mov    %r13,%rcx
    1db3:	44 89 f2             	mov    %r14d,%edx
    1db6:	4c 89 fe             	mov    %r15,%rsi
    1db9:	e8 00 00 00 00       	callq  1dbe <nvm_submit_bio+0x20e>
    1dbe:	48 8b 03             	mov    (%rbx),%rax
    1dc1:	48 85 c0             	test   %rax,%rax
    1dc4:	75 e2                	jne    1da8 <nvm_submit_bio+0x1f8>
	preempt_enable_notrace();
    1dc6:	e9 1d fe ff ff       	jmpq   1be8 <nvm_submit_bio+0x38>
		start %= F2FS_IO_SIZE(sbi);
    1dcb:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    1dd2:	00 
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1dd3:	41 8b 55 30          	mov    0x30(%r13),%edx
		start %= F2FS_IO_SIZE(sbi);
    1dd7:	b8 01 00 00 00       	mov    $0x1,%eax
    1ddc:	d3 e0                	shl    %cl,%eax
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    1dde:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    1de1:	8d 58 ff             	lea    -0x1(%rax),%ebx
		if (start == 0)
    1de4:	21 d3                	and    %edx,%ebx
    1de6:	0f 85 79 fe ff ff    	jne    1c65 <nvm_submit_bio+0xb5>
    1dec:	e9 22 ff ff ff       	jmpq   1d13 <nvm_submit_bio+0x163>
		__lock_page(page);
    1df1:	4c 89 ff             	mov    %r15,%rdi
    1df4:	e8 00 00 00 00       	callq  1df9 <nvm_submit_bio+0x249>
    1df9:	e9 bb fe ff ff       	jmpq   1cb9 <nvm_submit_bio+0x109>
			f2fs_bug_on(sbi, !page);
    1dfe:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1e00:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
}
    1e07:	e9 7f fe ff ff       	jmpq   1c8b <nvm_submit_bio+0xdb>
    1e0c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000001e10 <f2fs_submit_merged_write>:
void f2fs_submit_merged_write(struct f2fs_sb_info *sbi, enum page_type type) {
    1e10:	f3 0f 1e fa          	endbr64 
    1e14:	e8 00 00 00 00       	callq  1e19 <f2fs_submit_merged_write+0x9>
    1e19:	55                   	push   %rbp
    1e1a:	41 89 f0             	mov    %esi,%r8d
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    1e1d:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    1e23:	31 c9                	xor    %ecx,%ecx
    1e25:	31 d2                	xor    %edx,%edx
    1e27:	31 f6                	xor    %esi,%esi
void f2fs_submit_merged_write(struct f2fs_sb_info *sbi, enum page_type type) {
    1e29:	48 89 e5             	mov    %rsp,%rbp
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    1e2c:	e8 bf ee ff ff       	callq  cf0 <__submit_merged_write_cond>
}
    1e31:	5d                   	pop    %rbp
    1e32:	c3                   	retq   
    1e33:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    1e3a:	00 00 00 00 
    1e3e:	66 90                	xchg   %ax,%ax

0000000000001e40 <f2fs_submit_merged_write_cond>:
								   enum page_type type) {
    1e40:	f3 0f 1e fa          	endbr64 
    1e44:	e8 00 00 00 00       	callq  1e49 <f2fs_submit_merged_write_cond+0x9>
    1e49:	55                   	push   %rbp
	__submit_merged_write_cond(sbi, inode, ino, idx, type, false);
    1e4a:	45 31 c9             	xor    %r9d,%r9d
								   enum page_type type) {
    1e4d:	48 89 e5             	mov    %rsp,%rbp
	__submit_merged_write_cond(sbi, inode, ino, idx, type, false);
    1e50:	e8 9b ee ff ff       	callq  cf0 <__submit_merged_write_cond>
}
    1e55:	5d                   	pop    %rbp
    1e56:	c3                   	retq   
    1e57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    1e5e:	00 00 

0000000000001e60 <f2fs_flush_merged_writes>:
void f2fs_flush_merged_writes(struct f2fs_sb_info *sbi) {
    1e60:	f3 0f 1e fa          	endbr64 
    1e64:	e8 00 00 00 00       	callq  1e69 <f2fs_flush_merged_writes+0x9>
    1e69:	55                   	push   %rbp
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    1e6a:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    1e70:	45 31 c0             	xor    %r8d,%r8d
    1e73:	31 c9                	xor    %ecx,%ecx
    1e75:	31 d2                	xor    %edx,%edx
    1e77:	31 f6                	xor    %esi,%esi
void f2fs_flush_merged_writes(struct f2fs_sb_info *sbi) {
    1e79:	48 89 e5             	mov    %rsp,%rbp
    1e7c:	41 54                	push   %r12
    1e7e:	49 89 fc             	mov    %rdi,%r12
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    1e81:	e8 6a ee ff ff       	callq  cf0 <__submit_merged_write_cond>
    1e86:	4c 89 e7             	mov    %r12,%rdi
    1e89:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    1e8f:	31 c9                	xor    %ecx,%ecx
    1e91:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1e97:	31 d2                	xor    %edx,%edx
    1e99:	31 f6                	xor    %esi,%esi
    1e9b:	e8 50 ee ff ff       	callq  cf0 <__submit_merged_write_cond>
    1ea0:	4c 89 e7             	mov    %r12,%rdi
    1ea3:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    1ea9:	31 c9                	xor    %ecx,%ecx
    1eab:	41 b8 02 00 00 00    	mov    $0x2,%r8d
    1eb1:	31 d2                	xor    %edx,%edx
    1eb3:	31 f6                	xor    %esi,%esi
    1eb5:	e8 36 ee ff ff       	callq  cf0 <__submit_merged_write_cond>
}
    1eba:	41 5c                	pop    %r12
    1ebc:	5d                   	pop    %rbp
    1ebd:	c3                   	retq   
    1ebe:	66 90                	xchg   %ax,%ax

0000000000001ec0 <f2fs_submit_page_bio>:
int f2fs_submit_page_bio(struct f2fs_io_info *fio) {
    1ec0:	f3 0f 1e fa          	endbr64 
    1ec4:	e8 00 00 00 00       	callq  1ec9 <f2fs_submit_page_bio+0x9>
    1ec9:	55                   	push   %rbp
    1eca:	48 89 e5             	mov    %rsp,%rbp
    1ecd:	41 57                	push   %r15
    1ecf:	49 89 ff             	mov    %rdi,%r15
    1ed2:	41 56                	push   %r14
    1ed4:	41 55                	push   %r13
    1ed6:	41 54                	push   %r12
    1ed8:	53                   	push   %rbx
    1ed9:	48 83 ec 08          	sub    $0x8,%rsp
	struct page *page = fio->encrypted_page ?
    1edd:	4c 8b 6f 30          	mov    0x30(%rdi),%r13
						fio->encrypted_page : fio->page;
    1ee1:	4d 85 ed             	test   %r13,%r13
    1ee4:	0f 84 78 02 00 00    	je     2162 <f2fs_submit_page_bio+0x2a2>

static inline void verify_block_addr(struct f2fs_io_info *fio, block_t blk_addr)
{
	struct f2fs_sb_info *sbi = fio->sbi;
	//TODO:此处META地址合法性以NVM布局为准[0,nvm-main_blkaddr)
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    1eea:	45 8b 4f 0c          	mov    0xc(%r15),%r9d
	verify_block_addr(fio, fio->new_blkaddr);
    1eee:	41 8b 77 1c          	mov    0x1c(%r15),%esi
	struct f2fs_sb_info *sbi = fio->sbi;
    1ef2:	49 8b 3f             	mov    (%r15),%rdi
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    1ef5:	41 83 f9 01          	cmp    $0x1,%r9d
    1ef9:	76 2e                	jbe    1f29 <f2fs_submit_page_bio+0x69>
    1efb:	41 8b 4f 14          	mov    0x14(%r15),%ecx
    1eff:	85 c9                	test   %ecx,%ecx
    1f01:	74 1f                	je     1f22 <f2fs_submit_page_bio+0x62>
	return (struct f2fs_sm_info *)(sbi->sm_info);
    1f03:	48 8b 47 68          	mov    0x68(%rdi),%rax
				(!is_read_io(fio->op) || fio->is_meta))
		BUG_ON(blk_addr < 0 ||
    1f07:	48 85 c0             	test   %rax,%rax
    1f0a:	0f 84 b5 03 00 00    	je     22c5 <f2fs_submit_page_bio+0x405>
    1f10:	8b 50 4c             	mov    0x4c(%rax),%edx
    1f13:	8b 87 24 04 00 00    	mov    0x424(%rdi),%eax
    1f19:	8d 04 42             	lea    (%rdx,%rax,2),%eax
    1f1c:	39 c6                	cmp    %eax,%esi
    1f1e:	72 39                	jb     1f59 <f2fs_submit_page_bio+0x99>
    1f20:	0f 0b                	ud2    
				(!is_read_io(fio->op) || fio->is_meta))
    1f22:	41 80 7f 51 00       	cmpb   $0x0,0x51(%r15)
    1f27:	75 da                	jne    1f03 <f2fs_submit_page_bio+0x43>
    1f29:	48 8b 57 68          	mov    0x68(%rdi),%rdx
				blk_addr >= (MAIN_BLKADDR(sbi))+MAIN_OFFSET*sbi->blocks_per_seg);
	else
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    1f2d:	48 85 d2             	test   %rdx,%rdx
    1f30:	0f 84 1a 03 00 00    	je     2250 <f2fs_submit_page_bio+0x390>
    1f36:	3b 72 4c             	cmp    0x4c(%rdx),%esi
    1f39:	0f 82 b4 03 00 00    	jb     22f3 <f2fs_submit_page_bio+0x433>
    1f3f:	44 8b 42 48          	mov    0x48(%rdx),%r8d
    1f43:	8b 42 54             	mov    0x54(%rdx),%eax
    1f46:	8b 8f 20 04 00 00    	mov    0x420(%rdi),%ecx
    1f4c:	d3 e0                	shl    %cl,%eax
    1f4e:	44 01 c0             	add    %r8d,%eax
    1f51:	39 c6                	cmp    %eax,%esi
    1f53:	0f 83 9a 03 00 00    	jae    22f3 <f2fs_submit_page_bio+0x433>
    1f59:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	bio = __bio_alloc(fio->sbi, fio->new_blkaddr, fio->io_wbc,
    1f5e:	41 8b 47 14          	mov    0x14(%r15),%eax
    1f62:	49 8b 57 58          	mov    0x58(%r15),%rdx
    1f66:	b9 01 00 00 00       	mov    $0x1,%ecx
    1f6b:	85 c0                	test   %eax,%eax
    1f6d:	41 8b 47 10          	mov    0x10(%r15),%eax
    1f71:	41 0f 94 c0          	sete   %r8b
    1f75:	50                   	push   %rax
    1f76:	45 0f b6 c0          	movzbl %r8b,%r8d
    1f7a:	e8 91 f7 ff ff       	callq  1710 <__bio_alloc>
	if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {
    1f7f:	ba 00 10 00 00       	mov    $0x1000,%edx
    1f84:	31 c9                	xor    %ecx,%ecx
    1f86:	4c 89 ee             	mov    %r13,%rsi
    1f89:	48 89 c7             	mov    %rax,%rdi
	bio = __bio_alloc(fio->sbi, fio->new_blkaddr, fio->io_wbc,
    1f8c:	49 89 c4             	mov    %rax,%r12
	if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE) {
    1f8f:	e8 00 00 00 00       	callq  1f94 <f2fs_submit_page_bio+0xd4>
    1f94:	5a                   	pop    %rdx
    1f95:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    1f9a:	0f 86 0b 04 00 00    	jbe    23ab <f2fs_submit_page_bio+0x4eb>
    1fa0:	41 8b 47 18          	mov    0x18(%r15),%eax
    1fa4:	41 0b 47 14          	or     0x14(%r15),%eax
    1fa8:	41 89 44 24 10       	mov    %eax,0x10(%r12)
	if (!fio->is_meta && fio->type == META) {
    1fad:	4d 8b 2f             	mov    (%r15),%r13
    1fb0:	0f b6 c0             	movzbl %al,%eax
    1fb3:	41 80 7f 51 00       	cmpb   $0x0,0x51(%r15)
    1fb8:	45 8b 77 0c          	mov    0xc(%r15),%r14d
    1fbc:	49 8b 75 00          	mov    0x0(%r13),%rsi
    1fc0:	75 0a                	jne    1fcc <f2fs_submit_page_bio+0x10c>
    1fc2:	41 83 fe 02          	cmp    $0x2,%r14d
    1fc6:	0f 84 e6 02 00 00    	je     22b2 <f2fs_submit_page_bio+0x3f2>
		if (type != DATA && type != NODE)
    1fcc:	41 83 fe 01          	cmp    $0x1,%r14d
    1fd0:	0f 87 7a 01 00 00    	ja     2150 <f2fs_submit_page_bio+0x290>
    1fd6:	85 c0                	test   %eax,%eax
    1fd8:	0f 85 92 00 00 00    	jne    2070 <f2fs_submit_page_bio+0x1b0>
    1fde:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    1fe3:	44 89 f2             	mov    %r14d,%edx
    1fe6:	4c 89 e6             	mov    %r12,%rsi
    1fe9:	4c 89 ef             	mov    %r13,%rdi
    1fec:	e8 00 00 00 00       	callq  1ff1 <f2fs_submit_page_bio+0x131>
	submit_bio(bio);//提交进行io操作
    1ff1:	4c 89 e7             	mov    %r12,%rdi
    1ff4:	e8 00 00 00 00       	callq  1ff9 <f2fs_submit_page_bio+0x139>
	if (!is_read_io(fio->op))
    1ff9:	41 8b 47 14          	mov    0x14(%r15),%eax
    1ffd:	85 c0                	test   %eax,%eax
    1fff:	0f 85 66 01 00 00    	jne    216b <f2fs_submit_page_bio+0x2ab>
}
    2005:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    2009:	5b                   	pop    %rbx
    200a:	41 5c                	pop    %r12
    200c:	41 5d                	pop    %r13
    200e:	41 5e                	pop    %r14
    2010:	41 5f                	pop    %r15
    2012:	5d                   	pop    %rbp
    2013:	c3                   	retq   
DEFINE_EVENT_CONDITION(f2fs__submit_page_bio, f2fs_submit_page_bio,
    2014:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 201b <f2fs_submit_page_bio+0x15b>
    201b:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    201d:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 2025 <f2fs_submit_page_bio+0x165>
    2024:	00 
    2025:	0f 83 33 ff ff ff    	jae    1f5e <f2fs_submit_page_bio+0x9e>
    202b:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
    2030:	0f 84 28 ff ff ff    	je     1f5e <f2fs_submit_page_bio+0x9e>
    2036:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 203d <f2fs_submit_page_bio+0x17d>
    203d:	48 85 db             	test   %rbx,%rbx
    2040:	74 1e                	je     2060 <f2fs_submit_page_bio+0x1a0>
    2042:	48 8b 03             	mov    (%rbx),%rax
    2045:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2049:	48 83 c3 18          	add    $0x18,%rbx
    204d:	4c 89 fa             	mov    %r15,%rdx
    2050:	4c 89 ee             	mov    %r13,%rsi
    2053:	e8 00 00 00 00       	callq  2058 <f2fs_submit_page_bio+0x198>
    2058:	48 8b 03             	mov    (%rbx),%rax
    205b:	48 85 c0             	test   %rax,%rax
    205e:	75 e5                	jne    2045 <f2fs_submit_page_bio+0x185>
    2060:	45 8b 4f 0c          	mov    0xc(%r15),%r9d
    2064:	41 8b 77 1c          	mov    0x1c(%r15),%esi
    2068:	49 8b 3f             	mov    (%r15),%rdi
}
    206b:	e9 ee fe ff ff       	jmpq   1f5e <f2fs_submit_page_bio+0x9e>
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
    2070:	48 8b 86 08 04 00 00 	mov    0x408(%rsi),%rax
    2077:	48 8b 40 10          	mov    0x10(%rax),%rax
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    207b:	f6 80 84 08 00 00 02 	testb  $0x2,0x884(%rax)
    2082:	0f 85 e1 01 00 00    	jne    2269 <f2fs_submit_page_bio+0x3a9>
		start %= F2FS_IO_SIZE(sbi);
    2088:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    208f:	41 8b 54 24 30       	mov    0x30(%r12),%edx
		start %= F2FS_IO_SIZE(sbi);
    2094:	b8 01 00 00 00       	mov    $0x1,%eax
    2099:	d3 e0                	shl    %cl,%eax
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    209b:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    209e:	8d 58 ff             	lea    -0x1(%rax),%ebx
		if (start == 0)
    20a1:	21 d3                	and    %edx,%ebx
    20a3:	0f 84 af 00 00 00    	je     2158 <f2fs_submit_page_bio+0x298>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    20a9:	39 d8                	cmp    %ebx,%eax
    20ab:	0f 86 89 00 00 00    	jbe    213a <f2fs_submit_page_bio+0x27a>
					mempool_alloc(sbi->write_io_dummy,
    20b1:	49 8b bd 70 01 00 00 	mov    0x170(%r13),%rdi
    20b8:	be 00 88 60 00       	mov    $0x608800,%esi
    20bd:	e8 00 00 00 00       	callq  20c2 <f2fs_submit_page_bio+0x202>
    20c2:	48 89 c6             	mov    %rax,%rsi
			f2fs_bug_on(sbi, !page);
    20c5:	48 85 c0             	test   %rax,%rax
    20c8:	0f 84 18 02 00 00    	je     22e6 <f2fs_submit_page_bio+0x426>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    20ce:	f0 80 4e 01 10       	lock orb $0x10,0x1(%rsi)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    20d3:	48 c7 46 28 fe ff ff 	movq   $0xfffffffffffffffe,0x28(%rsi)
    20da:	ff 
    20db:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	might_sleep();
    20df:	e8 00 00 00 00       	callq  20e4 <f2fs_submit_page_bio+0x224>
    20e4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    20e8:	48 8b 56 08          	mov    0x8(%rsi),%rdx
    20ec:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    20f0:	83 e2 01             	and    $0x1,%edx
    20f3:	48 0f 44 c6          	cmove  %rsi,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    20f7:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    20fd:	0f 82 ce 01 00 00    	jb     22d1 <f2fs_submit_page_bio+0x411>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    2103:	31 c9                	xor    %ecx,%ecx
    2105:	ba 00 10 00 00       	mov    $0x1000,%edx
    210a:	4c 89 e7             	mov    %r12,%rdi
    210d:	e8 00 00 00 00       	callq  2112 <f2fs_submit_page_bio+0x252>
    2112:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    2117:	77 08                	ja     2121 <f2fs_submit_page_bio+0x261>
				f2fs_bug_on(sbi, 1);
    2119:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    211b:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    2121:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
    2128:	b8 01 00 00 00       	mov    $0x1,%eax
    212d:	83 c3 01             	add    $0x1,%ebx
    2130:	d3 e0                	shl    %cl,%eax
    2132:	39 c3                	cmp    %eax,%ebx
    2134:	0f 82 77 ff ff ff    	jb     20b1 <f2fs_submit_page_bio+0x1f1>
		if (type == NODE)
    213a:	41 83 fe 01          	cmp    $0x1,%r14d
    213e:	75 06                	jne    2146 <f2fs_submit_page_bio+0x286>
    2140:	f0 41 80 4d 48 20    	lock orb $0x20,0x48(%r13)
    2146:	41 0f b6 44 24 10    	movzbl 0x10(%r12),%eax
    214c:	49 8b 75 00          	mov    0x0(%r13),%rsi
	if (is_read_io(bio_op(bio)))
    2150:	85 c0                	test   %eax,%eax
    2152:	0f 84 86 fe ff ff    	je     1fde <f2fs_submit_page_bio+0x11e>
    2158:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    215d:	e9 81 fe ff ff       	jmpq   1fe3 <f2fs_submit_page_bio+0x123>
						fio->encrypted_page : fio->page;
    2162:	4c 8b 6f 28          	mov    0x28(%rdi),%r13
    2166:	e9 7f fd ff ff       	jmpq   1eea <f2fs_submit_page_bio+0x2a>
		inc_page_count(fio->sbi, WB_DATA_TYPE(fio->page));
    216b:	49 8b 7f 28          	mov    0x28(%r15),%rdi
    216f:	e8 8c de ff ff       	callq  0 <__is_cp_guaranteed>
	atomic_inc(&sbi->nr_pages[count_type]);
    2174:	49 8b 17             	mov    (%r15),%rdx
    2177:	3c 01                	cmp    $0x1,%al
    2179:	48 19 c0             	sbb    %rax,%rax
    217c:	83 e0 04             	and    $0x4,%eax
    217f:	f0 ff 84 02 90 04 00 	lock incl 0x490(%rdx,%rax,1)
    2186:	00 
}
    2187:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
	return 0;
    218b:	31 c0                	xor    %eax,%eax
}
    218d:	5b                   	pop    %rbx
    218e:	41 5c                	pop    %r12
    2190:	41 5d                	pop    %r13
    2192:	41 5e                	pop    %r14
    2194:	41 5f                	pop    %r15
    2196:	5d                   	pop    %rbp
    2197:	c3                   	retq   
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    2198:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 219f <f2fs_submit_page_bio+0x2df>
    219f:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    21a1:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 21a9 <f2fs_submit_page_bio+0x2e9>
    21a8:	00 
    21a9:	0f 92 c0             	setb   %al
    21ac:	4d 85 e4             	test   %r12,%r12
    21af:	0f 84 2e fe ff ff    	je     1fe3 <f2fs_submit_page_bio+0x123>
    21b5:	84 c0                	test   %al,%al
    21b7:	0f 84 26 fe ff ff    	je     1fe3 <f2fs_submit_page_bio+0x123>
    21bd:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 21c4 <f2fs_submit_page_bio+0x304>
    21c4:	48 85 db             	test   %rbx,%rbx
    21c7:	74 26                	je     21ef <f2fs_submit_page_bio+0x32f>
    21c9:	48 8b 03             	mov    (%rbx),%rax
    21cc:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    21d0:	48 83 c3 18          	add    $0x18,%rbx
    21d4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    21d8:	4c 89 e1             	mov    %r12,%rcx
    21db:	44 89 f2             	mov    %r14d,%edx
    21de:	e8 00 00 00 00       	callq  21e3 <f2fs_submit_page_bio+0x323>
    21e3:	48 8b 03             	mov    (%rbx),%rax
    21e6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    21ea:	48 85 c0             	test   %rax,%rax
    21ed:	75 dd                	jne    21cc <f2fs_submit_page_bio+0x30c>
    21ef:	e9 ef fd ff ff       	jmpq   1fe3 <f2fs_submit_page_bio+0x123>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    21f4:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 21fb <f2fs_submit_page_bio+0x33b>
    21fb:	89 c0                	mov    %eax,%eax
    21fd:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 2205 <f2fs_submit_page_bio+0x345>
    2204:	00 
    2205:	0f 92 c0             	setb   %al
    2208:	4d 85 e4             	test   %r12,%r12
    220b:	0f 84 d2 fd ff ff    	je     1fe3 <f2fs_submit_page_bio+0x123>
    2211:	84 c0                	test   %al,%al
    2213:	0f 84 ca fd ff ff    	je     1fe3 <f2fs_submit_page_bio+0x123>
    2219:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 2220 <f2fs_submit_page_bio+0x360>
    2220:	48 85 db             	test   %rbx,%rbx
    2223:	74 ca                	je     21ef <f2fs_submit_page_bio+0x32f>
    2225:	48 8b 03             	mov    (%rbx),%rax
    2228:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    222c:	48 83 c3 18          	add    $0x18,%rbx
    2230:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    2234:	4c 89 e1             	mov    %r12,%rcx
    2237:	44 89 f2             	mov    %r14d,%edx
    223a:	e8 00 00 00 00       	callq  223f <f2fs_submit_page_bio+0x37f>
    223f:	48 8b 03             	mov    (%rbx),%rax
    2242:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    2246:	48 85 c0             	test   %rax,%rax
    2249:	75 dd                	jne    2228 <f2fs_submit_page_bio+0x368>
	preempt_enable_notrace();
    224b:	e9 93 fd ff ff       	jmpq   1fe3 <f2fs_submit_page_bio+0x123>
	return (struct f2fs_super_block *)(sbi->raw_super);
    2250:	48 8b 47 10          	mov    0x10(%rdi),%rax
    2254:	3b 70 5c             	cmp    0x5c(%rax),%esi
    2257:	0f 82 96 00 00 00    	jb     22f3 <f2fs_submit_page_bio+0x433>
    225d:	44 8b 40 48          	mov    0x48(%rax),%r8d
    2261:	8b 40 30             	mov    0x30(%rax),%eax
    2264:	e9 dd fc ff ff       	jmpq   1f46 <f2fs_submit_page_bio+0x86>
    2269:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    2270:	00 00 
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    2272:	48 83 b8 48 0b 00 00 	cmpq   $0x0,0xb48(%rax)
    2279:	00 
    227a:	0f 84 08 fe ff ff    	je     2088 <f2fs_submit_page_bio+0x1c8>
			blk_finish_plug(current->plug);
    2280:	48 8b b8 48 0b 00 00 	mov    0xb48(%rax),%rdi
    2287:	e8 00 00 00 00       	callq  228c <f2fs_submit_page_bio+0x3cc>
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    228c:	41 8b 54 24 30       	mov    0x30(%r12),%edx
		start %= F2FS_IO_SIZE(sbi);
    2291:	b8 01 00 00 00       	mov    $0x1,%eax
    2296:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
    229d:	d3 e0                	shl    %cl,%eax
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    229f:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    22a2:	8d 58 ff             	lea    -0x1(%rax),%ebx
		if (start == 0)
    22a5:	21 d3                	and    %edx,%ebx
    22a7:	0f 85 fc fd ff ff    	jne    20a9 <f2fs_submit_page_bio+0x1e9>
    22ad:	e9 94 fe ff ff       	jmpq   2146 <f2fs_submit_page_bio+0x286>
	if (is_read_io(bio_op(bio)))
    22b2:	85 c0                	test   %eax,%eax
    22b4:	75 3f                	jne    22f5 <f2fs_submit_page_bio+0x435>
    22b6:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    22bb:	ba 03 00 00 00       	mov    $0x3,%edx
    22c0:	e9 21 fd ff ff       	jmpq   1fe6 <f2fs_submit_page_bio+0x126>
		BUG_ON(blk_addr < 0 ||
    22c5:	48 8b 47 10          	mov    0x10(%rdi),%rax
    22c9:	8b 50 5c             	mov    0x5c(%rax),%edx
    22cc:	e9 42 fc ff ff       	jmpq   1f13 <f2fs_submit_page_bio+0x53>
		__lock_page(page);
    22d1:	48 89 f7             	mov    %rsi,%rdi
    22d4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    22d8:	e8 00 00 00 00       	callq  22dd <f2fs_submit_page_bio+0x41d>
    22dd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    22e1:	e9 1d fe ff ff       	jmpq   2103 <f2fs_submit_page_bio+0x243>
			f2fs_bug_on(sbi, !page);
    22e6:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    22e8:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
}
    22ee:	e9 db fd ff ff       	jmpq   20ce <f2fs_submit_page_bio+0x20e>
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    22f3:	0f 0b                	ud2    
    22f5:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    22fa:	eb bf                	jmp    22bb <f2fs_submit_page_bio+0x3fb>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    22fc:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 2303 <f2fs_submit_page_bio+0x443>
    2303:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    2305:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 230d <f2fs_submit_page_bio+0x44d>
    230c:	00 
    230d:	73 ac                	jae    22bb <f2fs_submit_page_bio+0x3fb>
    230f:	4d 85 e4             	test   %r12,%r12
    2312:	74 a7                	je     22bb <f2fs_submit_page_bio+0x3fb>
    2314:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 231b <f2fs_submit_page_bio+0x45b>
    231b:	48 85 db             	test   %rbx,%rbx
    231e:	74 28                	je     2348 <f2fs_submit_page_bio+0x488>
    2320:	48 8b 03             	mov    (%rbx),%rax
    2323:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2327:	48 83 c3 18          	add    $0x18,%rbx
    232b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    232f:	4c 89 e1             	mov    %r12,%rcx
    2332:	ba 03 00 00 00       	mov    $0x3,%edx
    2337:	e8 00 00 00 00       	callq  233c <f2fs_submit_page_bio+0x47c>
    233c:	48 8b 03             	mov    (%rbx),%rax
    233f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    2343:	48 85 c0             	test   %rax,%rax
    2346:	75 db                	jne    2323 <f2fs_submit_page_bio+0x463>
}
    2348:	e9 6e ff ff ff       	jmpq   22bb <f2fs_submit_page_bio+0x3fb>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    234d:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 2354 <f2fs_submit_page_bio+0x494>
    2354:	89 c0                	mov    %eax,%eax
    2356:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 235e <f2fs_submit_page_bio+0x49e>
    235d:	00 
    235e:	0f 92 c0             	setb   %al
    2361:	4d 85 e4             	test   %r12,%r12
    2364:	0f 84 51 ff ff ff    	je     22bb <f2fs_submit_page_bio+0x3fb>
    236a:	84 c0                	test   %al,%al
    236c:	0f 84 49 ff ff ff    	je     22bb <f2fs_submit_page_bio+0x3fb>
    2372:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 2379 <f2fs_submit_page_bio+0x4b9>
    2379:	48 85 db             	test   %rbx,%rbx
    237c:	74 ca                	je     2348 <f2fs_submit_page_bio+0x488>
    237e:	48 8b 03             	mov    (%rbx),%rax
    2381:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2385:	48 83 c3 18          	add    $0x18,%rbx
    2389:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    238d:	4c 89 e1             	mov    %r12,%rcx
    2390:	ba 03 00 00 00       	mov    $0x3,%edx
    2395:	e8 00 00 00 00       	callq  239a <f2fs_submit_page_bio+0x4da>
    239a:	48 8b 03             	mov    (%rbx),%rax
    239d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    23a1:	48 85 c0             	test   %rax,%rax
    23a4:	75 db                	jne    2381 <f2fs_submit_page_bio+0x4c1>
	preempt_enable_notrace();
    23a6:	e9 10 ff ff ff       	jmpq   22bb <f2fs_submit_page_bio+0x3fb>
		bio_put(bio);
    23ab:	4c 89 e7             	mov    %r12,%rdi
    23ae:	e8 00 00 00 00       	callq  23b3 <f2fs_submit_page_bio+0x4f3>
		return -EFAULT;
    23b3:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    23b8:	e9 48 fc ff ff       	jmpq   2005 <f2fs_submit_page_bio+0x145>
    23bd:	0f 1f 00             	nopl   (%rax)

00000000000023c0 <f2fs_submit_page_write>:
void f2fs_submit_page_write(struct f2fs_io_info *fio) {
    23c0:	f3 0f 1e fa          	endbr64 
    23c4:	e8 00 00 00 00       	callq  23c9 <f2fs_submit_page_write+0x9>
    23c9:	55                   	push   %rbp
	enum page_type btype = PAGE_TYPE_OF_BIO(fio->type);
    23ca:	b8 02 00 00 00       	mov    $0x2,%eax
void f2fs_submit_page_write(struct f2fs_io_info *fio) {
    23cf:	48 89 e5             	mov    %rsp,%rbp
    23d2:	41 57                	push   %r15
    23d4:	49 89 ff             	mov    %rdi,%r15
    23d7:	41 56                	push   %r14
    23d9:	41 55                	push   %r13
    23db:	41 54                	push   %r12
    23dd:	53                   	push   %rbx
    23de:	48 83 ec 20          	sub    $0x20,%rsp
	enum page_type btype = PAGE_TYPE_OF_BIO(fio->type);
    23e2:	8b 4f 0c             	mov    0xc(%rdi),%ecx
	struct f2fs_sb_info *sbi = fio->sbi;
    23e5:	48 8b 1f             	mov    (%rdi),%rbx
	struct f2fs_bio_info *io = sbi->write_io[btype] + fio->temp;
    23e8:	44 8b 5f 10          	mov    0x10(%rdi),%r11d
	f2fs_bug_on(sbi, is_read_io(fio->op));
    23ec:	8b 57 14             	mov    0x14(%rdi),%edx
	enum page_type btype = PAGE_TYPE_OF_BIO(fio->type);
    23ef:	83 f9 02             	cmp    $0x2,%ecx
    23f2:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    23f5:	48 0f 46 c1          	cmovbe %rcx,%rax
	struct f2fs_bio_info *io = sbi->write_io[btype] + fio->temp;
    23f9:	4d 69 db b8 00 00 00 	imul   $0xb8,%r11,%r11
    2400:	4c 03 5c c3 70       	add    0x70(%rbx,%rax,8),%r11
    2405:	4d 89 de             	mov    %r11,%r14
	f2fs_bug_on(sbi, is_read_io(fio->op));
    2408:	85 d2                	test   %edx,%edx
    240a:	0f 84 96 04 00 00    	je     28a6 <f2fs_submit_page_write+0x4e6>
	down_write(&io->io_rwsem);
    2410:	49 8d 46 78          	lea    0x78(%r14),%rax
    2414:	48 89 c7             	mov    %rax,%rdi
    2417:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    241b:	e8 00 00 00 00       	callq  2420 <f2fs_submit_page_write+0x60>
	if (fio->in_list) {
    2420:	41 80 7f 50 00       	cmpb   $0x0,0x50(%r15)
    2425:	0f 85 13 02 00 00    	jne    263e <f2fs_submit_page_write+0x27e>
	if (is_valid_blkaddr(fio->old_blkaddr))
    242b:	41 8b 77 20          	mov    0x20(%r15),%esi
	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
    242f:	49 8b 17             	mov    (%r15),%rdx
    2432:	41 8b 7f 0c          	mov    0xc(%r15),%edi
    2436:	8d 4e ff             	lea    -0x1(%rsi),%ecx
    2439:	48 8b 42 68          	mov    0x68(%rdx),%rax
    243d:	83 f9 fd             	cmp    $0xfffffffd,%ecx
    2440:	77 4b                	ja     248d <f2fs_submit_page_write+0xcd>
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    2442:	83 ff 01             	cmp    $0x1,%edi
    2445:	76 17                	jbe    245e <f2fs_submit_page_write+0x9e>
				(!is_read_io(fio->op) || fio->is_meta))
    2447:	41 8b 4f 14          	mov    0x14(%r15),%ecx
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    244b:	85 c9                	test   %ecx,%ecx
    244d:	0f 85 50 02 00 00    	jne    26a3 <f2fs_submit_page_write+0x2e3>
				(!is_read_io(fio->op) || fio->is_meta))
    2453:	41 80 7f 51 00       	cmpb   $0x0,0x51(%r15)
    2458:	0f 85 45 02 00 00    	jne    26a3 <f2fs_submit_page_write+0x2e3>
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    245e:	48 85 c0             	test   %rax,%rax
    2461:	0f 84 96 03 00 00    	je     27fd <f2fs_submit_page_write+0x43d>
    2467:	3b 70 4c             	cmp    0x4c(%rax),%esi
    246a:	0f 82 09 04 00 00    	jb     2879 <f2fs_submit_page_write+0x4b9>
    2470:	44 8b 48 48          	mov    0x48(%rax),%r9d
    2474:	44 8b 40 54          	mov    0x54(%rax),%r8d
    2478:	8b 8a 20 04 00 00    	mov    0x420(%rdx),%ecx
    247e:	41 d3 e0             	shl    %cl,%r8d
    2481:	45 01 c8             	add    %r9d,%r8d
    2484:	44 39 c6             	cmp    %r8d,%esi
    2487:	0f 83 ec 03 00 00    	jae    2879 <f2fs_submit_page_write+0x4b9>
	verify_block_addr(fio, fio->new_blkaddr);
    248d:	41 8b 77 1c          	mov    0x1c(%r15),%esi
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    2491:	83 ff 01             	cmp    $0x1,%edi
    2494:	0f 87 b2 02 00 00    	ja     274c <f2fs_submit_page_write+0x38c>
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    249a:	48 85 c0             	test   %rax,%rax
    249d:	0f 84 2b 03 00 00    	je     27ce <f2fs_submit_page_write+0x40e>
    24a3:	39 70 4c             	cmp    %esi,0x4c(%rax)
    24a6:	0f 87 43 03 00 00    	ja     27ef <f2fs_submit_page_write+0x42f>
    24ac:	8b 78 48             	mov    0x48(%rax),%edi
    24af:	8b 8a 20 04 00 00    	mov    0x420(%rdx),%ecx
    24b5:	8b 40 54             	mov    0x54(%rax),%eax
    24b8:	d3 e0                	shl    %cl,%eax
    24ba:	01 f8                	add    %edi,%eax
    24bc:	39 f0                	cmp    %esi,%eax
    24be:	0f 86 2b 03 00 00    	jbe    27ef <f2fs_submit_page_write+0x42f>
	bio_page = fio->encrypted_page ? fio->encrypted_page : fio->page;
    24c4:	4d 8b 67 30          	mov    0x30(%r15),%r12
    24c8:	4d 85 e4             	test   %r12,%r12
    24cb:	0f 84 84 02 00 00    	je     2755 <f2fs_submit_page_write+0x395>
	fio->submitted = true;
    24d1:	41 c6 47 48 01       	movb   $0x1,0x48(%r15)
	inc_page_count(sbi, WB_DATA_TYPE(bio_page));
    24d6:	4c 89 e7             	mov    %r12,%rdi
    24d9:	e8 22 db ff ff       	callq  0 <__is_cp_guaranteed>
    24de:	3c 01                	cmp    $0x1,%al
    24e0:	48 19 c0             	sbb    %rax,%rax
    24e3:	83 e0 04             	and    $0x4,%eax
    24e6:	f0 ff 84 03 90 04 00 	lock incl 0x490(%rbx,%rax,1)
    24ed:	00 
	if (io->bio && (io->last_block_in_bio != fio->new_blkaddr - 1 ||
    24ee:	4d 8b 6e 08          	mov    0x8(%r14),%r13
    24f2:	4d 89 e8             	mov    %r13,%r8
    24f5:	4d 85 ed             	test   %r13,%r13
    24f8:	74 37                	je     2531 <f2fs_submit_page_write+0x171>
    24fa:	41 8b 77 1c          	mov    0x1c(%r15),%esi
    24fe:	4d 8b 4e 10          	mov    0x10(%r14),%r9
    2502:	8d 46 ff             	lea    -0x1(%rsi),%eax
    2505:	49 39 c1             	cmp    %rax,%r9
    2508:	75 0e                	jne    2518 <f2fs_submit_page_write+0x158>
    250a:	41 8b 47 14          	mov    0x14(%r15),%eax
    250e:	41 39 46 2c          	cmp    %eax,0x2c(%r14)
    2512:	0f 84 fb 02 00 00    	je     2813 <f2fs_submit_page_write+0x453>
		__submit_merged_bio(io);
    2518:	4c 89 f7             	mov    %r14,%rdi
    251b:	e8 d0 db ff ff       	callq  f0 <__submit_merged_bio>
    2520:	4d 8b 6e 08          	mov    0x8(%r14),%r13
	if (btype != META && io->bio) {
    2524:	83 7d d4 01          	cmpl   $0x1,-0x2c(%rbp)
    2528:	4d 89 e8             	mov    %r13,%r8
    252b:	0f 86 2d 02 00 00    	jbe    275e <f2fs_submit_page_write+0x39e>
			fio->new_blkaddr & F2FS_IO_SIZE_MASK(sbi)) {
    2531:	41 bd 01 00 00 00    	mov    $0x1,%r13d
    2537:	eb 29                	jmp    2562 <f2fs_submit_page_write+0x1a2>
	if (bio_add_page(io->bio, bio_page, PAGE_SIZE, 0) < PAGE_SIZE) {
    2539:	31 c9                	xor    %ecx,%ecx
    253b:	ba 00 10 00 00       	mov    $0x1000,%edx
    2540:	4c 89 e6             	mov    %r12,%rsi
    2543:	4c 89 c7             	mov    %r8,%rdi
    2546:	e8 00 00 00 00       	callq  254b <f2fs_submit_page_write+0x18b>
    254b:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    2550:	0f 87 ba 00 00 00    	ja     2610 <f2fs_submit_page_write+0x250>
		__submit_merged_bio(io);
    2556:	4c 89 f7             	mov    %r14,%rdi
    2559:	e8 92 db ff ff       	callq  f0 <__submit_merged_bio>
		goto alloc_new;
    255e:	4d 8b 46 08          	mov    0x8(%r14),%r8
	if (io->bio == NULL) {
    2562:	4d 85 c0             	test   %r8,%r8
    2565:	75 d2                	jne    2539 <f2fs_submit_page_write+0x179>
		if ((fio->type == DATA || fio->type == NODE) &&
    2567:	45 8b 4f 0c          	mov    0xc(%r15),%r9d
    256b:	41 8b 77 1c          	mov    0x1c(%r15),%esi
    256f:	41 83 f9 01          	cmp    $0x1,%r9d
    2573:	77 16                	ja     258b <f2fs_submit_page_write+0x1cb>
			fio->new_blkaddr & F2FS_IO_SIZE_MASK(sbi)) {
    2575:	8b 8b f4 04 00 00    	mov    0x4f4(%rbx),%ecx
    257b:	44 89 e8             	mov    %r13d,%eax
    257e:	d3 e0                	shl    %cl,%eax
    2580:	83 e8 01             	sub    $0x1,%eax
		if ((fio->type == DATA || fio->type == NODE) &&
    2583:	85 f0                	test   %esi,%eax
    2585:	0f 85 21 02 00 00    	jne    27ac <f2fs_submit_page_write+0x3ec>
		io->bio = __bio_alloc(sbi, fio->new_blkaddr, fio->io_wbc,
    258b:	41 8b 47 10          	mov    0x10(%r15),%eax
    258f:	49 8b 57 58          	mov    0x58(%r15),%rdx
    2593:	45 31 c0             	xor    %r8d,%r8d
    2596:	b9 00 02 00 00       	mov    $0x200,%ecx
    259b:	48 89 df             	mov    %rbx,%rdi
    259e:	50                   	push   %rax
    259f:	e8 6c f1 ff ff       	callq  1710 <__bio_alloc>
    25a4:	49 89 46 08          	mov    %rax,0x8(%r14)
    25a8:	49 89 c0             	mov    %rax,%r8
		io->fio = *fio;
    25ab:	49 8b 07             	mov    (%r15),%rax
    25ae:	49 89 46 18          	mov    %rax,0x18(%r14)
    25b2:	49 8b 47 08          	mov    0x8(%r15),%rax
    25b6:	49 89 46 20          	mov    %rax,0x20(%r14)
    25ba:	49 8b 47 10          	mov    0x10(%r15),%rax
    25be:	49 89 46 28          	mov    %rax,0x28(%r14)
    25c2:	49 8b 47 18          	mov    0x18(%r15),%rax
    25c6:	49 89 46 30          	mov    %rax,0x30(%r14)
    25ca:	49 8b 47 20          	mov    0x20(%r15),%rax
    25ce:	49 89 46 38          	mov    %rax,0x38(%r14)
    25d2:	49 8b 47 28          	mov    0x28(%r15),%rax
    25d6:	49 89 46 40          	mov    %rax,0x40(%r14)
    25da:	49 8b 47 30          	mov    0x30(%r15),%rax
    25de:	49 89 46 48          	mov    %rax,0x48(%r14)
    25e2:	49 8b 47 38          	mov    0x38(%r15),%rax
    25e6:	49 89 46 50          	mov    %rax,0x50(%r14)
    25ea:	49 8b 47 40          	mov    0x40(%r15),%rax
    25ee:	49 89 46 58          	mov    %rax,0x58(%r14)
    25f2:	49 8b 47 48          	mov    0x48(%r15),%rax
    25f6:	49 89 46 60          	mov    %rax,0x60(%r14)
    25fa:	49 8b 47 50          	mov    0x50(%r15),%rax
    25fe:	49 89 46 68          	mov    %rax,0x68(%r14)
    2602:	49 8b 47 58          	mov    0x58(%r15),%rax
    2606:	49 89 46 70          	mov    %rax,0x70(%r14)
    260a:	58                   	pop    %rax
    260b:	e9 29 ff ff ff       	jmpq   2539 <f2fs_submit_page_write+0x179>
	if (fio->io_wbc)
    2610:	49 8b 7f 58          	mov    0x58(%r15),%rdi
    2614:	48 85 ff             	test   %rdi,%rdi
    2617:	74 0d                	je     2626 <f2fs_submit_page_write+0x266>
		wbc_account_io(fio->io_wbc, bio_page, PAGE_SIZE);
    2619:	ba 00 10 00 00       	mov    $0x1000,%edx
    261e:	4c 89 e6             	mov    %r12,%rsi
    2621:	e8 00 00 00 00       	callq  2626 <f2fs_submit_page_write+0x266>
	io->last_block_in_bio = fio->new_blkaddr;
    2626:	41 8b 47 1c          	mov    0x1c(%r15),%eax
    262a:	49 89 46 10          	mov    %rax,0x10(%r14)
    262e:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	if (fio->in_list)
    2633:	41 80 7f 50 00       	cmpb   $0x0,0x50(%r15)
    2638:	0f 84 50 02 00 00    	je     288e <f2fs_submit_page_write+0x4ce>
    263e:	4d 8d a6 a0 00 00 00 	lea    0xa0(%r14),%r12
    2645:	4c 89 e7             	mov    %r12,%rdi
    2648:	e8 00 00 00 00       	callq  264d <f2fs_submit_page_write+0x28d>
    264d:	49 8b 86 a8 00 00 00 	mov    0xa8(%r14),%rax
		if (list_empty(&io->io_list)) {
    2654:	49 8d 96 a8 00 00 00 	lea    0xa8(%r14),%rdx
    265b:	48 39 c2             	cmp    %rax,%rdx
    265e:	0f 84 20 02 00 00    	je     2884 <f2fs_submit_page_write+0x4c4>
		fio = list_first_entry(&io->io_list,
    2664:	49 8b 96 a8 00 00 00 	mov    0xa8(%r14),%rdx
    266b:	4c 89 e7             	mov    %r12,%rdi
static inline void __list_del_entry(struct list_head *entry)
{
	if (!__list_del_entry_valid(entry))
		return;

	__list_del(entry->prev, entry->next);
    266e:	48 8b 42 08          	mov    0x8(%rdx),%rax
    2672:	48 8b 0a             	mov    (%rdx),%rcx
    2675:	4c 8d 7a c8          	lea    -0x38(%rdx),%r15
	next->prev = prev;
    2679:	48 89 41 08          	mov    %rax,0x8(%rcx)
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
    267d:	48 89 08             	mov    %rcx,(%rax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del_entry(entry);
	entry->next = LIST_POISON1;
    2680:	48 b8 00 01 00 00 00 	movabs $0xdead000000000100,%rax
    2687:	00 ad de 
    268a:	48 89 02             	mov    %rax,(%rdx)
	entry->prev = LIST_POISON2;
    268d:	48 05 00 01 00 00    	add    $0x100,%rax
    2693:	48 89 42 08          	mov    %rax,0x8(%rdx)
    2697:	ff 14 25 00 00 00 00 	callq  *0x0
} while (0)

static __always_inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
}
    269e:	e9 88 fd ff ff       	jmpq   242b <f2fs_submit_page_write+0x6b>
		BUG_ON(blk_addr < 0 ||
    26a3:	48 85 c0             	test   %rax,%rax
    26a6:	0f 84 b1 01 00 00    	je     285d <f2fs_submit_page_write+0x49d>
    26ac:	44 8b 40 4c          	mov    0x4c(%rax),%r8d
    26b0:	8b ba 24 04 00 00    	mov    0x424(%rdx),%edi
    26b6:	41 8d 3c 78          	lea    (%r8,%rdi,2),%edi
    26ba:	39 fe                	cmp    %edi,%esi
    26bc:	0f 83 b5 01 00 00    	jae    2877 <f2fs_submit_page_write+0x4b7>
	verify_block_addr(fio, fio->new_blkaddr);
    26c2:	41 8b 77 1c          	mov    0x1c(%r15),%esi
	if (PAGE_TYPE_OF_BIO(fio->type) == META &&
    26c6:	85 c9                	test   %ecx,%ecx
    26c8:	75 0b                	jne    26d5 <f2fs_submit_page_write+0x315>
				(!is_read_io(fio->op) || fio->is_meta))
    26ca:	41 80 7f 51 00       	cmpb   $0x0,0x51(%r15)
    26cf:	0f 84 c5 fd ff ff    	je     249a <f2fs_submit_page_write+0xda>
		BUG_ON(blk_addr < 0 ||
    26d5:	48 85 c0             	test   %rax,%rax
    26d8:	0f 84 13 01 00 00    	je     27f1 <f2fs_submit_page_write+0x431>
    26de:	8b 48 4c             	mov    0x4c(%rax),%ecx
    26e1:	8b 82 24 04 00 00    	mov    0x424(%rdx),%eax
    26e7:	8d 04 41             	lea    (%rcx,%rax,2),%eax
    26ea:	39 f0                	cmp    %esi,%eax
    26ec:	0f 87 d2 fd ff ff    	ja     24c4 <f2fs_submit_page_write+0x104>
    26f2:	0f 0b                	ud2    
DEFINE_EVENT_CONDITION(f2fs__submit_page_bio, f2fs_submit_page_write,
    26f4:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 26fb <f2fs_submit_page_write+0x33b>
    26fb:	89 c0                	mov    %eax,%eax
    26fd:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 2705 <f2fs_submit_page_write+0x345>
    2704:	00 
    2705:	0f 83 28 ff ff ff    	jae    2633 <f2fs_submit_page_write+0x273>
	trace_f2fs_submit_page_write(fio->page, fio);
    270b:	4d 8b 6f 28          	mov    0x28(%r15),%r13
    270f:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
    2714:	0f 84 19 ff ff ff    	je     2633 <f2fs_submit_page_write+0x273>
	__READ_ONCE_SIZE;
    271a:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 2721 <f2fs_submit_page_write+0x361>
    2721:	4d 85 e4             	test   %r12,%r12
    2724:	74 21                	je     2747 <f2fs_submit_page_write+0x387>
    2726:	49 8b 04 24          	mov    (%r12),%rax
    272a:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    272f:	49 83 c4 18          	add    $0x18,%r12
    2733:	4c 89 fa             	mov    %r15,%rdx
    2736:	4c 89 ee             	mov    %r13,%rsi
    2739:	e8 00 00 00 00       	callq  273e <f2fs_submit_page_write+0x37e>
    273e:	49 8b 04 24          	mov    (%r12),%rax
    2742:	48 85 c0             	test   %rax,%rax
    2745:	75 e3                	jne    272a <f2fs_submit_page_write+0x36a>
}
    2747:	e9 e7 fe ff ff       	jmpq   2633 <f2fs_submit_page_write+0x273>
    274c:	41 8b 4f 14          	mov    0x14(%r15),%ecx
    2750:	e9 71 ff ff ff       	jmpq   26c6 <f2fs_submit_page_write+0x306>
	bio_page = fio->encrypted_page ? fio->encrypted_page : fio->page;
    2755:	4d 8b 67 28          	mov    0x28(%r15),%r12
    2759:	e9 73 fd ff ff       	jmpq   24d1 <f2fs_submit_page_write+0x111>
	if (btype != META && io->bio) {
    275e:	4d 85 ed             	test   %r13,%r13
    2761:	0f 84 ca fd ff ff    	je     2531 <f2fs_submit_page_write+0x171>
    2767:	41 8b 77 1c          	mov    0x1c(%r15),%esi
    276b:	4d 8b 4e 10          	mov    0x10(%r14),%r9
	return (struct f2fs_sm_info *)(sbi->sm_info);
    276f:	48 8b 43 68          	mov    0x68(%rbx),%rax
    2773:	8b 8b 20 04 00 00    	mov    0x420(%rbx),%ecx
		unsigned int main_segno = GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
    2779:	48 85 c0             	test   %rax,%rax
    277c:	0f 84 f9 00 00 00    	je     287b <f2fs_submit_page_write+0x4bb>
    2782:	8b 50 48             	mov    0x48(%rax),%edx
		if (old_segno != new_segno) {
    2785:	4d 89 e8             	mov    %r13,%r8
		unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, io->last_block_in_bio);
    2788:	49 29 d1             	sub    %rdx,%r9
		unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, fio->new_blkaddr);
    278b:	29 d6                	sub    %edx,%esi
		unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, io->last_block_in_bio);
    278d:	49 d3 e9             	shr    %cl,%r9
		unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, fio->new_blkaddr);
    2790:	d3 ee                	shr    %cl,%esi
		if (old_segno != new_segno) {
    2792:	44 39 ce             	cmp    %r9d,%esi
    2795:	0f 84 96 fd ff ff    	je     2531 <f2fs_submit_page_write+0x171>
			__submit_merged_bio(io);
    279b:	4c 89 f7             	mov    %r14,%rdi
    279e:	e8 4d d9 ff ff       	callq  f0 <__submit_merged_bio>
    27a3:	4d 8b 46 08          	mov    0x8(%r14),%r8
    27a7:	e9 85 fd ff ff       	jmpq   2531 <f2fs_submit_page_write+0x171>
			dec_page_count(sbi, WB_DATA_TYPE(bio_page));
    27ac:	4c 89 e7             	mov    %r12,%rdi
    27af:	e8 4c d8 ff ff       	callq  0 <__is_cp_guaranteed>
    27b4:	3c 01                	cmp    $0x1,%al
    27b6:	48 19 c0             	sbb    %rax,%rax
    27b9:	83 e0 04             	and    $0x4,%eax
	asm volatile(LOCK_PREFIX "decl %0"
    27bc:	f0 ff 8c 03 90 04 00 	lock decl 0x490(%rbx,%rax,1)
    27c3:	00 
			fio->retry = true;
    27c4:	41 c6 47 52 01       	movb   $0x1,0x52(%r15)
			goto skip;
    27c9:	e9 65 fe ff ff       	jmpq   2633 <f2fs_submit_page_write+0x273>
	return (struct f2fs_super_block *)(sbi->raw_super);
    27ce:	48 8b 42 10          	mov    0x10(%rdx),%rax
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    27d2:	39 70 5c             	cmp    %esi,0x5c(%rax)
    27d5:	77 18                	ja     27ef <f2fs_submit_page_write+0x42f>
    27d7:	8b 78 48             	mov    0x48(%rax),%edi
    27da:	8b 8a 20 04 00 00    	mov    0x420(%rdx),%ecx
    27e0:	8b 40 30             	mov    0x30(%rax),%eax
    27e3:	d3 e0                	shl    %cl,%eax
    27e5:	01 f8                	add    %edi,%eax
    27e7:	39 f0                	cmp    %esi,%eax
    27e9:	0f 87 d5 fc ff ff    	ja     24c4 <f2fs_submit_page_write+0x104>
    27ef:	0f 0b                	ud2    
		BUG_ON(blk_addr < 0 ||
    27f1:	48 8b 42 10          	mov    0x10(%rdx),%rax
    27f5:	8b 48 5c             	mov    0x5c(%rax),%ecx
    27f8:	e9 e4 fe ff ff       	jmpq   26e1 <f2fs_submit_page_write+0x321>
    27fd:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    2801:	3b 71 5c             	cmp    0x5c(%rcx),%esi
    2804:	72 73                	jb     2879 <f2fs_submit_page_write+0x4b9>
    2806:	44 8b 49 48          	mov    0x48(%rcx),%r9d
    280a:	44 8b 41 30          	mov    0x30(%rcx),%r8d
    280e:	e9 65 fc ff ff       	jmpq   2478 <f2fs_submit_page_write+0xb8>
					(io->fio.op != fio->op || io->fio.op_flags != fio->op_flags) ||
    2813:	41 8b 47 18          	mov    0x18(%r15),%eax
    2817:	41 39 46 30          	cmp    %eax,0x30(%r14)
    281b:	0f 85 f7 fc ff ff    	jne    2518 <f2fs_submit_page_write+0x158>
					!__same_bdev(sbi, fio->new_blkaddr, io->bio)))
    2821:	49 8d 4d 1b          	lea    0x1b(%r13),%rcx
    2825:	49 8d 55 08          	lea    0x8(%r13),%rdx
    2829:	48 89 df             	mov    %rbx,%rdi
    282c:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    2830:	89 75 d0             	mov    %esi,-0x30(%rbp)
    2833:	4c 89 6d c0          	mov    %r13,-0x40(%rbp)
    2837:	e8 d4 eb ff ff       	callq  1410 <__same_bdev.isra.0>
					(io->fio.op != fio->op || io->fio.op_flags != fio->op_flags) ||
    283c:	8b 75 d0             	mov    -0x30(%rbp),%esi
    283f:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
    2843:	4d 89 e8             	mov    %r13,%r8
    2846:	84 c0                	test   %al,%al
    2848:	0f 84 ca fc ff ff    	je     2518 <f2fs_submit_page_write+0x158>
	if (btype != META && io->bio) {
    284e:	83 7d d4 01          	cmpl   $0x1,-0x2c(%rbp)
    2852:	0f 87 d9 fc ff ff    	ja     2531 <f2fs_submit_page_write+0x171>
    2858:	e9 12 ff ff ff       	jmpq   276f <f2fs_submit_page_write+0x3af>
		BUG_ON(blk_addr < 0 ||
    285d:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
    2861:	44 8b 47 5c          	mov    0x5c(%rdi),%r8d
    2865:	8b ba 24 04 00 00    	mov    0x424(%rdx),%edi
    286b:	41 8d 3c 78          	lea    (%r8,%rdi,2),%edi
    286f:	39 fe                	cmp    %edi,%esi
    2871:	0f 82 4b fe ff ff    	jb     26c2 <f2fs_submit_page_write+0x302>
    2877:	0f 0b                	ud2    
		BUG_ON(blk_addr < MAIN_BLKADDR(sbi) ||
    2879:	0f 0b                	ud2    
		unsigned int main_segno = GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
    287b:	48 8b 43 10          	mov    0x10(%rbx),%rax
    287f:	e9 fe fe ff ff       	jmpq   2782 <f2fs_submit_page_write+0x3c2>
    2884:	4c 89 e7             	mov    %r12,%rdi
    2887:	ff 14 25 00 00 00 00 	callq  *0x0
	up_write(&io->io_rwsem);
    288e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    2892:	e8 00 00 00 00       	callq  2897 <f2fs_submit_page_write+0x4d7>
}
    2897:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    289b:	5b                   	pop    %rbx
    289c:	41 5c                	pop    %r12
    289e:	41 5d                	pop    %r13
    28a0:	41 5e                	pop    %r14
    28a2:	41 5f                	pop    %r15
    28a4:	5d                   	pop    %rbp
    28a5:	c3                   	retq   
	f2fs_bug_on(sbi, is_read_io(fio->op));
    28a6:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    28a8:	f0 80 4b 48 04       	lock orb $0x4,0x48(%rbx)
}
    28ad:	e9 5e fb ff ff       	jmpq   2410 <f2fs_submit_page_write+0x50>
    28b2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    28b9:	00 00 00 00 
    28bd:	0f 1f 00             	nopl   (%rax)

00000000000028c0 <f2fs_set_data_blkaddr>:
void f2fs_set_data_blkaddr(struct dnode_of_data *dn) {
    28c0:	f3 0f 1e fa          	endbr64 
    28c4:	e8 00 00 00 00       	callq  28c9 <f2fs_set_data_blkaddr+0x9>
    28c9:	55                   	push   %rbp
	f2fs_wait_on_page_writeback(dn->node_page, NODE, true);
    28ca:	ba 01 00 00 00       	mov    $0x1,%edx
    28cf:	be 01 00 00 00       	mov    $0x1,%esi
void f2fs_set_data_blkaddr(struct dnode_of_data *dn) {
    28d4:	48 89 e5             	mov    %rsp,%rbp
    28d7:	53                   	push   %rbx
    28d8:	48 89 fb             	mov    %rdi,%rbx
	f2fs_wait_on_page_writeback(dn->node_page, NODE, true);
    28db:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    28df:	e8 00 00 00 00       	callq  28e4 <f2fs_set_data_blkaddr+0x24>
	__set_data_blkaddr(dn);
    28e4:	48 89 df             	mov    %rbx,%rdi
    28e7:	e8 94 d7 ff ff       	callq  80 <__set_data_blkaddr>
	if (set_page_dirty(dn->node_page))
    28ec:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    28f0:	e8 00 00 00 00       	callq  28f5 <f2fs_set_data_blkaddr+0x35>
    28f5:	85 c0                	test   %eax,%eax
    28f7:	74 04                	je     28fd <f2fs_set_data_blkaddr+0x3d>
		dn->node_changed = true;
    28f9:	c6 43 21 01          	movb   $0x1,0x21(%rbx)
}
    28fd:	5b                   	pop    %rbx
    28fe:	5d                   	pop    %rbp
    28ff:	c3                   	retq   

0000000000002900 <f2fs_update_data_blkaddr>:
void f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr) {
    2900:	f3 0f 1e fa          	endbr64 
    2904:	e8 00 00 00 00       	callq  2909 <f2fs_update_data_blkaddr+0x9>
    2909:	55                   	push   %rbp
    290a:	48 89 e5             	mov    %rsp,%rbp
    290d:	41 54                	push   %r12
    290f:	49 89 fc             	mov    %rdi,%r12
	dn->data_blkaddr = blkaddr;
    2912:	89 77 24             	mov    %esi,0x24(%rdi)
	f2fs_set_data_blkaddr(dn);
    2915:	e8 00 00 00 00       	callq  291a <f2fs_update_data_blkaddr+0x1a>
	f2fs_update_extent_cache(dn);
    291a:	4c 89 e7             	mov    %r12,%rdi
    291d:	e8 00 00 00 00       	callq  2922 <f2fs_update_data_blkaddr+0x22>
}
    2922:	41 5c                	pop    %r12
    2924:	5d                   	pop    %rbp
    2925:	c3                   	retq   
    2926:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    292d:	00 00 00 

0000000000002930 <f2fs_reserve_new_blocks>:
int f2fs_reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count) {
    2930:	f3 0f 1e fa          	endbr64 
    2934:	e8 00 00 00 00       	callq  2939 <f2fs_reserve_new_blocks+0x9>
    2939:	55                   	push   %rbp
    293a:	48 89 e5             	mov    %rsp,%rbp
    293d:	41 57                	push   %r15
    293f:	41 56                	push   %r14
    2941:	41 55                	push   %r13
    2943:	41 54                	push   %r12
    2945:	53                   	push   %rbx
    2946:	48 83 ec 18          	sub    $0x18,%rsp
	if (!count)
    294a:	48 85 f6             	test   %rsi,%rsi
    294d:	74 5e                	je     29ad <f2fs_reserve_new_blocks+0x7d>
	struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);
    294f:	4c 8b 3f             	mov    (%rdi),%r15
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
    2952:	48 89 f3             	mov    %rsi,%rbx
    2955:	49 89 fc             	mov    %rdi,%r12
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    2958:	49 8b b7 78 02 00 00 	mov    0x278(%r15),%rsi
    295f:	48 c1 ee 06          	shr    $0x6,%rsi
	if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))
    2963:	83 e6 01             	and    $0x1,%esi
    2966:	49 89 f5             	mov    %rsi,%r13
    2969:	0f 85 10 03 00 00    	jne    2c7f <f2fs_reserve_new_blocks+0x34f>
	return sb->s_fs_info;
    296f:	49 8b 47 28          	mov    0x28(%r15),%rax
	return ret;
}

static inline int dquot_reserve_block(struct inode *inode, qsize_t nr)
{
	return __dquot_alloc_space(inode, nr << inode->i_blkbits,
    2973:	48 89 de             	mov    %rbx,%rsi
    2976:	ba 03 00 00 00       	mov    $0x3,%edx
    297b:	4c 89 ff             	mov    %r15,%rdi
    297e:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
    2985:	4c 8b b0 08 04 00 00 	mov    0x408(%rax),%r14
    298c:	48 d3 e6             	shl    %cl,%rsi
    298f:	e8 00 00 00 00       	callq  2994 <f2fs_reserve_new_blocks+0x64>
    2994:	89 45 d4             	mov    %eax,-0x2c(%rbp)
	if (ret)
    2997:	85 c0                	test   %eax,%eax
    2999:	74 1b                	je     29b6 <f2fs_reserve_new_blocks+0x86>
}
    299b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    299e:	48 83 c4 18          	add    $0x18,%rsp
    29a2:	5b                   	pop    %rbx
    29a3:	41 5c                	pop    %r12
    29a5:	41 5d                	pop    %r13
    29a7:	41 5e                	pop    %r14
    29a9:	41 5f                	pop    %r15
    29ab:	5d                   	pop    %rbp
    29ac:	c3                   	retq   
		return 0;
    29ad:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
    29b4:	eb e5                	jmp    299b <f2fs_reserve_new_blocks+0x6b>
	percpu_counter_add(&sbi->alloc_valid_block_count, (*count));
    29b6:	4d 8d 96 98 04 00 00 	lea    0x498(%r14),%r10
	return __percpu_counter_compare(fbc, rhs, percpu_counter_batch);
}

static inline void percpu_counter_add(struct percpu_counter *fbc, s64 amount)
{
	percpu_counter_add_batch(fbc, amount, percpu_counter_batch);
    29bd:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 29c3 <f2fs_reserve_new_blocks+0x93>
    29c3:	48 89 de             	mov    %rbx,%rsi
    29c6:	4c 89 d7             	mov    %r10,%rdi
    29c9:	4c 89 55 c0          	mov    %r10,-0x40(%rbp)
    29cd:	e8 00 00 00 00       	callq  29d2 <f2fs_reserve_new_blocks+0xa2>
	raw_spin_lock(&lock->rlock);
    29d2:	4d 8d 86 00 06 00 00 	lea    0x600(%r14),%r8
    29d9:	4c 89 c7             	mov    %r8,%rdi
    29dc:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
    29e0:	e8 00 00 00 00       	callq  29e5 <f2fs_reserve_new_blocks+0xb5>
	sbi->total_valid_block_count += (block_t)(*count);
    29e5:	41 8b 86 58 04 00 00 	mov    0x458(%r14),%eax
	avail_user_block_count = sbi->user_block_count -
    29ec:	41 8b 96 54 04 00 00 	mov    0x454(%r14),%edx
    29f3:	41 2b 96 68 04 00 00 	sub    0x468(%r14),%edx
	if (!inode)
    29fa:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
	sbi->total_valid_block_count += (block_t)(*count);
    29fe:	01 d8                	add    %ebx,%eax
	if (!inode)
    2a00:	4d 85 ff             	test   %r15,%r15
    2a03:	4c 8b 55 c0          	mov    -0x40(%rbp),%r10
	sbi->total_valid_block_count += (block_t)(*count);
    2a07:	41 89 86 58 04 00 00 	mov    %eax,0x458(%r14)
	if (!inode)
    2a0e:	74 6e                	je     2a7e <f2fs_reserve_new_blocks+0x14e>
	if (!test_opt(sbi, RESERVE_ROOT))
    2a10:	41 f6 86 f3 04 00 00 	testb  $0x1,0x4f3(%r14)
    2a17:	01 
    2a18:	74 5d                	je     2a77 <f2fs_reserve_new_blocks+0x147>
	if (IS_NOQUOTA(inode))
    2a1a:	41 f6 47 0c 20       	testb  $0x20,0xc(%r15)
    2a1f:	75 5d                	jne    2a7e <f2fs_reserve_new_blocks+0x14e>
    2a21:	65 48 8b 0c 25 00 00 	mov    %gs:0x0,%rcx
    2a28:	00 00 
	if (uid_eq(F2FS_OPTION(sbi).s_resuid, current_fsuid()))
    2a2a:	48 8b 89 28 0a 00 00 	mov    0xa28(%rcx),%rcx
    2a31:	8b 49 1c             	mov    0x1c(%rcx),%ecx
    2a34:	41 39 8e fc 04 00 00 	cmp    %ecx,0x4fc(%r14)
    2a3b:	74 41                	je     2a7e <f2fs_reserve_new_blocks+0x14e>
	if (!gid_eq(F2FS_OPTION(sbi).s_resgid, GLOBAL_ROOT_GID) &&
    2a3d:	41 8b 8e 00 05 00 00 	mov    0x500(%r14),%ecx
    2a44:	85 c9                	test   %ecx,%ecx
    2a46:	0f 85 bc 02 00 00    	jne    2d08 <f2fs_reserve_new_blocks+0x3d8>
	if (cap && capable(CAP_SYS_RESOURCE))
    2a4c:	bf 18 00 00 00       	mov    $0x18,%edi
    2a51:	89 55 d0             	mov    %edx,-0x30(%rbp)
    2a54:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
    2a58:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
    2a5c:	e8 00 00 00 00       	callq  2a61 <f2fs_reserve_new_blocks+0x131>
    2a61:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    2a65:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
    2a69:	84 c0                	test   %al,%al
    2a6b:	8b 55 d0             	mov    -0x30(%rbp),%edx
    2a6e:	41 8b 86 58 04 00 00 	mov    0x458(%r14),%eax
    2a75:	75 07                	jne    2a7e <f2fs_reserve_new_blocks+0x14e>
		avail_user_block_count -= F2FS_OPTION(sbi).root_reserved_blocks;
    2a77:	41 2b 96 f8 04 00 00 	sub    0x4f8(%r14),%edx
    2a7e:	4c 89 c7             	mov    %r8,%rdi
	if (unlikely(sbi->total_valid_block_count > avail_user_block_count)) {
    2a81:	39 c2                	cmp    %eax,%edx
    2a83:	0f 82 02 02 00 00    	jb     2c8b <f2fs_reserve_new_blocks+0x35b>
    2a89:	ff 14 25 00 00 00 00 	callq  *0x0
	if (unlikely(release))
    2a90:	4d 85 ed             	test   %r13,%r13
    2a93:	0f 85 50 02 00 00    	jne    2ce9 <f2fs_reserve_new_blocks+0x3b9>
    2a99:	4d 8b af 78 02 00 00 	mov    0x278(%r15),%r13

static inline int dquot_claim_block(struct inode *inode, qsize_t nr)
{
	int ret;

	ret = dquot_claim_space_nodirty(inode, nr << inode->i_blkbits);
    2aa0:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
			dquot_claim_block(inode, diff);
    2aa7:	89 de                	mov    %ebx,%esi
    2aa9:	4c 89 ff             	mov    %r15,%rdi
    2aac:	4d 8b b7 78 02 00 00 	mov    0x278(%r15),%r14
    2ab3:	49 d1 ed             	shr    %r13
    2ab6:	48 d3 e6             	shl    %cl,%rsi
    2ab9:	41 83 e5 01          	and    $0x1,%r13d
    2abd:	49 c1 ee 02          	shr    $0x2,%r14
	bool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);
    2ac1:	41 83 f5 01          	xor    $0x1,%r13d
    2ac5:	41 83 e6 01          	and    $0x1,%r14d
    2ac9:	e8 00 00 00 00       	callq  2ace <f2fs_reserve_new_blocks+0x19e>
	if (!ret)
    2ace:	85 c0                	test   %eax,%eax
    2ad0:	0f 84 7a 01 00 00    	je     2c50 <f2fs_reserve_new_blocks+0x320>
	f2fs_mark_inode_dirty_sync(inode, true);
    2ad6:	be 01 00 00 00       	mov    $0x1,%esi
    2adb:	4c 89 ff             	mov    %r15,%rdi
    2ade:	e8 00 00 00 00       	callq  2ae3 <f2fs_reserve_new_blocks+0x1b3>
	if (clean || recover)
    2ae3:	45 84 ed             	test   %r13b,%r13b
    2ae6:	0f 85 76 01 00 00    	jne    2c62 <f2fs_reserve_new_blocks+0x332>
    2aec:	45 84 f6             	test   %r14b,%r14b
    2aef:	0f 85 6d 01 00 00    	jne    2c62 <f2fs_reserve_new_blocks+0x332>
    2af5:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	f2fs_wait_on_page_writeback(dn->node_page, NODE, true);
    2afa:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
    2aff:	ba 01 00 00 00       	mov    $0x1,%edx
    2b04:	be 01 00 00 00       	mov    $0x1,%esi
    2b09:	e8 00 00 00 00       	callq  2b0e <f2fs_reserve_new_blocks+0x1de>
	for (; count > 0; dn->ofs_in_node++) {
    2b0e:	41 8b 4c 24 1c       	mov    0x1c(%r12),%ecx
    2b13:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
    2b18:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2b1f <f2fs_reserve_new_blocks+0x1ef>
    2b1f:	48 89 f8             	mov    %rdi,%rax
    2b22:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 2b29 <f2fs_reserve_new_blocks+0x1f9>
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
    2b29:	89 ca                	mov    %ecx,%edx
    2b2b:	48 c1 f8 06          	sar    $0x6,%rax
    2b2f:	48 c1 e0 0c          	shl    $0xc,%rax
    2b33:	48 01 f0             	add    %rsi,%rax
	if (is_inode) {
    2b36:	44 8b 88 ec 0f 00 00 	mov    0xfec(%rax),%r9d
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
    2b3d:	49 89 c0             	mov    %rax,%r8
	if (is_inode) {
    2b40:	44 39 88 e8 0f 00 00 	cmp    %r9d,0xfe8(%rax)
    2b47:	74 12                	je     2b5b <f2fs_reserve_new_blocks+0x22b>
		if (blkaddr == NULL_ADDR) {
    2b49:	41 8b 04 90          	mov    (%r8,%rdx,4),%eax
    2b4d:	85 c0                	test   %eax,%eax
    2b4f:	74 41                	je     2b92 <f2fs_reserve_new_blocks+0x262>
	for (; count > 0; dn->ofs_in_node++) {
    2b51:	83 c1 01             	add    $0x1,%ecx
    2b54:	41 89 4c 24 1c       	mov    %ecx,0x1c(%r12)
    2b59:	eb c4                	jmp    2b1f <f2fs_reserve_new_blocks+0x1ef>
		block_t blkaddr = datablock_addr(dn->inode, dn->node_page, dn->ofs_in_node);
    2b5b:	4d 8b 04 24          	mov    (%r12),%r8
		if (!inode)
    2b5f:	4d 85 c0             	test   %r8,%r8
    2b62:	74 73                	je     2bd7 <f2fs_reserve_new_blocks+0x2a7>
    2b64:	4d 8b 90 78 02 00 00 	mov    0x278(%r8),%r10
    2b6b:	89 ca                	mov    %ecx,%edx
		else if (f2fs_has_extra_attr(inode))
    2b6d:	41 f7 c2 00 00 00 04 	test   $0x4000000,%r10d
    2b74:	74 0d                	je     2b83 <f2fs_reserve_new_blocks+0x253>
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
    2b76:	49 63 90 08 04 00 00 	movslq 0x408(%r8),%rdx
    2b7d:	48 c1 ea 02          	shr    $0x2,%rdx
    2b81:	01 ca                	add    %ecx,%edx
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
    2b83:	4c 8d 80 68 01 00 00 	lea    0x168(%rax),%r8
		if (blkaddr == NULL_ADDR) {
    2b8a:	41 8b 04 90          	mov    (%r8,%rdx,4),%eax
    2b8e:	85 c0                	test   %eax,%eax
    2b90:	75 bf                	jne    2b51 <f2fs_reserve_new_blocks+0x221>
			dn->data_blkaddr = NEW_ADDR;
    2b92:	41 c7 44 24 24 ff ff 	movl   $0xffffffff,0x24(%r12)
    2b99:	ff ff 
			__set_data_blkaddr(dn);
    2b9b:	4c 89 e7             	mov    %r12,%rdi
    2b9e:	e8 dd d4 ff ff       	callq  80 <__set_data_blkaddr>
	for (; count > 0; dn->ofs_in_node++) {
    2ba3:	41 8b 44 24 1c       	mov    0x1c(%r12),%eax
    2ba8:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
    2bad:	8d 48 01             	lea    0x1(%rax),%ecx
    2bb0:	41 89 4c 24 1c       	mov    %ecx,0x1c(%r12)
    2bb5:	48 83 eb 01          	sub    $0x1,%rbx
    2bb9:	0f 85 59 ff ff ff    	jne    2b18 <f2fs_reserve_new_blocks+0x1e8>
	if (set_page_dirty(dn->node_page))
    2bbf:	e8 00 00 00 00       	callq  2bc4 <f2fs_reserve_new_blocks+0x294>
    2bc4:	85 c0                	test   %eax,%eax
    2bc6:	0f 84 e1 fd ff ff    	je     29ad <f2fs_reserve_new_blocks+0x7d>
		dn->node_changed = true;
    2bcc:	41 c6 44 24 21 01    	movb   $0x1,0x21(%r12)
    2bd2:	e9 c4 fd ff ff       	jmpq   299b <f2fs_reserve_new_blocks+0x6b>
			(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;
    2bd7:	f6 40 03 20          	testb  $0x20,0x3(%rax)
    2bdb:	74 a6                	je     2b83 <f2fs_reserve_new_blocks+0x253>
    2bdd:	0f b7 90 68 01 00 00 	movzwl 0x168(%rax),%edx
    2be4:	66 c1 ea 02          	shr    $0x2,%dx
    2be8:	0f b7 d2             	movzwl %dx,%edx
    2beb:	01 ca                	add    %ecx,%edx
    2bed:	eb 94                	jmp    2b83 <f2fs_reserve_new_blocks+0x253>
TRACE_EVENT(f2fs_reserve_new_blocks,
    2bef:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 2bf6 <f2fs_reserve_new_blocks+0x2c6>
    2bf6:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    2bf8:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 2c00 <f2fs_reserve_new_blocks+0x2d0>
    2bff:	00 
    2c00:	0f 83 f4 fe ff ff    	jae    2afa <f2fs_reserve_new_blocks+0x1ca>
	trace_f2fs_reserve_new_blocks(dn->inode, dn->nid,
    2c06:	41 8b 44 24 1c       	mov    0x1c(%r12),%eax
    2c0b:	45 8b 74 24 18       	mov    0x18(%r12),%r14d
    2c10:	4d 8b 3c 24          	mov    (%r12),%r15
    2c14:	89 45 c8             	mov    %eax,-0x38(%rbp)
    2c17:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2c1e <f2fs_reserve_new_blocks+0x2ee>
    2c1e:	48 85 c0             	test   %rax,%rax
    2c21:	74 28                	je     2c4b <f2fs_reserve_new_blocks+0x31b>
    2c23:	4c 8b 10             	mov    (%rax),%r10
    2c26:	49 89 c5             	mov    %rax,%r13
    2c29:	49 8b 7d 08          	mov    0x8(%r13),%rdi
    2c2d:	49 83 c5 18          	add    $0x18,%r13
    2c31:	8b 4d c8             	mov    -0x38(%rbp),%ecx
    2c34:	49 89 d8             	mov    %rbx,%r8
    2c37:	44 89 f2             	mov    %r14d,%edx
    2c3a:	4c 89 fe             	mov    %r15,%rsi
    2c3d:	e8 00 00 00 00       	callq  2c42 <f2fs_reserve_new_blocks+0x312>
    2c42:	4d 8b 55 00          	mov    0x0(%r13),%r10
    2c46:	4d 85 d2             	test   %r10,%r10
    2c49:	75 de                	jne    2c29 <f2fs_reserve_new_blocks+0x2f9>
    2c4b:	e9 aa fe ff ff       	jmpq   2afa <f2fs_reserve_new_blocks+0x1ca>
	__mark_inode_dirty(inode, I_DIRTY_SYNC);
    2c50:	be 01 00 00 00       	mov    $0x1,%esi
    2c55:	4c 89 ff             	mov    %r15,%rdi
    2c58:	e8 00 00 00 00       	callq  2c5d <f2fs_reserve_new_blocks+0x32d>
}
    2c5d:	e9 74 fe ff ff       	jmpq   2ad6 <f2fs_reserve_new_blocks+0x1a6>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    2c62:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    2c69:	a8 04                	test   $0x4,%al
    2c6b:	0f 85 84 fe ff ff    	jne    2af5 <f2fs_reserve_new_blocks+0x1c5>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    2c71:	f0 41 80 8f 78 02 00 	lock orb $0x4,0x278(%r15)
    2c78:	00 04 
    2c7a:	e9 76 fe ff ff       	jmpq   2af5 <f2fs_reserve_new_blocks+0x1c5>
		return -EPERM;
    2c7f:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%rbp)
    2c86:	e9 10 fd ff ff       	jmpq   299b <f2fs_reserve_new_blocks+0x6b>
		diff = sbi->total_valid_block_count - avail_user_block_count;
    2c8b:	89 c6                	mov    %eax,%esi
    2c8d:	29 d6                	sub    %edx,%esi
		if (diff > *count)
    2c8f:	48 39 de             	cmp    %rbx,%rsi
    2c92:	48 0f 47 f3          	cmova  %rbx,%rsi
		sbi->total_valid_block_count -= diff;
    2c96:	29 f0                	sub    %esi,%eax
    2c98:	49 89 f5             	mov    %rsi,%r13
    2c9b:	41 89 86 58 04 00 00 	mov    %eax,0x458(%r14)
		if (!*count) {
    2ca2:	48 29 f3             	sub    %rsi,%rbx
    2ca5:	0f 85 de fd ff ff    	jne    2a89 <f2fs_reserve_new_blocks+0x159>
    2cab:	ff 14 25 00 00 00 00 	callq  *0x0
    2cb2:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 2cb8 <f2fs_reserve_new_blocks+0x388>
    2cb8:	4c 89 d7             	mov    %r10,%rdi
	percpu_counter_add(fbc, -1);
}

static inline void percpu_counter_sub(struct percpu_counter *fbc, s64 amount)
{
	percpu_counter_add(fbc, -amount);
    2cbb:	48 f7 de             	neg    %rsi
	percpu_counter_add_batch(fbc, amount, percpu_counter_batch);
    2cbe:	e8 00 00 00 00       	callq  2cc3 <f2fs_reserve_new_blocks+0x393>
}

static inline void dquot_release_reservation_block(struct inode *inode,
		qsize_t nr)
{
	__dquot_free_space(inode, nr << inode->i_blkbits, DQUOT_SPACE_RESERVE);
    2cc3:	4c 89 ee             	mov    %r13,%rsi
    2cc6:	ba 02 00 00 00       	mov    $0x2,%edx
    2ccb:	4c 89 ff             	mov    %r15,%rdi
    2cce:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
    2cd5:	48 d3 e6             	shl    %cl,%rsi
    2cd8:	e8 00 00 00 00       	callq  2cdd <f2fs_reserve_new_blocks+0x3ad>
	return -ENOSPC;
    2cdd:	c7 45 d4 e4 ff ff ff 	movl   $0xffffffe4,-0x2c(%rbp)
    2ce4:	e9 b2 fc ff ff       	jmpq   299b <f2fs_reserve_new_blocks+0x6b>
    2ce9:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
    2cf0:	4c 89 ee             	mov    %r13,%rsi
    2cf3:	ba 02 00 00 00       	mov    $0x2,%edx
    2cf8:	4c 89 ff             	mov    %r15,%rdi
    2cfb:	48 d3 e6             	shl    %cl,%rsi
    2cfe:	e8 00 00 00 00       	callq  2d03 <f2fs_reserve_new_blocks+0x3d3>
}
    2d03:	e9 91 fd ff ff       	jmpq   2a99 <f2fs_reserve_new_blocks+0x169>
					in_group_p(F2FS_OPTION(sbi).s_resgid))
    2d08:	41 8b be 00 05 00 00 	mov    0x500(%r14),%edi
    2d0f:	89 55 d0             	mov    %edx,-0x30(%rbp)
    2d12:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
    2d16:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
    2d1a:	e8 00 00 00 00       	callq  2d1f <f2fs_reserve_new_blocks+0x3ef>
	if (!gid_eq(F2FS_OPTION(sbi).s_resgid, GLOBAL_ROOT_GID) &&
    2d1f:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    2d23:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
    2d27:	85 c0                	test   %eax,%eax
    2d29:	8b 55 d0             	mov    -0x30(%rbp),%edx
    2d2c:	0f 84 1a fd ff ff    	je     2a4c <f2fs_reserve_new_blocks+0x11c>
    2d32:	41 8b 86 58 04 00 00 	mov    0x458(%r14),%eax
    2d39:	e9 40 fd ff ff       	jmpq   2a7e <f2fs_reserve_new_blocks+0x14e>
    2d3e:	66 90                	xchg   %ax,%ax

0000000000002d40 <f2fs_reserve_new_block>:
int f2fs_reserve_new_block(struct dnode_of_data *dn) {
    2d40:	f3 0f 1e fa          	endbr64 
    2d44:	e8 00 00 00 00       	callq  2d49 <f2fs_reserve_new_block+0x9>
    2d49:	55                   	push   %rbp
	ret = f2fs_reserve_new_blocks(dn, 1);
    2d4a:	be 01 00 00 00       	mov    $0x1,%esi
int f2fs_reserve_new_block(struct dnode_of_data *dn) {
    2d4f:	48 89 e5             	mov    %rsp,%rbp
    2d52:	41 54                	push   %r12
	unsigned int ofs_in_node = dn->ofs_in_node;
    2d54:	44 8b 67 1c          	mov    0x1c(%rdi),%r12d
int f2fs_reserve_new_block(struct dnode_of_data *dn) {
    2d58:	53                   	push   %rbx
    2d59:	48 89 fb             	mov    %rdi,%rbx
	ret = f2fs_reserve_new_blocks(dn, 1);
    2d5c:	e8 00 00 00 00       	callq  2d61 <f2fs_reserve_new_block+0x21>
	dn->ofs_in_node = ofs_in_node;
    2d61:	44 89 63 1c          	mov    %r12d,0x1c(%rbx)
}
    2d65:	5b                   	pop    %rbx
    2d66:	41 5c                	pop    %r12
    2d68:	5d                   	pop    %rbp
    2d69:	c3                   	retq   
    2d6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000002d70 <f2fs_reserve_block>:
int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index) {
    2d70:	f3 0f 1e fa          	endbr64 
    2d74:	e8 00 00 00 00       	callq  2d79 <f2fs_reserve_block+0x9>
    2d79:	55                   	push   %rbp
	err = f2fs_get_dnode_of_data(dn, index, ALLOC_NODE);
    2d7a:	31 d2                	xor    %edx,%edx
int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index) {
    2d7c:	48 89 e5             	mov    %rsp,%rbp
    2d7f:	41 57                	push   %r15
    2d81:	41 56                	push   %r14
    2d83:	41 55                	push   %r13
    2d85:	41 54                	push   %r12
    2d87:	53                   	push   %rbx
    2d88:	48 89 fb             	mov    %rdi,%rbx
	bool need_put = dn->inode_page ? false : true;
    2d8b:	4c 8b 6f 08          	mov    0x8(%rdi),%r13
	err = f2fs_get_dnode_of_data(dn, index, ALLOC_NODE);
    2d8f:	e8 00 00 00 00       	callq  2d94 <f2fs_reserve_block+0x24>
    2d94:	41 89 c4             	mov    %eax,%r12d
	if (err)
    2d97:	85 c0                	test   %eax,%eax
    2d99:	0f 85 ad 00 00 00    	jne    2e4c <f2fs_reserve_block+0xdc>
	if (dn->data_blkaddr == NULL_ADDR)
    2d9f:	8b 43 24             	mov    0x24(%rbx),%eax
	bool need_put = dn->inode_page ? false : true;
    2da2:	4d 85 ed             	test   %r13,%r13
    2da5:	41 0f 94 c6          	sete   %r14b
	err = f2fs_get_dnode_of_data(dn, index, ALLOC_NODE);
    2da9:	45 31 ed             	xor    %r13d,%r13d
	if (dn->data_blkaddr == NULL_ADDR)
    2dac:	85 c0                	test   %eax,%eax
    2dae:	0f 84 a6 00 00 00    	je     2e5a <f2fs_reserve_block+0xea>
	if (err || need_put)
    2db4:	45 84 f6             	test   %r14b,%r14b
    2db7:	0f 84 8f 00 00 00    	je     2e4c <f2fs_reserve_block+0xdc>
	if (dn->node_page)
    2dbd:	4c 8b 63 10          	mov    0x10(%rbx),%r12
    2dc1:	4d 85 e4             	test   %r12,%r12
    2dc4:	0f 84 f2 00 00 00    	je     2ebc <f2fs_reserve_block+0x14c>
    2dca:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    2dcf:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    2dd3:	83 e2 01             	and    $0x1,%edx
    2dd6:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    2dda:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    2ddd:	a8 01                	test   $0x1,%al
    2ddf:	0f 84 33 01 00 00    	je     2f18 <f2fs_reserve_block+0x1a8>
		unlock_page(page);
    2de5:	4c 89 e7             	mov    %r12,%rdi
    2de8:	e8 00 00 00 00       	callq  2ded <f2fs_reserve_block+0x7d>
    2ded:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    2df2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    2df6:	a8 01                	test   $0x1,%al
    2df8:	4c 0f 45 e2          	cmovne %rdx,%r12
    2dfc:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
    2e01:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    2e07:	0f 84 f4 00 00 00    	je     2f01 <f2fs_reserve_block+0x191>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    2e0d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2e11:	48 85 ff             	test   %rdi,%rdi
    2e14:	74 23                	je     2e39 <f2fs_reserve_block+0xc9>
    2e16:	48 3b 7b 10          	cmp    0x10(%rbx),%rdi
    2e1a:	74 1d                	je     2e39 <f2fs_reserve_block+0xc9>
    2e1c:	48 8b 47 08          	mov    0x8(%rdi),%rax
    2e20:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    2e24:	a8 01                	test   $0x1,%al
    2e26:	48 0f 45 fa          	cmovne %rdx,%rdi
    2e2a:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    2e2f:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    2e33:	0f 84 d5 00 00 00    	je     2f0e <f2fs_reserve_block+0x19e>
	dn->node_page = NULL;
    2e39:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    2e40:	00 
}
    2e41:	45 89 ec             	mov    %r13d,%r12d
	dn->inode_page = NULL;
    2e44:	48 c7 43 08 00 00 00 	movq   $0x0,0x8(%rbx)
    2e4b:	00 
}
    2e4c:	5b                   	pop    %rbx
    2e4d:	44 89 e0             	mov    %r12d,%eax
    2e50:	41 5c                	pop    %r12
    2e52:	41 5d                	pop    %r13
    2e54:	41 5e                	pop    %r14
    2e56:	41 5f                	pop    %r15
    2e58:	5d                   	pop    %rbp
    2e59:	c3                   	retq   
	ret = f2fs_reserve_new_blocks(dn, 1);
    2e5a:	be 01 00 00 00       	mov    $0x1,%esi
    2e5f:	48 89 df             	mov    %rbx,%rdi
	unsigned int ofs_in_node = dn->ofs_in_node;
    2e62:	44 8b 7b 1c          	mov    0x1c(%rbx),%r15d
	ret = f2fs_reserve_new_blocks(dn, 1);
    2e66:	e8 00 00 00 00       	callq  2e6b <f2fs_reserve_block+0xfb>
    2e6b:	85 c0                	test   %eax,%eax
    2e6d:	41 89 c5             	mov    %eax,%r13d
	dn->ofs_in_node = ofs_in_node;
    2e70:	44 89 7b 1c          	mov    %r15d,0x1c(%rbx)
	return ret;
    2e74:	0f 95 c0             	setne  %al
    2e77:	41 09 c6             	or     %eax,%r14d
	if (err || need_put)
    2e7a:	45 84 f6             	test   %r14b,%r14b
    2e7d:	74 cd                	je     2e4c <f2fs_reserve_block+0xdc>
    2e7f:	e9 39 ff ff ff       	jmpq   2dbd <f2fs_reserve_block+0x4d>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    2e84:	49 8b 04 24          	mov    (%r12),%rax
    2e88:	48 c1 e8 33          	shr    $0x33,%rax
    2e8c:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    2e8f:	83 f8 04             	cmp    $0x4,%eax
    2e92:	0f 85 69 ff ff ff    	jne    2e01 <f2fs_reserve_block+0x91>
	switch (page->pgmap->type) {
    2e98:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    2e9d:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    2ea3:	83 e8 01             	sub    $0x1,%eax
    2ea6:	83 f8 02             	cmp    $0x2,%eax
    2ea9:	0f 87 52 ff ff ff    	ja     2e01 <f2fs_reserve_block+0x91>
		__put_devmap_managed_page(page);
    2eaf:	4c 89 e7             	mov    %r12,%rdi
    2eb2:	e8 00 00 00 00       	callq  2eb7 <f2fs_reserve_block+0x147>
		return;
    2eb7:	e9 51 ff ff ff       	jmpq   2e0d <f2fs_reserve_block+0x9d>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    2ebc:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    2ec0:	48 85 ff             	test   %rdi,%rdi
    2ec3:	0f 85 53 ff ff ff    	jne    2e1c <f2fs_reserve_block+0xac>
    2ec9:	e9 6b ff ff ff       	jmpq   2e39 <f2fs_reserve_block+0xc9>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    2ece:	48 8b 07             	mov    (%rdi),%rax
    2ed1:	48 c1 e8 33          	shr    $0x33,%rax
    2ed5:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    2ed8:	83 f8 04             	cmp    $0x4,%eax
    2edb:	0f 85 4e ff ff ff    	jne    2e2f <f2fs_reserve_block+0xbf>
	switch (page->pgmap->type) {
    2ee1:	48 8b 47 08          	mov    0x8(%rdi),%rax
    2ee5:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    2eeb:	83 e8 01             	sub    $0x1,%eax
    2eee:	83 f8 02             	cmp    $0x2,%eax
    2ef1:	0f 87 38 ff ff ff    	ja     2e2f <f2fs_reserve_block+0xbf>
		__put_devmap_managed_page(page);
    2ef7:	e8 00 00 00 00       	callq  2efc <f2fs_reserve_block+0x18c>
		return;
    2efc:	e9 38 ff ff ff       	jmpq   2e39 <f2fs_reserve_block+0xc9>
		__put_page(page);
    2f01:	4c 89 e7             	mov    %r12,%rdi
    2f04:	e8 00 00 00 00       	callq  2f09 <f2fs_reserve_block+0x199>
    2f09:	e9 ff fe ff ff       	jmpq   2e0d <f2fs_reserve_block+0x9d>
    2f0e:	e8 00 00 00 00       	callq  2f13 <f2fs_reserve_block+0x1a3>
    2f13:	e9 21 ff ff ff       	jmpq   2e39 <f2fs_reserve_block+0xc9>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    2f18:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    2f1a:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    2f1f:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    2f22:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    2f26:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    2f2d:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    2f32:	e9 ae fe ff ff       	jmpq   2de5 <f2fs_reserve_block+0x75>
    2f37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    2f3e:	00 00 

0000000000002f40 <f2fs_get_block>:
int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index) {
    2f40:	f3 0f 1e fa          	endbr64 
    2f44:	e8 00 00 00 00       	callq  2f49 <f2fs_get_block+0x9>
    2f49:	55                   	push   %rbp
    2f4a:	48 89 e5             	mov    %rsp,%rbp
    2f4d:	41 55                	push   %r13
    2f4f:	49 89 f5             	mov    %rsi,%r13
    2f52:	41 54                	push   %r12
    2f54:	49 89 fc             	mov    %rdi,%r12
	if (f2fs_lookup_extent_cache(inode, index, &ei)) {
    2f57:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index) {
    2f5b:	48 83 ec 18          	sub    $0x18,%rsp
	if (f2fs_lookup_extent_cache(inode, index, &ei)) {
    2f5f:	48 8b 3f             	mov    (%rdi),%rdi
int f2fs_get_block(struct dnode_of_data *dn, pgoff_t index) {
    2f62:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    2f69:	00 00 
    2f6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    2f6f:	31 c0                	xor    %eax,%eax
	struct extent_info ei = {0, 0, 0};
    2f71:	48 c7 45 dc 00 00 00 	movq   $0x0,-0x24(%rbp)
    2f78:	00 
    2f79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	if (f2fs_lookup_extent_cache(inode, index, &ei)) {
    2f80:	e8 00 00 00 00       	callq  2f85 <f2fs_get_block+0x45>
    2f85:	84 c0                	test   %al,%al
    2f87:	74 29                	je     2fb2 <f2fs_get_block+0x72>
		dn->data_blkaddr = ei.blk + index - ei.fofs;
    2f89:	8b 75 e4             	mov    -0x1c(%rbp),%esi
    2f8c:	2b 75 dc             	sub    -0x24(%rbp),%esi
		return 0;
    2f8f:	31 c0                	xor    %eax,%eax
		dn->data_blkaddr = ei.blk + index - ei.fofs;
    2f91:	44 01 ee             	add    %r13d,%esi
    2f94:	41 89 74 24 24       	mov    %esi,0x24(%r12)
}
    2f99:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
    2f9d:	65 48 33 0c 25 28 00 	xor    %gs:0x28,%rcx
    2fa4:	00 00 
    2fa6:	75 17                	jne    2fbf <f2fs_get_block+0x7f>
    2fa8:	48 83 c4 18          	add    $0x18,%rsp
    2fac:	41 5c                	pop    %r12
    2fae:	41 5d                	pop    %r13
    2fb0:	5d                   	pop    %rbp
    2fb1:	c3                   	retq   
	return f2fs_reserve_block(dn, index);
    2fb2:	4c 89 ee             	mov    %r13,%rsi
    2fb5:	4c 89 e7             	mov    %r12,%rdi
    2fb8:	e8 00 00 00 00       	callq  2fbd <f2fs_get_block+0x7d>
    2fbd:	eb da                	jmp    2f99 <f2fs_get_block+0x59>
}
    2fbf:	e8 00 00 00 00       	callq  2fc4 <f2fs_get_block+0x84>
    2fc4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    2fcb:	00 00 00 00 
    2fcf:	90                   	nop

0000000000002fd0 <f2fs_write_begin>:
							struct page **pagep, void **fsdata) {
    2fd0:	f3 0f 1e fa          	endbr64 
    2fd4:	e8 00 00 00 00       	callq  2fd9 <f2fs_write_begin+0x9>
    2fd9:	55                   	push   %rbp
    2fda:	48 89 e5             	mov    %rsp,%rbp
    2fdd:	41 57                	push   %r15
    2fdf:	41 56                	push   %r14
    2fe1:	41 55                	push   %r13
    2fe3:	41 54                	push   %r12
    2fe5:	53                   	push   %rbx
    2fe6:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
    2fed:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
	pgoff_t index = ((unsigned long long) pos) >> PAGE_SHIFT;
    2ff1:	48 c1 ea 0c          	shr    $0xc,%rdx
							struct page **pagep, void **fsdata) {
    2ff5:	48 89 b5 70 ff ff ff 	mov    %rsi,-0x90(%rbp)
    2ffc:	89 4d 84             	mov    %ecx,-0x7c(%rbp)
    2fff:	4c 89 8d 58 ff ff ff 	mov    %r9,-0xa8(%rbp)
    3006:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    300d:	00 00 
    300f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3013:	31 c0                	xor    %eax,%eax
	struct inode *inode = mapping->host;
    3015:	48 8b 06             	mov    (%rsi),%rax
	pgoff_t index = ((unsigned long long) pos) >> PAGE_SHIFT;
    3018:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
	struct inode *inode = mapping->host;
    301f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	return sb->s_fs_info;
    3023:	48 8b 40 28          	mov    0x28(%rax),%rax
    3027:	4c 8b b0 08 04 00 00 	mov    0x408(%rax),%r14
    302e:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3033:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    3037:	48 8b 80 78 02 00 00 	mov    0x278(%rax),%rax
	if (f2fs_is_atomic_file(inode) &&
    303e:	f6 c4 80             	test   $0x80,%ah
    3041:	0f 85 22 05 00 00    	jne    3569 <f2fs_write_begin+0x599>
	if (index != 0) {
    3047:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
    304e:	00 
    304f:	0f 85 2f 06 00 00    	jne    3684 <f2fs_write_begin+0x6b4>
    3055:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%rbp)
    305c:	00 00 00 
    305f:	4d 89 f4             	mov    %r14,%r12
    3062:	c6 45 83 00          	movb   $0x0,-0x7d(%rbp)
	return pagecache_get_page(mapping, index, fgp_flags, gfp_mask);
    3066:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
    306d:	b9 40 00 60 00       	mov    $0x600040,%ecx
    3072:	ba 0e 00 00 00       	mov    $0xe,%edx
    3077:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    307e:	e8 00 00 00 00       	callq  3083 <f2fs_write_begin+0xb3>
    3083:	49 89 c7             	mov    %rax,%r15
	if (!page) {
    3086:	48 85 c0             	test   %rax,%rax
    3089:	0f 84 fb 0a 00 00    	je     3b8a <f2fs_write_begin+0xbba>
	*pagep = page;
    308f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    3096:	4c 89 38             	mov    %r15,(%rax)
	struct inode *inode = page->mapping->host;
    3099:	49 8b 47 18          	mov    0x18(%r15),%rax
	pgoff_t index = page->index;
    309d:	4d 8b 77 20          	mov    0x20(%r15),%r14
	struct inode *inode = page->mapping->host;
    30a1:	48 8b 18             	mov    (%rax),%rbx
	struct extent_info ei = {0, 0, 0};
    30a4:	48 c7 45 9c 00 00 00 	movq   $0x0,-0x64(%rbp)
    30ab:	00 
    30ac:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)
    30b3:	48 8b 83 78 02 00 00 	mov    0x278(%rbx),%rax
	if (!f2fs_has_inline_data(inode) && len == PAGE_SIZE &&
    30ba:	f6 c4 04             	test   $0x4,%ah
    30bd:	75 0d                	jne    30cc <f2fs_write_begin+0xfc>
    30bf:	81 7d 84 00 10 00 00 	cmpl   $0x1000,-0x7c(%rbp)
    30c6:	0f 84 84 06 00 00    	je     3750 <f2fs_write_begin+0x780>
    30cc:	4c 8b ab 78 02 00 00 	mov    0x278(%rbx),%r13
    30d3:	49 c1 ed 0a          	shr    $0xa,%r13
	if (f2fs_has_inline_data(inode) ||
    30d7:	41 83 e5 01          	and    $0x1,%r13d
    30db:	0f 85 5a 01 00 00    	jne    323b <f2fs_write_begin+0x26b>
		(pos & PAGE_MASK) >= i_size_read(inode)) {
    30e1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    30e5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
	if (f2fs_has_inline_data(inode) ||
    30eb:	48 3b 43 50          	cmp    0x50(%rbx),%rax
    30ef:	0f 83 46 01 00 00    	jae    323b <f2fs_write_begin+0x26b>
		locked = true;
    30f5:	31 c0                	xor    %eax,%eax
    30f7:	4c 89 bd 50 ff ff ff 	mov    %r15,-0xb0(%rbp)
    30fe:	41 89 c7             	mov    %eax,%r15d
    3101:	e9 8f 00 00 00       	jmpq   3195 <f2fs_write_begin+0x1c5>
    3106:	49 8b 55 08          	mov    0x8(%r13),%rdx
    310a:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    310e:	83 e2 01             	and    $0x1,%edx
    3111:	49 0f 44 c5          	cmove  %r13,%rax
    3115:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3118:	a8 01                	test   $0x1,%al
    311a:	0f 84 46 05 00 00    	je     3666 <f2fs_write_begin+0x696>
		unlock_page(page);
    3120:	4c 89 ef             	mov    %r13,%rdi
    3123:	e8 00 00 00 00       	callq  3128 <f2fs_write_begin+0x158>
    3128:	49 8b 45 08          	mov    0x8(%r13),%rax
    312c:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3130:	a8 01                	test   $0x1,%al
    3132:	4c 0f 45 ea          	cmovne %rdx,%r13
    3136:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    313b:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
	if (put_page_testzero(page))
    3140:	0f 84 77 01 00 00    	je     32bd <f2fs_write_begin+0x2ed>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    3146:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    314a:	48 85 ff             	test   %rdi,%rdi
    314d:	74 23                	je     3172 <f2fs_write_begin+0x1a2>
    314f:	48 3b 7d b8          	cmp    -0x48(%rbp),%rdi
    3153:	74 1d                	je     3172 <f2fs_write_begin+0x1a2>
    3155:	48 8b 47 08          	mov    0x8(%rdi),%rax
    3159:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    315d:	a8 01                	test   $0x1,%al
    315f:	48 0f 45 fa          	cmovne %rdx,%rdi
    3163:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3168:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    316c:	0f 84 58 01 00 00    	je     32ca <f2fs_write_begin+0x2fa>
			down_read(&sbi->node_change);
    3172:	49 8d bc 24 00 02 00 	lea    0x200(%r12),%rdi
    3179:	00 
	dn->node_page = NULL;
    317a:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    3181:	00 
				locked = true;
    3182:	41 bd 01 00 00 00    	mov    $0x1,%r13d
	dn->inode_page = NULL;
    3188:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    318f:	00 
			down_read(&sbi->node_change);
    3190:	e8 00 00 00 00       	callq  3195 <f2fs_write_begin+0x1c5>
	ipage = f2fs_get_node_page(sbi, inode->i_ino);
    3195:	48 8b 73 40          	mov    0x40(%rbx),%rsi
    3199:	4c 89 e7             	mov    %r12,%rdi
    319c:	e8 00 00 00 00       	callq  31a1 <f2fs_write_begin+0x1d1>
	if (IS_ERR(ipage)) {
    31a1:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    31a7:	0f 87 27 01 00 00    	ja     32d4 <f2fs_write_begin+0x304>
    31ad:	48 8b 93 78 02 00 00 	mov    0x278(%rbx),%rdx
	size_t p_size = __builtin_object_size(p, 0);
	if (__builtin_constant_p(size) && p_size < size)
		__write_overflow();
	if (p_size < size)
		fortify_panic(__func__);
	return __builtin_memset(p, c, size);
    31b4:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    31bb:	00 
    31bc:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    31c3:	00 
	dn->inode = inode;
    31c4:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
	dn->inode_page = ipage;
    31c8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	dn->node_page = npage;
    31cc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	if (f2fs_has_inline_data(inode)) {
    31d0:	80 e6 04             	and    $0x4,%dh
    31d3:	0f 85 5d 06 00 00    	jne    3836 <f2fs_write_begin+0x866>
	} else if (locked) {
    31d9:	45 84 ed             	test   %r13b,%r13b
    31dc:	0f 85 b4 07 00 00    	jne    3996 <f2fs_write_begin+0x9c6>
		if (f2fs_lookup_extent_cache(inode, index, &ei)) {
    31e2:	48 8d 55 9c          	lea    -0x64(%rbp),%rdx
    31e6:	4c 89 f6             	mov    %r14,%rsi
    31e9:	48 89 df             	mov    %rbx,%rdi
    31ec:	e8 00 00 00 00       	callq  31f1 <f2fs_write_begin+0x221>
    31f1:	84 c0                	test   %al,%al
    31f3:	0f 85 bb 07 00 00    	jne    39b4 <f2fs_write_begin+0x9e4>
			err = f2fs_get_dnode_of_data(&dn, index, LOOKUP_NODE);
    31f9:	ba 01 00 00 00       	mov    $0x1,%edx
    31fe:	4c 89 f6             	mov    %r14,%rsi
    3201:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
    3205:	e8 00 00 00 00       	callq  320a <f2fs_write_begin+0x23a>
    320a:	41 89 c7             	mov    %eax,%r15d
			if (err || dn.data_blkaddr == NULL_ADDR) {
    320d:	85 c0                	test   %eax,%eax
    320f:	75 0b                	jne    321c <f2fs_write_begin+0x24c>
    3211:	8b 45 cc             	mov    -0x34(%rbp),%eax
    3214:	85 c0                	test   %eax,%eax
    3216:	0f 85 58 08 00 00    	jne    3a74 <f2fs_write_begin+0xaa4>
	if (dn->node_page)
    321c:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    3220:	4d 85 ed             	test   %r13,%r13
    3223:	0f 85 dd fe ff ff    	jne    3106 <f2fs_write_begin+0x136>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    3229:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    322d:	48 85 ff             	test   %rdi,%rdi
    3230:	0f 85 1f ff ff ff    	jne    3155 <f2fs_write_begin+0x185>
    3236:	e9 37 ff ff ff       	jmpq   3172 <f2fs_write_begin+0x1a2>
			down_read(&sbi->node_change);
    323b:	49 8d bc 24 00 02 00 	lea    0x200(%r12),%rdi
    3242:	00 
		locked = true;
    3243:	41 bd 01 00 00 00    	mov    $0x1,%r13d
			down_read(&sbi->node_change);
    3249:	e8 00 00 00 00       	callq  324e <f2fs_write_begin+0x27e>
		locked = true;
    324e:	e9 a2 fe ff ff       	jmpq   30f5 <f2fs_write_begin+0x125>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3253:	49 8b 45 00          	mov    0x0(%r13),%rax
    3257:	48 c1 e8 33          	shr    $0x33,%rax
    325b:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    325e:	83 f8 04             	cmp    $0x4,%eax
    3261:	0f 85 d4 fe ff ff    	jne    313b <f2fs_write_begin+0x16b>
	switch (page->pgmap->type) {
    3267:	49 8b 45 08          	mov    0x8(%r13),%rax
    326b:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3271:	83 e8 01             	sub    $0x1,%eax
    3274:	83 f8 02             	cmp    $0x2,%eax
    3277:	0f 87 be fe ff ff    	ja     313b <f2fs_write_begin+0x16b>
		__put_devmap_managed_page(page);
    327d:	4c 89 ef             	mov    %r13,%rdi
    3280:	e8 00 00 00 00       	callq  3285 <f2fs_write_begin+0x2b5>
		return;
    3285:	e9 bc fe ff ff       	jmpq   3146 <f2fs_write_begin+0x176>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    328a:	48 8b 07             	mov    (%rdi),%rax
    328d:	48 c1 e8 33          	shr    $0x33,%rax
    3291:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3294:	83 f8 04             	cmp    $0x4,%eax
    3297:	0f 85 cb fe ff ff    	jne    3168 <f2fs_write_begin+0x198>
	switch (page->pgmap->type) {
    329d:	48 8b 47 08          	mov    0x8(%rdi),%rax
    32a1:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    32a7:	83 e8 01             	sub    $0x1,%eax
    32aa:	83 f8 02             	cmp    $0x2,%eax
    32ad:	0f 87 b5 fe ff ff    	ja     3168 <f2fs_write_begin+0x198>
		__put_devmap_managed_page(page);
    32b3:	e8 00 00 00 00       	callq  32b8 <f2fs_write_begin+0x2e8>
		return;
    32b8:	e9 b5 fe ff ff       	jmpq   3172 <f2fs_write_begin+0x1a2>
		__put_page(page);
    32bd:	4c 89 ef             	mov    %r13,%rdi
    32c0:	e8 00 00 00 00       	callq  32c5 <f2fs_write_begin+0x2f5>
    32c5:	e9 7c fe ff ff       	jmpq   3146 <f2fs_write_begin+0x176>
    32ca:	e8 00 00 00 00       	callq  32cf <f2fs_write_begin+0x2ff>
    32cf:	e9 9e fe ff ff       	jmpq   3172 <f2fs_write_begin+0x1a2>
		err = PTR_ERR(ipage);
    32d4:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
    32da:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
	if (locked)
    32e1:	45 84 ed             	test   %r13b,%r13b
    32e4:	0f 85 b3 03 00 00    	jne    369d <f2fs_write_begin+0x6cd>
	if (err)
    32ea:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
    32f0:	85 c0                	test   %eax,%eax
    32f2:	0f 85 4a 08 00 00    	jne    3b42 <f2fs_write_begin+0xb72>
	if (need_balance && has_not_enough_free_secs(sbi, 0, 0)) {
    32f8:	80 7d 83 00          	cmpb   $0x0,-0x7d(%rbp)
    32fc:	0f 84 95 00 00 00    	je     3397 <f2fs_write_begin+0x3c7>
    3302:	4d 63 8c 24 80 04 00 	movslq 0x480(%r12),%r9
    3309:	00 
    330a:	4d 63 b4 24 74 04 00 	movslq 0x474(%r12),%r14
    3311:	00 
    3312:	4d 63 84 24 8c 04 00 	movslq 0x48c(%r12),%r8
    3319:	00 
    331a:	49 8b 44 24 48       	mov    0x48(%r12),%rax
	unsigned int pages_per_sec = sbi->segs_per_sec * sbi->blocks_per_seg;
    331f:	41 8b b4 24 28 04 00 	mov    0x428(%r12),%esi
    3326:	00 
    3327:	41 8b 8c 24 24 04 00 	mov    0x424(%r12),%ecx
    332e:	00 
	if (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))
    332f:	a8 08                	test   $0x8,%al
    3331:	75 64                	jne    3397 <f2fs_write_begin+0x3c7>
	return (struct f2fs_sm_info *)(sbi->sm_info);
    3333:	49 8b 7c 24 68       	mov    0x68(%r12),%rdi
	return GET_SEC_FROM_SEG(sbi, (unsigned int)reserved_segments(sbi));
    3338:	31 d2                	xor    %edx,%edx
	return FREE_I(sbi)->free_sections;
    333a:	48 8b 47 08          	mov    0x8(%rdi),%rax
    333e:	44 8b 58 08          	mov    0x8(%rax),%r11d
	return GET_SEC_FROM_SEG(sbi, (unsigned int)reserved_segments(sbi));
    3342:	8b 47 5c             	mov    0x5c(%rdi),%eax
    3345:	f7 f6                	div    %esi
    3347:	89 c3                	mov    %eax,%ebx
	if (free_sections(sbi) + freed == reserved_sections(sbi) + needed &&
    3349:	41 39 c3             	cmp    %eax,%r11d
    334c:	0f 84 5d 03 00 00    	je     36af <f2fs_write_begin+0x6df>
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    3352:	41 89 ca             	mov    %ecx,%r10d
						sbi->log_blocks_per_seg;
    3355:	41 8b 8c 24 20 04 00 	mov    0x420(%r12),%ecx
    335c:	00 
	return segs / sbi->segs_per_sec;
    335d:	31 d2                	xor    %edx,%edx
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    335f:	44 0f af d6          	imul   %esi,%r10d
    3363:	4b 8d 44 0a ff       	lea    -0x1(%r10,%r9,1),%rax
    3368:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    336b:	f7 f6                	div    %esi
    336d:	31 d2                	xor    %edx,%edx
    336f:	89 c7                	mov    %eax,%edi
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    3371:	4b 8d 44 02 ff       	lea    -0x1(%r10,%r8,1),%rax
    3376:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    3379:	f7 f6                	div    %esi
    337b:	31 d2                	xor    %edx,%edx
		(node_secs + 2 * dent_secs + imeta_secs +
    337d:	01 f8                	add    %edi,%eax
    337f:	01 c3                	add    %eax,%ebx
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    3381:	4b 8d 44 32 ff       	lea    -0x1(%r10,%r14,1),%rax
    3386:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    3389:	f7 f6                	div    %esi
    338b:	8d 04 43             	lea    (%rbx,%rax,2),%eax
    338e:	41 39 c3             	cmp    %eax,%r11d
    3391:	0f 86 d0 03 00 00    	jbe    3767 <f2fs_write_begin+0x797>
	f2fs_wait_on_page_writeback(page, DATA, false);
    3397:	31 d2                	xor    %edx,%edx
    3399:	31 f6                	xor    %esi,%esi
    339b:	4c 89 ff             	mov    %r15,%rdi
    339e:	e8 00 00 00 00       	callq  33a3 <f2fs_write_begin+0x3d3>
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    33a3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    33a7:	f6 80 60 02 00 00 04 	testb  $0x4,0x260(%rax)
    33ae:	0f 85 f5 01 00 00    	jne    35a9 <f2fs_write_begin+0x5d9>
	if (len == PAGE_SIZE || PageUptodate(page))
    33b4:	81 7d 84 00 10 00 00 	cmpl   $0x1000,-0x7c(%rbp)
    33bb:	74 16                	je     33d3 <f2fs_write_begin+0x403>
    33bd:	49 8b 57 08          	mov    0x8(%r15),%rdx
    33c1:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    33c5:	83 e2 01             	and    $0x1,%edx
    33c8:	49 0f 44 c7          	cmove  %r15,%rax
    33cc:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    33cf:	a8 08                	test   $0x8,%al
    33d1:	74 2b                	je     33fe <f2fs_write_begin+0x42e>
		return 0;
    33d3:	45 31 e4             	xor    %r12d,%r12d
}
    33d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    33da:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    33e1:	00 00 
    33e3:	0f 85 7f 08 00 00    	jne    3c68 <f2fs_write_begin+0xc98>
    33e9:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
    33f0:	44 89 e0             	mov    %r12d,%eax
    33f3:	5b                   	pop    %rbx
    33f4:	41 5c                	pop    %r12
    33f6:	41 5d                	pop    %r13
    33f8:	41 5e                	pop    %r14
    33fa:	41 5f                	pop    %r15
    33fc:	5d                   	pop    %rbp
    33fd:	c3                   	retq   
	if (!(pos & (PAGE_SIZE - 1)) && (pos + len) >= i_size_read(inode)) {
    33fe:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    3402:	25 ff 0f 00 00       	and    $0xfff,%eax
    3407:	0f 84 c7 01 00 00    	je     35d4 <f2fs_write_begin+0x604>
	if (blkaddr == NEW_ADDR) {
    340d:	83 bd 68 ff ff ff ff 	cmpl   $0xffffffff,-0x98(%rbp)
    3414:	0f 84 7b 07 00 00    	je     3b95 <f2fs_write_begin+0xbc5>
		err = f2fs_submit_page_read(inode, page, blkaddr);
    341a:	8b 95 68 ff ff ff    	mov    -0x98(%rbp),%edx
    3420:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    3424:	4c 89 fe             	mov    %r15,%rsi
    3427:	e8 a4 e4 ff ff       	callq  18d0 <f2fs_submit_page_read>
    342c:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
		if (err)
    3432:	85 c0                	test   %eax,%eax
    3434:	0f 85 08 07 00 00    	jne    3b42 <f2fs_write_begin+0xb72>
	might_sleep();
    343a:	e8 00 00 00 00       	callq  343f <f2fs_write_begin+0x46f>
    343f:	49 8b 57 08          	mov    0x8(%r15),%rdx
		return (struct page *) (head - 1);
    3443:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3447:	83 e2 01             	and    $0x1,%edx
    344a:	49 0f 44 c7          	cmove  %r15,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    344e:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    3454:	0f 82 0d 06 00 00    	jb     3a67 <f2fs_write_begin+0xa97>
		if (unlikely(page->mapping != mapping)) {
    345a:	49 8b 47 18          	mov    0x18(%r15),%rax
    345e:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
    3465:	0f 85 ae 05 00 00    	jne    3a19 <f2fs_write_begin+0xa49>
    346b:	49 8b 57 08          	mov    0x8(%r15),%rdx
    346f:	44 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12d
    3476:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    347a:	83 e2 01             	and    $0x1,%edx
    347d:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3481:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    3484:	a8 08                	test   $0x8,%al
    3486:	0f 85 d5 01 00 00    	jne    3661 <f2fs_write_begin+0x691>
			err = -EIO;
    348c:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    3492:	49 8b 57 08          	mov    0x8(%r15),%rdx
	if (unlikely(head & 1))
    3496:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    349a:	83 e2 01             	and    $0x1,%edx
    349d:	49 0f 44 c7          	cmove  %r15,%rax
    34a1:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    34a4:	a8 01                	test   $0x1,%al
    34a6:	0f 84 a2 06 00 00    	je     3b4e <f2fs_write_begin+0xb7e>
		unlock_page(page);
    34ac:	4c 89 ff             	mov    %r15,%rdi
    34af:	e8 00 00 00 00       	callq  34b4 <f2fs_write_begin+0x4e4>
    34b4:	49 8b 47 08          	mov    0x8(%r15),%rax
		return (struct page *) (head - 1);
    34b8:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    34bc:	a8 01                	test   $0x1,%al
    34be:	4c 0f 45 fa          	cmovne %rdx,%r15
    34c2:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    34c7:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
    34cc:	75 08                	jne    34d6 <f2fs_write_begin+0x506>
		__put_page(page);
    34ce:	4c 89 ff             	mov    %r15,%rdi
    34d1:	e8 00 00 00 00       	callq  34d6 <f2fs_write_begin+0x506>
	f2fs_write_failed(mapping, pos + len);
    34d6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    34dd:	8b 75 84             	mov    -0x7c(%rbp),%esi
    34e0:	48 03 75 88          	add    -0x78(%rbp),%rsi
    34e4:	48 8b 38             	mov    (%rax),%rdi
    34e7:	e8 c4 da ff ff       	callq  fb0 <f2fs_write_failed.isra.0>
	if (drop_atomic)
    34ec:	e9 e5 fe ff ff       	jmpq   33d6 <f2fs_write_begin+0x406>
TRACE_EVENT(f2fs_write_begin,
    34f1:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 34f8 <f2fs_write_begin+0x528>
    34f8:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    34fa:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 3502 <f2fs_write_begin+0x532>
    3501:	00 
    3502:	0f 83 2b fb ff ff    	jae    3033 <f2fs_write_begin+0x63>
    3508:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 350f <f2fs_write_begin+0x53f>
    350f:	48 85 db             	test   %rbx,%rbx
    3512:	74 41                	je     3555 <f2fs_write_begin+0x585>
    3514:	48 8b 03             	mov    (%rbx),%rax
    3517:	4c 8b 6d 90          	mov    -0x70(%rbp),%r13
    351b:	4c 89 b5 78 ff ff ff 	mov    %r14,-0x88(%rbp)
    3522:	45 89 c6             	mov    %r8d,%r14d
    3525:	4c 8b 7d 88          	mov    -0x78(%rbp),%r15
    3529:	44 8b 65 84          	mov    -0x7c(%rbp),%r12d
    352d:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    3531:	48 83 c3 18          	add    $0x18,%rbx
    3535:	45 89 f0             	mov    %r14d,%r8d
    3538:	44 89 e1             	mov    %r12d,%ecx
    353b:	4c 89 fa             	mov    %r15,%rdx
    353e:	4c 89 ee             	mov    %r13,%rsi
    3541:	e8 00 00 00 00       	callq  3546 <f2fs_write_begin+0x576>
    3546:	48 8b 03             	mov    (%rbx),%rax
    3549:	48 85 c0             	test   %rax,%rax
    354c:	75 df                	jne    352d <f2fs_write_begin+0x55d>
    354e:	4c 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%r14
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3555:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    3559:	48 8b 80 78 02 00 00 	mov    0x278(%rax),%rax
	if (f2fs_is_atomic_file(inode) &&
    3560:	f6 c4 80             	test   $0x80,%ah
    3563:	0f 84 de fa ff ff    	je     3047 <f2fs_write_begin+0x77>
		!f2fs_available_free_memory(sbi, INMEM_PAGES)) {
    3569:	be 05 00 00 00       	mov    $0x5,%esi
    356e:	4c 89 f7             	mov    %r14,%rdi
    3571:	e8 00 00 00 00       	callq  3576 <f2fs_write_begin+0x5a6>
	if (f2fs_is_atomic_file(inode) &&
    3576:	84 c0                	test   %al,%al
    3578:	0f 85 c9 fa ff ff    	jne    3047 <f2fs_write_begin+0x77>
	f2fs_write_failed(mapping, pos + len);
    357e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
    3585:	8b 75 84             	mov    -0x7c(%rbp),%esi
		err = -ENOMEM;
    3588:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
	f2fs_write_failed(mapping, pos + len);
    358e:	48 03 75 88          	add    -0x78(%rbp),%rsi
    3592:	48 8b 38             	mov    (%rax),%rdi
    3595:	e8 16 da ff ff       	callq  fb0 <f2fs_write_failed.isra.0>
		f2fs_drop_inmem_pages_all(sbi, false);
    359a:	31 f6                	xor    %esi,%esi
    359c:	4c 89 f7             	mov    %r14,%rdi
    359f:	e8 00 00 00 00       	callq  35a4 <f2fs_write_begin+0x5d4>
    35a4:	e9 2d fe ff ff       	jmpq   33d6 <f2fs_write_begin+0x406>
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    35a9:	0f b7 00             	movzwl (%rax),%eax
    35ac:	66 89 85 78 ff ff ff 	mov    %ax,-0x88(%rbp)
    35b3:	66 25 00 f0          	and    $0xf000,%ax
    35b7:	66 3d 00 80          	cmp    $0x8000,%ax
    35bb:	0f 85 f3 fd ff ff    	jne    33b4 <f2fs_write_begin+0x3e4>
		f2fs_wait_on_block_writeback(sbi, blkaddr);
    35c1:	8b b5 68 ff ff ff    	mov    -0x98(%rbp),%esi
    35c7:	4c 89 e7             	mov    %r12,%rdi
    35ca:	e8 00 00 00 00       	callq  35cf <f2fs_write_begin+0x5ff>
    35cf:	e9 e0 fd ff ff       	jmpq   33b4 <f2fs_write_begin+0x3e4>
	if (!(pos & (PAGE_SIZE - 1)) && (pos + len) >= i_size_read(inode)) {
    35d4:	8b 55 84             	mov    -0x7c(%rbp),%edx
    35d7:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
    35db:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
    35df:	48 01 d1             	add    %rdx,%rcx
    35e2:	48 3b 4b 50          	cmp    0x50(%rbx),%rcx
    35e6:	0f 8c 21 fe ff ff    	jl     340d <f2fs_write_begin+0x43d>
    35ec:	65 48 8b 0c 25 00 00 	mov    %gs:0x0,%rcx
    35f3:	00 00 
}
#endif

static __always_inline void pagefault_disabled_inc(void)
{
	current->pagefault_disabled++;
    35f5:	83 81 38 12 00 00 01 	addl   $0x1,0x1238(%rcx)
{
	void *kaddr = kmap_atomic(page);

	BUG_ON(end1 > PAGE_SIZE || end2 > PAGE_SIZE);

	if (end1 > start1)
    35fc:	8b 5d 84             	mov    -0x7c(%rbp),%ebx
    35ff:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
    3605:	77 45                	ja     364c <f2fs_write_begin+0x67c>
	return page_to_virt(page);
    3607:	4c 89 fe             	mov    %r15,%rsi
    360a:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 3611 <f2fs_write_begin+0x641>
		memset(kaddr + start1, 0, end1 - start1);
    3611:	b9 00 10 00 00       	mov    $0x1000,%ecx
    3616:	48 c1 fe 06          	sar    $0x6,%rsi
    361a:	29 d9                	sub    %ebx,%ecx
    361c:	48 c1 e6 0c          	shl    $0xc,%rsi
    3620:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 3627 <f2fs_write_begin+0x657>
    3627:	48 01 f2             	add    %rsi,%rdx
    362a:	83 f9 08             	cmp    $0x8,%ecx
    362d:	0f 83 0b 06 00 00    	jae    3c3e <f2fs_write_begin+0xc6e>
    3633:	f6 c1 04             	test   $0x4,%cl
    3636:	0f 85 31 06 00 00    	jne    3c6d <f2fs_write_begin+0xc9d>
    363c:	85 c9                	test   %ecx,%ecx
    363e:	74 0c                	je     364c <f2fs_write_begin+0x67c>
    3640:	c6 02 00             	movb   $0x0,(%rdx)
    3643:	f6 c1 02             	test   $0x2,%cl
    3646:	0f 85 34 06 00 00    	jne    3c80 <f2fs_write_begin+0xcb0>
    364c:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    3653:	00 00 
}

static __always_inline void pagefault_disabled_dec(void)
{
	current->pagefault_disabled--;
    3655:	83 a8 38 12 00 00 01 	subl   $0x1,0x1238(%rax)
    365c:	e9 72 fd ff ff       	jmpq   33d3 <f2fs_write_begin+0x403>
	return ret;
    3661:	e9 70 fd ff ff       	jmpq   33d6 <f2fs_write_begin+0x406>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3666:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    3668:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
    366c:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    366f:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    3673:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    367a:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    367f:	e9 9c fa ff ff       	jmpq   3120 <f2fs_write_begin+0x150>
		err = f2fs_convert_inline_inode(inode);
    3684:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    3688:	e8 00 00 00 00       	callq  368d <f2fs_write_begin+0x6bd>
    368d:	41 89 c4             	mov    %eax,%r12d
		if (err)
    3690:	85 c0                	test   %eax,%eax
    3692:	0f 84 bd f9 ff ff    	je     3055 <f2fs_write_begin+0x85>
    3698:	e9 39 fe ff ff       	jmpq   34d6 <f2fs_write_begin+0x506>
			up_read(&sbi->node_change);
    369d:	49 8d bc 24 00 02 00 	lea    0x200(%r12),%rdi
    36a4:	00 
    36a5:	e8 00 00 00 00       	callq  36aa <f2fs_write_begin+0x6da>
}
    36aa:	e9 3b fc ff ff       	jmpq   32ea <f2fs_write_begin+0x31a>
    36af:	41 8b 94 24 80 04 00 	mov    0x480(%r12),%edx
    36b6:	00 
    36b7:	41 8b 84 24 74 04 00 	mov    0x474(%r12),%eax
    36be:	00 
	unsigned int node_blocks = get_pages(sbi, F2FS_DIRTY_NODES) +
    36bf:	01 d0                	add    %edx,%eax
	return &sit_i->sentries[segno];
    36c1:	48 8b 17             	mov    (%rdi),%rdx
	unsigned int node_blocks = get_pages(sbi, F2FS_DIRTY_NODES) +
    36c4:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
    36ca:	41 8b 84 24 74 04 00 	mov    0x474(%r12),%eax
    36d1:	00 
	return &sit_i->sentries[segno];
    36d2:	48 8b 52 68          	mov    0x68(%rdx),%rdx
    36d6:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    36dc:	48 8b 47 18          	mov    0x18(%rdi),%rax
    36e0:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    36e7:	48 8d b8 ac 01 00 00 	lea    0x1ac(%rax),%rdi
    36ee:	4c 8d a8 fc 02 00 00 	lea    0x2fc(%rax),%r13
	return &sit_i->sentries[segno];
    36f5:	44 8b 17             	mov    (%rdi),%r10d
		left_blocks = sbi->blocks_per_seg -
    36f8:	89 c8                	mov    %ecx,%eax
			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
    36fa:	4f 8d 14 92          	lea    (%r10,%r10,4),%r10
    36fe:	46 0f b7 54 d2 02    	movzwl 0x2(%rdx,%r10,8),%r10d
    3704:	41 81 e2 ff 03 00 00 	and    $0x3ff,%r10d
		left_blocks = sbi->blocks_per_seg -
    370b:	44 29 d0             	sub    %r10d,%eax
		if (node_blocks > left_blocks)
    370e:	39 85 78 ff ff ff    	cmp    %eax,-0x88(%rbp)
    3714:	0f 87 38 fc ff ff    	ja     3352 <f2fs_write_begin+0x382>
	for (i = CURSEG_HOT_NODE; i <= CURSEG_COLD_NODE; i++) {
    371a:	48 83 c7 70          	add    $0x70,%rdi
    371e:	49 39 fd             	cmp    %rdi,%r13
    3721:	75 d2                	jne    36f5 <f2fs_write_begin+0x725>
    3723:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
	return &sit_i->sentries[segno];
    372a:	8b 40 5c             	mov    0x5c(%rax),%eax
			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
    372d:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    3731:	0f b7 44 c2 02       	movzwl 0x2(%rdx,%rax,8),%eax
	left_blocks = sbi->blocks_per_seg -
    3736:	89 ca                	mov    %ecx,%edx
			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
    3738:	25 ff 03 00 00       	and    $0x3ff,%eax
	left_blocks = sbi->blocks_per_seg -
    373d:	29 c2                	sub    %eax,%edx
	if (dent_blocks > left_blocks)
    373f:	39 95 50 ff ff ff    	cmp    %edx,-0xb0(%rbp)
    3745:	0f 86 4c fc ff ff    	jbe    3397 <f2fs_write_begin+0x3c7>
    374b:	e9 02 fc ff ff       	jmpq   3352 <f2fs_write_begin+0x382>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3750:	48 8b 83 78 02 00 00 	mov    0x278(%rbx),%rax
	if (!f2fs_has_inline_data(inode) && len == PAGE_SIZE &&
    3757:	a9 00 00 00 01       	test   $0x1000000,%eax
    375c:	0f 85 6a f9 ff ff    	jne    30cc <f2fs_write_begin+0xfc>
    3762:	e9 91 fb ff ff       	jmpq   32f8 <f2fs_write_begin+0x328>
		unlock_page(page);
    3767:	4c 89 ff             	mov    %r15,%rdi
    376a:	e8 00 00 00 00       	callq  376f <f2fs_write_begin+0x79f>
		f2fs_balance_fs(sbi, true);
    376f:	be 01 00 00 00       	mov    $0x1,%esi
    3774:	4c 89 e7             	mov    %r12,%rdi
    3777:	e8 00 00 00 00       	callq  377c <f2fs_write_begin+0x7ac>
	might_sleep();
    377c:	e8 00 00 00 00       	callq  3781 <f2fs_write_begin+0x7b1>
    3781:	49 8b 57 08          	mov    0x8(%r15),%rdx
		return (struct page *) (head - 1);
    3785:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3789:	83 e2 01             	and    $0x1,%edx
    378c:	49 0f 44 c7          	cmove  %r15,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    3790:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    3796:	0f 82 61 04 00 00    	jb     3bfd <f2fs_write_begin+0xc2d>
		if (page->mapping != mapping) {
    379c:	49 8b 57 18          	mov    0x18(%r15),%rdx
    37a0:	48 3b 95 70 ff ff ff 	cmp    -0x90(%rbp),%rdx
    37a7:	0f 84 ea fb ff ff    	je     3397 <f2fs_write_begin+0x3c7>
    37ad:	49 8b 4f 08          	mov    0x8(%r15),%rcx
    37b1:	48 8d 41 ff          	lea    -0x1(%rcx),%rax
    37b5:	83 e1 01             	and    $0x1,%ecx
    37b8:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    37bc:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    37bf:	a8 01                	test   $0x1,%al
    37c1:	0f 84 43 04 00 00    	je     3c0a <f2fs_write_begin+0xc3a>
		unlock_page(page);
    37c7:	4c 89 ff             	mov    %r15,%rdi
    37ca:	e8 00 00 00 00       	callq  37cf <f2fs_write_begin+0x7ff>
    37cf:	49 8b 47 08          	mov    0x8(%r15),%rax
    37d3:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    37d7:	a8 01                	test   $0x1,%al
    37d9:	4c 0f 45 fa          	cmovne %rdx,%r15
    37dd:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    37e2:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
    37e7:	0f 94 c3             	sete   %bl
    37ea:	0f 85 76 f8 ff ff    	jne    3066 <f2fs_write_begin+0x96>
		__put_page(page);
    37f0:	4c 89 ff             	mov    %r15,%rdi
    37f3:	e8 00 00 00 00       	callq  37f8 <f2fs_write_begin+0x828>
    37f8:	88 5d 83             	mov    %bl,-0x7d(%rbp)
    37fb:	e9 66 f8 ff ff       	jmpq   3066 <f2fs_write_begin+0x96>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3800:	49 8b 07             	mov    (%r15),%rax
    3803:	48 c1 e8 33          	shr    $0x33,%rax
    3807:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    380a:	83 f8 04             	cmp    $0x4,%eax
    380d:	0f 85 b4 fc ff ff    	jne    34c7 <f2fs_write_begin+0x4f7>
	switch (page->pgmap->type) {
    3813:	49 8b 47 08          	mov    0x8(%r15),%rax
    3817:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    381d:	83 e8 01             	sub    $0x1,%eax
    3820:	83 f8 02             	cmp    $0x2,%eax
    3823:	0f 87 9e fc ff ff    	ja     34c7 <f2fs_write_begin+0x4f7>
		__put_devmap_managed_page(page);
    3829:	4c 89 ff             	mov    %r15,%rdi
    382c:	e8 00 00 00 00       	callq  3831 <f2fs_write_begin+0x861>
		return;
    3831:	e9 a0 fc ff ff       	jmpq   34d6 <f2fs_write_begin+0x506>
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
    3836:	48 63 b3 08 04 00 00 	movslq 0x408(%rbx),%rsi
		if (pos + len <= MAX_INLINE_DATA(inode)) {
    383d:	ba 9a 03 00 00       	mov    $0x39a,%edx
    3842:	2b 93 10 04 00 00    	sub    0x410(%rbx),%edx
    3848:	44 89 bd 78 ff ff ff 	mov    %r15d,-0x88(%rbp)
    384f:	8b 4d 84             	mov    -0x7c(%rbp),%ecx
    3852:	48 03 4d 88          	add    -0x78(%rbp),%rcx
    3856:	48 c1 ee 02          	shr    $0x2,%rsi
    385a:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
    3861:	29 f2                	sub    %esi,%edx
    3863:	48 63 d2             	movslq %edx,%rdx
    3866:	48 c1 e2 02          	shl    $0x2,%rdx
    386a:	48 39 d1             	cmp    %rdx,%rcx
    386d:	0f 87 24 02 00 00    	ja     3a97 <f2fs_write_begin+0xac7>
			f2fs_do_read_inline_data(page, ipage);
    3873:	48 89 c6             	mov    %rax,%rsi
    3876:	4c 89 ff             	mov    %r15,%rdi
    3879:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    3880:	e8 00 00 00 00       	callq  3885 <f2fs_write_begin+0x8b5>
    3885:	48 8b 93 78 02 00 00 	mov    0x278(%rbx),%rdx
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    388c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    3893:	f7 c2 00 00 10 00    	test   $0x100000,%edx
    3899:	75 08                	jne    38a3 <f2fs_write_begin+0x8d3>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    389b:	f0 80 8b 7a 02 00 00 	lock orb $0x10,0x27a(%rbx)
    38a2:	10 
		f2fs_mark_inode_dirty_sync(inode, true);
    38a3:	be 01 00 00 00       	mov    $0x1,%esi
    38a8:	48 89 df             	mov    %rbx,%rdi
    38ab:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    38b2:	e8 00 00 00 00       	callq  38b7 <f2fs_write_begin+0x8e7>
			if (inode->i_nlink)
    38b7:	8b 53 48             	mov    0x48(%rbx),%edx
    38ba:	85 d2                	test   %edx,%edx
    38bc:	0f 85 66 02 00 00    	jne    3b28 <f2fs_write_begin+0xb58>
    38c2:	8b 45 cc             	mov    -0x34(%rbp),%eax
    38c5:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
	*node_changed = dn.node_changed;
    38cb:	0f b6 45 c9          	movzbl -0x37(%rbp),%eax
    38cf:	88 45 83             	mov    %al,-0x7d(%rbp)
	if (dn->node_page)
    38d2:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
    38d6:	4d 85 f6             	test   %r14,%r14
    38d9:	0f 84 ac 00 00 00    	je     398b <f2fs_write_begin+0x9bb>
    38df:	49 8b 56 08          	mov    0x8(%r14),%rdx
    38e3:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    38e7:	83 e2 01             	and    $0x1,%edx
    38ea:	49 0f 44 c6          	cmove  %r14,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    38ee:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    38f1:	a8 01                	test   $0x1,%al
    38f3:	0f 84 73 02 00 00    	je     3b6c <f2fs_write_begin+0xb9c>
		unlock_page(page);
    38f9:	4c 89 f7             	mov    %r14,%rdi
    38fc:	e8 00 00 00 00       	callq  3901 <f2fs_write_begin+0x931>
    3901:	49 8b 46 08          	mov    0x8(%r14),%rax
    3905:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3909:	a8 01                	test   $0x1,%al
    390b:	4c 0f 45 f2          	cmovne %rdx,%r14
    390f:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3914:	f0 41 ff 4e 34       	lock decl 0x34(%r14)
	if (put_page_testzero(page))
    3919:	0f 84 ed 00 00 00    	je     3a0c <f2fs_write_begin+0xa3c>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    391f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    3923:	48 85 ff             	test   %rdi,%rdi
    3926:	74 23                	je     394b <f2fs_write_begin+0x97b>
    3928:	48 3b 7d b8          	cmp    -0x48(%rbp),%rdi
    392c:	74 1d                	je     394b <f2fs_write_begin+0x97b>
    392e:	48 8b 47 08          	mov    0x8(%rdi),%rax
    3932:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3936:	a8 01                	test   $0x1,%al
    3938:	48 0f 45 fa          	cmovne %rdx,%rdi
    393c:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3941:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    3945:	0f 84 42 01 00 00    	je     3a8d <f2fs_write_begin+0xabd>
	dn->node_page = NULL;
    394b:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    3952:	00 
	dn->inode_page = NULL;
    3953:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    395a:	00 
}
    395b:	e9 81 f9 ff ff       	jmpq   32e1 <f2fs_write_begin+0x311>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3960:	49 8b 06             	mov    (%r14),%rax
    3963:	48 c1 e8 33          	shr    $0x33,%rax
    3967:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    396a:	83 f8 04             	cmp    $0x4,%eax
    396d:	75 a5                	jne    3914 <f2fs_write_begin+0x944>
	switch (page->pgmap->type) {
    396f:	49 8b 46 08          	mov    0x8(%r14),%rax
    3973:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3979:	83 e8 01             	sub    $0x1,%eax
    397c:	83 f8 02             	cmp    $0x2,%eax
    397f:	77 93                	ja     3914 <f2fs_write_begin+0x944>
		__put_devmap_managed_page(page);
    3981:	4c 89 f7             	mov    %r14,%rdi
    3984:	e8 00 00 00 00       	callq  3989 <f2fs_write_begin+0x9b9>
		return;
    3989:	eb 94                	jmp    391f <f2fs_write_begin+0x94f>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    398b:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    398f:	48 85 ff             	test   %rdi,%rdi
    3992:	75 9a                	jne    392e <f2fs_write_begin+0x95e>
    3994:	eb b5                	jmp    394b <f2fs_write_begin+0x97b>
    3996:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
		err = f2fs_get_block(&dn, index);
    399d:	4c 89 f6             	mov    %r14,%rsi
    39a0:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
    39a4:	e8 00 00 00 00       	callq  39a9 <f2fs_write_begin+0x9d9>
    39a9:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
    39af:	e9 0e ff ff ff       	jmpq   38c2 <f2fs_write_begin+0x8f2>
			dn.data_blkaddr = ei.blk + index - ei.fofs;
    39b4:	8b 45 a4             	mov    -0x5c(%rbp),%eax
    39b7:	2b 45 9c             	sub    -0x64(%rbp),%eax
    39ba:	44 89 bd 78 ff ff ff 	mov    %r15d,-0x88(%rbp)
    39c1:	44 01 f0             	add    %r14d,%eax
    39c4:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
    39cb:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
    39d1:	89 45 cc             	mov    %eax,-0x34(%rbp)
    39d4:	e9 f2 fe ff ff       	jmpq   38cb <f2fs_write_begin+0x8fb>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    39d9:	48 8b 07             	mov    (%rdi),%rax
    39dc:	48 c1 e8 33          	shr    $0x33,%rax
    39e0:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    39e3:	83 f8 04             	cmp    $0x4,%eax
    39e6:	0f 85 55 ff ff ff    	jne    3941 <f2fs_write_begin+0x971>
	switch (page->pgmap->type) {
    39ec:	48 8b 47 08          	mov    0x8(%rdi),%rax
    39f0:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    39f6:	83 e8 01             	sub    $0x1,%eax
    39f9:	83 f8 02             	cmp    $0x2,%eax
    39fc:	0f 87 3f ff ff ff    	ja     3941 <f2fs_write_begin+0x971>
		__put_devmap_managed_page(page);
    3a02:	e8 00 00 00 00       	callq  3a07 <f2fs_write_begin+0xa37>
		return;
    3a07:	e9 3f ff ff ff       	jmpq   394b <f2fs_write_begin+0x97b>
		__put_page(page);
    3a0c:	4c 89 f7             	mov    %r14,%rdi
    3a0f:	e8 00 00 00 00       	callq  3a14 <f2fs_write_begin+0xa44>
    3a14:	e9 06 ff ff ff       	jmpq   391f <f2fs_write_begin+0x94f>
    3a19:	49 8b 4f 08          	mov    0x8(%r15),%rcx
    3a1d:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    3a21:	83 e1 01             	and    $0x1,%ecx
    3a24:	49 0f 44 d7          	cmove  %r15,%rdx
    3a28:	48 8b 12             	mov    (%rdx),%rdx
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3a2b:	83 e2 01             	and    $0x1,%edx
    3a2e:	0f 84 f0 01 00 00    	je     3c24 <f2fs_write_begin+0xc54>
		unlock_page(page);
    3a34:	4c 89 ff             	mov    %r15,%rdi
    3a37:	e8 00 00 00 00       	callq  3a3c <f2fs_write_begin+0xa6c>
    3a3c:	49 8b 47 08          	mov    0x8(%r15),%rax
    3a40:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3a44:	a8 01                	test   $0x1,%al
    3a46:	4c 0f 45 fa          	cmovne %rdx,%r15
    3a4a:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3a4f:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
	if (put_page_testzero(page))
    3a54:	0f 85 0c f6 ff ff    	jne    3066 <f2fs_write_begin+0x96>
		__put_page(page);
    3a5a:	4c 89 ff             	mov    %r15,%rdi
    3a5d:	e8 00 00 00 00       	callq  3a62 <f2fs_write_begin+0xa92>
    3a62:	e9 ff f5 ff ff       	jmpq   3066 <f2fs_write_begin+0x96>
		__lock_page(page);
    3a67:	4c 89 ff             	mov    %r15,%rdi
    3a6a:	e8 00 00 00 00       	callq  3a6f <f2fs_write_begin+0xa9f>
    3a6f:	e9 e6 f9 ff ff       	jmpq   345a <f2fs_write_begin+0x48a>
    3a74:	44 89 bd 78 ff ff ff 	mov    %r15d,-0x88(%rbp)
    3a7b:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
			if (err || dn.data_blkaddr == NULL_ADDR) {
    3a82:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
    3a88:	e9 3e fe ff ff       	jmpq   38cb <f2fs_write_begin+0x8fb>
    3a8d:	e8 00 00 00 00       	callq  3a92 <f2fs_write_begin+0xac2>
    3a92:	e9 b4 fe ff ff       	jmpq   394b <f2fs_write_begin+0x97b>
			err = f2fs_convert_inline_page(&dn, page);
    3a97:	4c 89 fe             	mov    %r15,%rsi
    3a9a:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
    3a9e:	e8 00 00 00 00       	callq  3aa3 <f2fs_write_begin+0xad3>
    3aa3:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
			if (err)
    3aa9:	85 c0                	test   %eax,%eax
    3aab:	0f 85 21 fe ff ff    	jne    38d2 <f2fs_write_begin+0x902>
			if (dn.data_blkaddr == NULL_ADDR)
    3ab1:	8b 45 cc             	mov    -0x34(%rbp),%eax
    3ab4:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
    3aba:	85 c0                	test   %eax,%eax
    3abc:	0f 85 09 fe ff ff    	jne    38cb <f2fs_write_begin+0x8fb>
    3ac2:	e9 d6 fe ff ff       	jmpq   399d <f2fs_write_begin+0x9cd>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3ac7:	49 8b 07             	mov    (%r15),%rax
    3aca:	48 c1 e8 33          	shr    $0x33,%rax
    3ace:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3ad1:	83 f8 04             	cmp    $0x4,%eax
    3ad4:	0f 85 08 fd ff ff    	jne    37e2 <f2fs_write_begin+0x812>
	switch (page->pgmap->type) {
    3ada:	49 8b 47 08          	mov    0x8(%r15),%rax
    3ade:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3ae4:	83 e8 01             	sub    $0x1,%eax
    3ae7:	83 f8 02             	cmp    $0x2,%eax
    3aea:	0f 87 f2 fc ff ff    	ja     37e2 <f2fs_write_begin+0x812>
		__put_devmap_managed_page(page);
    3af0:	4c 89 ff             	mov    %r15,%rdi
    3af3:	e8 00 00 00 00       	callq  3af8 <f2fs_write_begin+0xb28>
		return;
    3af8:	e9 69 f5 ff ff       	jmpq   3066 <f2fs_write_begin+0x96>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3afd:	49 8b 07             	mov    (%r15),%rax
    3b00:	48 c1 e8 33          	shr    $0x33,%rax
    3b04:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3b07:	83 f8 04             	cmp    $0x4,%eax
    3b0a:	0f 85 3f ff ff ff    	jne    3a4f <f2fs_write_begin+0xa7f>
	switch (page->pgmap->type) {
    3b10:	49 8b 47 08          	mov    0x8(%r15),%rax
    3b14:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3b1a:	83 e8 01             	sub    $0x1,%eax
    3b1d:	83 f8 02             	cmp    $0x2,%eax
    3b20:	0f 87 29 ff ff ff    	ja     3a4f <f2fs_write_begin+0xa7f>
    3b26:	eb c8                	jmp    3af0 <f2fs_write_begin+0xb20>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    3b28:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    3b2f:	f0 80 48 01 02       	lock orb $0x2,0x1(%rax)
    3b34:	8b 45 cc             	mov    -0x34(%rbp),%eax
    3b37:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
}

static inline void set_inline_node(struct page *page)
{
	SetPageChecked(page);
}
    3b3d:	e9 89 fd ff ff       	jmpq   38cb <f2fs_write_begin+0x8fb>
    3b42:	44 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12d
    3b49:	e9 44 f9 ff ff       	jmpq   3492 <f2fs_write_begin+0x4c2>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3b4e:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    3b50:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
    3b54:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    3b57:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    3b5b:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    3b62:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    3b67:	e9 40 f9 ff ff       	jmpq   34ac <f2fs_write_begin+0x4dc>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3b6c:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    3b6e:	49 8b 46 18          	mov    0x18(%r14),%rax
	return F2FS_SB(inode->i_sb);
    3b72:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    3b75:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    3b79:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    3b80:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    3b85:	e9 6f fd ff ff       	jmpq   38f9 <f2fs_write_begin+0x929>
		err = -ENOMEM;
    3b8a:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
    3b90:	e9 41 f9 ff ff       	jmpq   34d6 <f2fs_write_begin+0x506>
    3b95:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    3b9c:	00 00 
	current->pagefault_disabled++;
    3b9e:	83 82 38 12 00 00 01 	addl   $0x1,0x1238(%rdx)
	return page_to_virt(page);
    3ba5:	4c 89 f8             	mov    %r15,%rax
    3ba8:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 3baf <f2fs_write_begin+0xbdf>
    3baf:	48 c1 f8 06          	sar    $0x6,%rax
    3bb3:	48 c1 e0 0c          	shl    $0xc,%rax
    3bb7:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 3bbe <f2fs_write_begin+0xbee>
    3bbe:	48 8d 78 08          	lea    0x8(%rax),%rdi
    3bc2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    3bc9:	48 c7 80 f8 0f 00 00 	movq   $0x0,0xff8(%rax)
    3bd0:	00 00 00 00 
    3bd4:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    3bd8:	48 29 f8             	sub    %rdi,%rax
    3bdb:	8d 88 00 10 00 00    	lea    0x1000(%rax),%ecx
    3be1:	31 c0                	xor    %eax,%eax
    3be3:	c1 e9 03             	shr    $0x3,%ecx
    3be6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	current->pagefault_disabled--;
    3be9:	83 aa 38 12 00 00 01 	subl   $0x1,0x1238(%rdx)
    3bf0:	f0 41 80 0f 08       	lock orb $0x8,(%r15)
	return 0;
    3bf5:	45 31 e4             	xor    %r12d,%r12d
}
    3bf8:	e9 d9 f7 ff ff       	jmpq   33d6 <f2fs_write_begin+0x406>
    3bfd:	4c 89 ff             	mov    %r15,%rdi
    3c00:	e8 00 00 00 00       	callq  3c05 <f2fs_write_begin+0xc35>
    3c05:	e9 92 fb ff ff       	jmpq   379c <f2fs_write_begin+0x7cc>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3c0a:	0f 0b                	ud2    
	return F2FS_SB(inode->i_sb);
    3c0c:	48 8b 02             	mov    (%rdx),%rax
	return sb->s_fs_info;
    3c0f:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    3c13:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    3c1a:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    3c1f:	e9 a3 fb ff ff       	jmpq   37c7 <f2fs_write_begin+0x7f7>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3c24:	0f 0b                	ud2    
	return F2FS_SB(inode->i_sb);
    3c26:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    3c29:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    3c2d:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    3c34:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    3c39:	e9 f6 fd ff ff       	jmpq   3a34 <f2fs_write_begin+0xa64>
    3c3e:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
    3c42:	89 ce                	mov    %ecx,%esi
    3c44:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    3c4b:	48 c7 44 32 f8 00 00 	movq   $0x0,-0x8(%rdx,%rsi,1)
    3c52:	00 00 
    3c54:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    3c58:	48 29 fa             	sub    %rdi,%rdx
    3c5b:	01 d1                	add    %edx,%ecx
    3c5d:	c1 e9 03             	shr    $0x3,%ecx
    3c60:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    3c63:	e9 e4 f9 ff ff       	jmpq   364c <f2fs_write_begin+0x67c>
}
    3c68:	e8 00 00 00 00       	callq  3c6d <f2fs_write_begin+0xc9d>
    3c6d:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
    3c73:	c7 44 0a fc 00 00 00 	movl   $0x0,-0x4(%rdx,%rcx,1)
    3c7a:	00 
    3c7b:	e9 cc f9 ff ff       	jmpq   364c <f2fs_write_begin+0x67c>
    3c80:	66 c7 44 0a fe 00 00 	movw   $0x0,-0x2(%rdx,%rcx,1)
    3c87:	e9 c0 f9 ff ff       	jmpq   364c <f2fs_write_begin+0x67c>
    3c8c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003c90 <f2fs_get_read_data_page>:
									 int op_flags, bool for_write) {
    3c90:	f3 0f 1e fa          	endbr64 
    3c94:	e8 00 00 00 00       	callq  3c99 <f2fs_get_read_data_page+0x9>
    3c99:	55                   	push   %rbp
    3c9a:	48 89 e5             	mov    %rsp,%rbp
    3c9d:	41 56                	push   %r14
    3c9f:	49 89 fe             	mov    %rdi,%r14
    3ca2:	41 55                	push   %r13
    3ca4:	49 89 f5             	mov    %rsi,%r13
    3ca7:	41 54                	push   %r12
    3ca9:	48 83 ec 40          	sub    $0x40,%rsp
	struct address_space *mapping = inode->i_mapping;
    3cad:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
									 int op_flags, bool for_write) {
    3cb1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    3cb8:	00 00 
    3cba:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    3cbe:	31 c0                	xor    %eax,%eax
	struct extent_info ei = {0, 0, 0};
    3cc0:	48 c7 45 ac 00 00 00 	movq   $0x0,-0x54(%rbp)
    3cc7:	00 
    3cc8:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
	if (!for_write)
    3ccf:	84 c9                	test   %cl,%cl
    3cd1:	0f 84 c1 01 00 00    	je     3e98 <f2fs_get_read_data_page+0x208>
	return grab_cache_page_write_begin(mapping, index, AOP_FLAG_NOFS);
    3cd7:	ba 02 00 00 00       	mov    $0x2,%edx
    3cdc:	e8 00 00 00 00       	callq  3ce1 <f2fs_get_read_data_page+0x51>
    3ce1:	49 89 c4             	mov    %rax,%r12
	if (!page)
    3ce4:	4d 85 e4             	test   %r12,%r12
    3ce7:	0f 84 c7 01 00 00    	je     3eb4 <f2fs_get_read_data_page+0x224>
	if (f2fs_lookup_extent_cache(inode, index, &ei)) {
    3ced:	48 8d 55 ac          	lea    -0x54(%rbp),%rdx
    3cf1:	4c 89 ee             	mov    %r13,%rsi
    3cf4:	4c 89 f7             	mov    %r14,%rdi
    3cf7:	e8 00 00 00 00       	callq  3cfc <f2fs_get_read_data_page+0x6c>
    3cfc:	84 c0                	test   %al,%al
    3cfe:	74 51                	je     3d51 <f2fs_get_read_data_page+0xc1>
		dn.data_blkaddr = ei.blk + index - ei.fofs;
    3d00:	8b 75 b4             	mov    -0x4c(%rbp),%esi
    3d03:	2b 75 ac             	sub    -0x54(%rbp),%esi
    3d06:	44 01 ee             	add    %r13d,%esi
    3d09:	89 75 dc             	mov    %esi,-0x24(%rbp)
    3d0c:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
    3d11:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3d15:	83 e2 01             	and    $0x1,%edx
    3d18:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3d1c:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    3d1f:	a8 08                	test   $0x8,%al
    3d21:	0f 84 04 01 00 00    	je     3e2b <f2fs_get_read_data_page+0x19b>
		unlock_page(page);
    3d27:	4c 89 e7             	mov    %r12,%rdi
    3d2a:	e8 00 00 00 00       	callq  3d2f <f2fs_get_read_data_page+0x9f>
}
    3d2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3d33:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    3d3a:	00 00 
    3d3c:	0f 85 09 03 00 00    	jne    404b <f2fs_get_read_data_page+0x3bb>
    3d42:	48 83 c4 40          	add    $0x40,%rsp
    3d46:	4c 89 e0             	mov    %r12,%rax
    3d49:	41 5c                	pop    %r12
    3d4b:	41 5d                	pop    %r13
    3d4d:	41 5e                	pop    %r14
    3d4f:	5d                   	pop    %rbp
    3d50:	c3                   	retq   
	err = f2fs_get_dnode_of_data(&dn, index, LOOKUP_NODE);
    3d51:	ba 01 00 00 00       	mov    $0x1,%edx
    3d56:	4c 89 ee             	mov    %r13,%rsi
    3d59:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
	dn->inode = inode;
    3d5d:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
    3d61:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    3d68:	00 
    3d69:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    3d70:	00 
	dn->inode_page = ipage;
    3d71:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    3d78:	00 
	dn->node_page = npage;
    3d79:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    3d80:	00 
    3d81:	e8 00 00 00 00       	callq  3d86 <f2fs_get_read_data_page+0xf6>
	if (err)
    3d86:	85 c0                	test   %eax,%eax
    3d88:	0f 85 bc 00 00 00    	jne    3e4a <f2fs_get_read_data_page+0x1ba>
	if (dn->node_page)
    3d8e:	4c 8b 6d c8          	mov    -0x38(%rbp),%r13
    3d92:	4d 85 ed             	test   %r13,%r13
    3d95:	0f 84 52 01 00 00    	je     3eed <f2fs_get_read_data_page+0x25d>
    3d9b:	49 8b 55 08          	mov    0x8(%r13),%rdx
		return (struct page *) (head - 1);
    3d9f:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3da3:	83 e2 01             	and    $0x1,%edx
    3da6:	49 0f 44 c5          	cmove  %r13,%rax
    3daa:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3dad:	a8 01                	test   $0x1,%al
    3daf:	0f 84 78 02 00 00    	je     402d <f2fs_get_read_data_page+0x39d>
		unlock_page(page);
    3db5:	4c 89 ef             	mov    %r13,%rdi
    3db8:	e8 00 00 00 00       	callq  3dbd <f2fs_get_read_data_page+0x12d>
    3dbd:	49 8b 45 08          	mov    0x8(%r13),%rax
    3dc1:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3dc5:	a8 01                	test   $0x1,%al
    3dc7:	4c 0f 45 ea          	cmovne %rdx,%r13
    3dcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3dd0:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
	if (put_page_testzero(page))
    3dd5:	0f 84 1c 02 00 00    	je     3ff7 <f2fs_get_read_data_page+0x367>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    3ddb:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    3ddf:	48 85 ff             	test   %rdi,%rdi
    3de2:	74 23                	je     3e07 <f2fs_get_read_data_page+0x177>
    3de4:	48 3b 7d c8          	cmp    -0x38(%rbp),%rdi
    3de8:	74 1d                	je     3e07 <f2fs_get_read_data_page+0x177>
    3dea:	48 8b 47 08          	mov    0x8(%rdi),%rax
    3dee:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3df2:	a8 01                	test   $0x1,%al
    3df4:	48 0f 45 fa          	cmovne %rdx,%rdi
    3df8:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3dfd:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    3e01:	0f 84 fd 01 00 00    	je     4004 <f2fs_get_read_data_page+0x374>
	if (unlikely(dn.data_blkaddr == NULL_ADDR)) {
    3e07:	8b 45 dc             	mov    -0x24(%rbp),%eax
	dn->node_page = NULL;
    3e0a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    3e11:	00 
	dn->inode_page = NULL;
    3e12:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    3e19:	00 
    3e1a:	85 c0                	test   %eax,%eax
    3e1c:	0f 85 ea fe ff ff    	jne    3d0c <f2fs_get_read_data_page+0x7c>
    3e22:	49 c7 c5 fe ff ff ff 	mov    $0xfffffffffffffffe,%r13
    3e29:	eb 22                	jmp    3e4d <f2fs_get_read_data_page+0x1bd>
	if (dn.data_blkaddr == NEW_ADDR) {
    3e2b:	8b 55 dc             	mov    -0x24(%rbp),%edx
    3e2e:	83 fa ff             	cmp    $0xffffffff,%edx
    3e31:	0f 84 c8 00 00 00    	je     3eff <f2fs_get_read_data_page+0x26f>
	err = f2fs_submit_page_read(inode, page, dn.data_blkaddr);
    3e37:	4c 89 e6             	mov    %r12,%rsi
    3e3a:	4c 89 f7             	mov    %r14,%rdi
    3e3d:	e8 8e da ff ff       	callq  18d0 <f2fs_submit_page_read>
	if (err)
    3e42:	85 c0                	test   %eax,%eax
    3e44:	0f 84 e5 fe ff ff    	je     3d2f <f2fs_get_read_data_page+0x9f>
    3e4a:	4c 63 e8             	movslq %eax,%r13
    3e4d:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    3e52:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3e56:	83 e2 01             	and    $0x1,%edx
    3e59:	49 0f 44 c4          	cmove  %r12,%rax
    3e5d:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    3e60:	a8 01                	test   $0x1,%al
    3e62:	0f 84 a6 01 00 00    	je     400e <f2fs_get_read_data_page+0x37e>
		unlock_page(page);
    3e68:	4c 89 e7             	mov    %r12,%rdi
    3e6b:	e8 00 00 00 00       	callq  3e70 <f2fs_get_read_data_page+0x1e0>
    3e70:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3e75:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    3e79:	a8 01                	test   $0x1,%al
    3e7b:	4c 0f 45 e2          	cmovne %rdx,%r12
    3e7f:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    3e84:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
    3e8a:	0f 84 27 01 00 00    	je     3fb7 <f2fs_get_read_data_page+0x327>
	return ERR_PTR(err);
    3e90:	4d 89 ec             	mov    %r13,%r12
    3e93:	e9 97 fe ff ff       	jmpq   3d2f <f2fs_get_read_data_page+0x9f>
	return pagecache_get_page(mapping, offset,
    3e98:	8b 8f 84 00 00 00    	mov    0x84(%rdi),%ecx
    3e9e:	ba 07 00 00 00       	mov    $0x7,%edx
    3ea3:	e8 00 00 00 00       	callq  3ea8 <f2fs_get_read_data_page+0x218>
    3ea8:	49 89 c4             	mov    %rax,%r12
	if (!page)
    3eab:	4d 85 e4             	test   %r12,%r12
    3eae:	0f 85 39 fe ff ff    	jne    3ced <f2fs_get_read_data_page+0x5d>
		return ERR_PTR(-ENOMEM);
    3eb4:	49 c7 c4 f4 ff ff ff 	mov    $0xfffffffffffffff4,%r12
    3ebb:	e9 6f fe ff ff       	jmpq   3d2f <f2fs_get_read_data_page+0x9f>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3ec0:	49 8b 04 24          	mov    (%r12),%rax
    3ec4:	48 c1 e8 33          	shr    $0x33,%rax
    3ec8:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3ecb:	83 f8 04             	cmp    $0x4,%eax
    3ece:	75 b4                	jne    3e84 <f2fs_get_read_data_page+0x1f4>
	switch (page->pgmap->type) {
    3ed0:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    3ed5:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3edb:	83 e8 01             	sub    $0x1,%eax
    3ede:	83 f8 02             	cmp    $0x2,%eax
    3ee1:	77 a1                	ja     3e84 <f2fs_get_read_data_page+0x1f4>
		__put_devmap_managed_page(page);
    3ee3:	4c 89 e7             	mov    %r12,%rdi
    3ee6:	e8 00 00 00 00       	callq  3eeb <f2fs_get_read_data_page+0x25b>
		return;
    3eeb:	eb a3                	jmp    3e90 <f2fs_get_read_data_page+0x200>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    3eed:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    3ef1:	48 85 ff             	test   %rdi,%rdi
    3ef4:	0f 85 f0 fe ff ff    	jne    3dea <f2fs_get_read_data_page+0x15a>
    3efa:	e9 08 ff ff ff       	jmpq   3e07 <f2fs_get_read_data_page+0x177>
    3eff:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    3f06:	00 00 
	current->pagefault_disabled++;
    3f08:	83 82 38 12 00 00 01 	addl   $0x1,0x1238(%rdx)
	return page_to_virt(page);
    3f0f:	4c 89 e0             	mov    %r12,%rax
    3f12:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 3f19 <f2fs_get_read_data_page+0x289>
    3f19:	48 c1 f8 06          	sar    $0x6,%rax
    3f1d:	48 c1 e0 0c          	shl    $0xc,%rax
    3f21:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 3f28 <f2fs_get_read_data_page+0x298>
    3f28:	48 8d 78 08          	lea    0x8(%rax),%rdi
    3f2c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    3f33:	48 c7 80 f8 0f 00 00 	movq   $0x0,0xff8(%rax)
    3f3a:	00 00 00 00 
    3f3e:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    3f42:	48 29 f8             	sub    %rdi,%rax
    3f45:	8d 88 00 10 00 00    	lea    0x1000(%rax),%ecx
    3f4b:	31 c0                	xor    %eax,%eax
    3f4d:	c1 e9 03             	shr    $0x3,%ecx
    3f50:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	current->pagefault_disabled--;
    3f53:	83 aa 38 12 00 00 01 	subl   $0x1,0x1238(%rdx)
    3f5a:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    3f5f:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    3f63:	83 e2 01             	and    $0x1,%edx
    3f66:	49 0f 44 c4          	cmove  %r12,%rax
    3f6a:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    3f6d:	a8 08                	test   $0x8,%al
    3f6f:	0f 85 b2 fd ff ff    	jne    3d27 <f2fs_get_read_data_page+0x97>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    3f75:	f0 41 80 0c 24 08    	lock orb $0x8,(%r12)
}
    3f7b:	e9 a7 fd ff ff       	jmpq   3d27 <f2fs_get_read_data_page+0x97>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3f80:	49 8b 45 00          	mov    0x0(%r13),%rax
    3f84:	48 c1 e8 33          	shr    $0x33,%rax
    3f88:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3f8b:	83 f8 04             	cmp    $0x4,%eax
    3f8e:	0f 85 3c fe ff ff    	jne    3dd0 <f2fs_get_read_data_page+0x140>
	switch (page->pgmap->type) {
    3f94:	49 8b 45 08          	mov    0x8(%r13),%rax
    3f98:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3f9e:	83 e8 01             	sub    $0x1,%eax
    3fa1:	83 f8 02             	cmp    $0x2,%eax
    3fa4:	0f 87 26 fe ff ff    	ja     3dd0 <f2fs_get_read_data_page+0x140>
		__put_devmap_managed_page(page);
    3faa:	4c 89 ef             	mov    %r13,%rdi
    3fad:	e8 00 00 00 00       	callq  3fb2 <f2fs_get_read_data_page+0x322>
		return;
    3fb2:	e9 24 fe ff ff       	jmpq   3ddb <f2fs_get_read_data_page+0x14b>
		__put_page(page);
    3fb7:	4c 89 e7             	mov    %r12,%rdi
    3fba:	e8 00 00 00 00       	callq  3fbf <f2fs_get_read_data_page+0x32f>
    3fbf:	e9 cc fe ff ff       	jmpq   3e90 <f2fs_get_read_data_page+0x200>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    3fc4:	48 8b 07             	mov    (%rdi),%rax
    3fc7:	48 c1 e8 33          	shr    $0x33,%rax
    3fcb:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    3fce:	83 f8 04             	cmp    $0x4,%eax
    3fd1:	0f 85 26 fe ff ff    	jne    3dfd <f2fs_get_read_data_page+0x16d>
	switch (page->pgmap->type) {
    3fd7:	48 8b 47 08          	mov    0x8(%rdi),%rax
    3fdb:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    3fe1:	83 e8 01             	sub    $0x1,%eax
    3fe4:	83 f8 02             	cmp    $0x2,%eax
    3fe7:	0f 87 10 fe ff ff    	ja     3dfd <f2fs_get_read_data_page+0x16d>
		__put_devmap_managed_page(page);
    3fed:	e8 00 00 00 00       	callq  3ff2 <f2fs_get_read_data_page+0x362>
		return;
    3ff2:	e9 10 fe ff ff       	jmpq   3e07 <f2fs_get_read_data_page+0x177>
		__put_page(page);
    3ff7:	4c 89 ef             	mov    %r13,%rdi
    3ffa:	e8 00 00 00 00       	callq  3fff <f2fs_get_read_data_page+0x36f>
    3fff:	e9 d7 fd ff ff       	jmpq   3ddb <f2fs_get_read_data_page+0x14b>
    4004:	e8 00 00 00 00       	callq  4009 <f2fs_get_read_data_page+0x379>
    4009:	e9 f9 fd ff ff       	jmpq   3e07 <f2fs_get_read_data_page+0x177>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    400e:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    4010:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    4015:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    4018:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    401c:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    4023:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    4028:	e9 3b fe ff ff       	jmpq   3e68 <f2fs_get_read_data_page+0x1d8>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    402d:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    402f:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
    4033:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    4036:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    403a:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    4041:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    4046:	e9 6a fd ff ff       	jmpq   3db5 <f2fs_get_read_data_page+0x125>
}
    404b:	e8 00 00 00 00       	callq  4050 <f2fs_find_data_page>

0000000000004050 <f2fs_find_data_page>:
struct page *f2fs_find_data_page(struct inode *inode, pgoff_t index) {
    4050:	f3 0f 1e fa          	endbr64 
    4054:	e8 00 00 00 00       	callq  4059 <f2fs_find_data_page+0x9>
    4059:	55                   	push   %rbp
	return pagecache_get_page(mapping, offset, 0, 0);
    405a:	31 c9                	xor    %ecx,%ecx
    405c:	31 d2                	xor    %edx,%edx
    405e:	48 89 e5             	mov    %rsp,%rbp
    4061:	41 55                	push   %r13
    4063:	49 89 f5             	mov    %rsi,%r13
    4066:	41 54                	push   %r12
    4068:	49 89 fc             	mov    %rdi,%r12
    406b:	48 83 ec 08          	sub    $0x8,%rsp
    406f:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    4073:	e8 00 00 00 00       	callq  4078 <f2fs_find_data_page+0x28>
	if (page && PageUptodate(page))
    4078:	48 85 c0             	test   %rax,%rax
    407b:	74 43                	je     40c0 <f2fs_find_data_page+0x70>
    407d:	48 8b 48 08          	mov    0x8(%rax),%rcx
		return (struct page *) (head - 1);
    4081:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    4085:	83 e1 01             	and    $0x1,%ecx
    4088:	48 0f 44 d0          	cmove  %rax,%rdx
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    408c:	48 8b 12             	mov    (%rdx),%rdx
	if (ret)
    408f:	83 e2 08             	and    $0x8,%edx
    4092:	74 0a                	je     409e <f2fs_find_data_page+0x4e>
}
    4094:	48 83 c4 08          	add    $0x8,%rsp
    4098:	41 5c                	pop    %r12
    409a:	41 5d                	pop    %r13
    409c:	5d                   	pop    %rbp
    409d:	c3                   	retq   
    409e:	48 8b 50 08          	mov    0x8(%rax),%rdx
		return (struct page *) (head - 1);
    40a2:	48 8d 4a ff          	lea    -0x1(%rdx),%rcx
    40a6:	83 e2 01             	and    $0x1,%edx
    40a9:	48 0f 45 c1          	cmovne %rcx,%rax
    40ad:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    40b2:	f0 ff 48 34          	lock decl 0x34(%rax)
	if (put_page_testzero(page))
    40b6:	75 08                	jne    40c0 <f2fs_find_data_page+0x70>
		__put_page(page);
    40b8:	48 89 c7             	mov    %rax,%rdi
    40bb:	e8 00 00 00 00       	callq  40c0 <f2fs_find_data_page+0x70>
	page = f2fs_get_read_data_page(inode, index, 0, false);
    40c0:	31 c9                	xor    %ecx,%ecx
    40c2:	31 d2                	xor    %edx,%edx
    40c4:	4c 89 ee             	mov    %r13,%rsi
    40c7:	4c 89 e7             	mov    %r12,%rdi
    40ca:	e8 00 00 00 00       	callq  40cf <f2fs_find_data_page+0x7f>
	if (IS_ERR(page))
    40cf:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    40d5:	77 bd                	ja     4094 <f2fs_find_data_page+0x44>
    40d7:	48 8b 48 08          	mov    0x8(%rax),%rcx
    40db:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    40df:	83 e1 01             	and    $0x1,%ecx
    40e2:	48 0f 44 d0          	cmove  %rax,%rdx
    40e6:	48 8b 12             	mov    (%rdx),%rdx
	if (ret)
    40e9:	83 e2 08             	and    $0x8,%edx
    40ec:	75 a6                	jne    4094 <f2fs_find_data_page+0x44>
    40ee:	48 8b 48 08          	mov    0x8(%rax),%rcx
	page = f2fs_get_read_data_page(inode, index, 0, false);
    40f2:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    40f6:	83 e1 01             	and    $0x1,%ecx
    40f9:	48 0f 44 d0          	cmove  %rax,%rdx
    40fd:	48 8b 12             	mov    (%rdx),%rdx
 * ie with increased "page->count" so that the page won't
 * go away during the wait..
 */
static inline void wait_on_page_locked(struct page *page)
{
	if (PageLocked(page))
    4100:	83 e2 01             	and    $0x1,%edx
    4103:	74 1e                	je     4123 <f2fs_find_data_page+0xd3>
    4105:	48 8b 50 08          	mov    0x8(%rax),%rdx
		return (struct page *) (head - 1);
    4109:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    410d:	48 8d 7a ff          	lea    -0x1(%rdx),%rdi
    4111:	83 e2 01             	and    $0x1,%edx
    4114:	48 0f 44 f8          	cmove  %rax,%rdi
		wait_on_page_bit(compound_head(page), PG_locked);
    4118:	31 f6                	xor    %esi,%esi
    411a:	e8 00 00 00 00       	callq  411f <f2fs_find_data_page+0xcf>
    411f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    4123:	48 8b 48 08          	mov    0x8(%rax),%rcx
    4127:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    412b:	83 e1 01             	and    $0x1,%ecx
    412e:	48 0f 44 d0          	cmove  %rax,%rdx
    4132:	48 8b 12             	mov    (%rdx),%rdx
	if (ret)
    4135:	83 e2 08             	and    $0x8,%edx
    4138:	0f 85 56 ff ff ff    	jne    4094 <f2fs_find_data_page+0x44>
	if (!page)
    413e:	48 85 c0             	test   %rax,%rax
    4141:	74 1a                	je     415d <f2fs_find_data_page+0x10d>
    4143:	48 8b 50 08          	mov    0x8(%rax),%rdx
		return (struct page *) (head - 1);
    4147:	48 8d 4a ff          	lea    -0x1(%rdx),%rcx
    414b:	83 e2 01             	and    $0x1,%edx
    414e:	48 0f 45 c1          	cmovne %rcx,%rax
    4152:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4157:	f0 ff 48 34          	lock decl 0x34(%rax)
	if (put_page_testzero(page))
    415b:	74 77                	je     41d4 <f2fs_find_data_page+0x184>
		return ERR_PTR(-EIO);
    415d:	48 c7 c0 fb ff ff ff 	mov    $0xfffffffffffffffb,%rax
    4164:	e9 2b ff ff ff       	jmpq   4094 <f2fs_find_data_page+0x44>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    4169:	48 8b 10             	mov    (%rax),%rdx
    416c:	48 c1 ea 33          	shr    $0x33,%rdx
    4170:	83 e2 07             	and    $0x7,%edx
	if (!is_zone_device_page(page))
    4173:	83 fa 04             	cmp    $0x4,%edx
    4176:	0f 85 36 ff ff ff    	jne    40b2 <f2fs_find_data_page+0x62>
	switch (page->pgmap->type) {
    417c:	48 8b 50 08          	mov    0x8(%rax),%rdx
    4180:	8b 92 98 00 00 00    	mov    0x98(%rdx),%edx
    4186:	83 ea 01             	sub    $0x1,%edx
    4189:	83 fa 02             	cmp    $0x2,%edx
    418c:	0f 87 20 ff ff ff    	ja     40b2 <f2fs_find_data_page+0x62>
		__put_devmap_managed_page(page);
    4192:	48 89 c7             	mov    %rax,%rdi
    4195:	e8 00 00 00 00       	callq  419a <f2fs_find_data_page+0x14a>
		return;
    419a:	e9 21 ff ff ff       	jmpq   40c0 <f2fs_find_data_page+0x70>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    419f:	48 8b 10             	mov    (%rax),%rdx
    41a2:	48 c1 ea 33          	shr    $0x33,%rdx
    41a6:	83 e2 07             	and    $0x7,%edx
	if (!is_zone_device_page(page))
    41a9:	83 fa 04             	cmp    $0x4,%edx
    41ac:	75 a9                	jne    4157 <f2fs_find_data_page+0x107>
	switch (page->pgmap->type) {
    41ae:	48 8b 50 08          	mov    0x8(%rax),%rdx
    41b2:	8b 92 98 00 00 00    	mov    0x98(%rdx),%edx
    41b8:	83 ea 01             	sub    $0x1,%edx
    41bb:	83 fa 02             	cmp    $0x2,%edx
    41be:	77 97                	ja     4157 <f2fs_find_data_page+0x107>
		__put_devmap_managed_page(page);
    41c0:	48 89 c7             	mov    %rax,%rdi
    41c3:	e8 00 00 00 00       	callq  41c8 <f2fs_find_data_page+0x178>
    41c8:	48 c7 c0 fb ff ff ff 	mov    $0xfffffffffffffffb,%rax
		return;
    41cf:	e9 c0 fe ff ff       	jmpq   4094 <f2fs_find_data_page+0x44>
		__put_page(page);
    41d4:	48 89 c7             	mov    %rax,%rdi
    41d7:	e8 00 00 00 00       	callq  41dc <f2fs_find_data_page+0x18c>
    41dc:	e9 7c ff ff ff       	jmpq   415d <f2fs_find_data_page+0x10d>
    41e1:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    41e8:	00 00 00 00 
    41ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000041f0 <f2fs_get_lock_data_page>:
									 bool for_write) {
    41f0:	f3 0f 1e fa          	endbr64 
    41f4:	e8 00 00 00 00       	callq  41f9 <f2fs_get_lock_data_page+0x9>
    41f9:	55                   	push   %rbp
    41fa:	48 89 e5             	mov    %rsp,%rbp
    41fd:	41 57                	push   %r15
    41ff:	41 56                	push   %r14
    4201:	49 89 f6             	mov    %rsi,%r14
    4204:	41 55                	push   %r13
    4206:	44 0f b6 ea          	movzbl %dl,%r13d
    420a:	41 54                	push   %r12
    420c:	53                   	push   %rbx
	struct address_space *mapping = inode->i_mapping;
    420d:	4c 8b 7f 30          	mov    0x30(%rdi),%r15
									 bool for_write) {
    4211:	48 89 fb             	mov    %rdi,%rbx
	page = f2fs_get_read_data_page(inode, index, 0, for_write);
    4214:	44 89 e9             	mov    %r13d,%ecx
    4217:	31 d2                	xor    %edx,%edx
    4219:	4c 89 f6             	mov    %r14,%rsi
    421c:	48 89 df             	mov    %rbx,%rdi
    421f:	e8 00 00 00 00       	callq  4224 <f2fs_get_lock_data_page+0x34>
    4224:	49 89 c4             	mov    %rax,%r12
	if (IS_ERR(page))
    4227:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    422d:	0f 87 99 00 00 00    	ja     42cc <f2fs_get_lock_data_page+0xdc>
	might_sleep();
    4233:	e8 00 00 00 00       	callq  4238 <f2fs_get_lock_data_page+0x48>
    4238:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    423d:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4241:	83 e2 01             	and    $0x1,%edx
    4244:	49 0f 44 c4          	cmove  %r12,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    4248:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    424e:	0f 82 94 00 00 00    	jb     42e8 <f2fs_get_lock_data_page+0xf8>
	if (unlikely(page->mapping != mapping)) {
    4254:	49 8b 44 24 18       	mov    0x18(%r12),%rax
    4259:	4c 39 f8             	cmp    %r15,%rax
    425c:	0f 85 93 00 00 00    	jne    42f5 <f2fs_get_lock_data_page+0x105>
    4262:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    4267:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    426b:	83 e2 01             	and    $0x1,%edx
    426e:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    4272:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    4275:	a8 08                	test   $0x8,%al
    4277:	75 61                	jne    42da <f2fs_get_lock_data_page+0xea>
    4279:	4d 85 e4             	test   %r12,%r12
    427c:	74 47                	je     42c5 <f2fs_get_lock_data_page+0xd5>
    427e:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
    4283:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4287:	83 e2 01             	and    $0x1,%edx
    428a:	49 0f 44 c4          	cmove  %r12,%rax
    428e:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    4291:	a8 01                	test   $0x1,%al
    4293:	0f 84 3f 01 00 00    	je     43d8 <f2fs_get_lock_data_page+0x1e8>
		unlock_page(page);
    4299:	4c 89 e7             	mov    %r12,%rdi
    429c:	e8 00 00 00 00       	callq  42a1 <f2fs_get_lock_data_page+0xb1>
    42a1:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    42a6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    42aa:	a8 01                	test   $0x1,%al
    42ac:	4c 0f 45 e2          	cmovne %rdx,%r12
    42b0:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    42b5:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    42bb:	75 08                	jne    42c5 <f2fs_get_lock_data_page+0xd5>
		__put_page(page);
    42bd:	4c 89 e7             	mov    %r12,%rdi
    42c0:	e8 00 00 00 00       	callq  42c5 <f2fs_get_lock_data_page+0xd5>
		return ERR_PTR(-EIO);
    42c5:	49 c7 c4 fb ff ff ff 	mov    $0xfffffffffffffffb,%r12
}
    42cc:	5b                   	pop    %rbx
    42cd:	4c 89 e0             	mov    %r12,%rax
    42d0:	41 5c                	pop    %r12
    42d2:	41 5d                	pop    %r13
    42d4:	41 5e                	pop    %r14
    42d6:	41 5f                	pop    %r15
    42d8:	5d                   	pop    %rbp
    42d9:	c3                   	retq   
    42da:	5b                   	pop    %rbx
    42db:	4c 89 e0             	mov    %r12,%rax
    42de:	41 5c                	pop    %r12
    42e0:	41 5d                	pop    %r13
    42e2:	41 5e                	pop    %r14
    42e4:	41 5f                	pop    %r15
    42e6:	5d                   	pop    %rbp
    42e7:	c3                   	retq   
		__lock_page(page);
    42e8:	4c 89 e7             	mov    %r12,%rdi
    42eb:	e8 00 00 00 00       	callq  42f0 <f2fs_get_lock_data_page+0x100>
    42f0:	e9 5f ff ff ff       	jmpq   4254 <f2fs_get_lock_data_page+0x64>
	if (!page)
    42f5:	4d 85 e4             	test   %r12,%r12
    42f8:	0f 84 16 ff ff ff    	je     4214 <f2fs_get_lock_data_page+0x24>
    42fe:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
    4303:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    4307:	83 e1 01             	and    $0x1,%ecx
    430a:	49 0f 44 d4          	cmove  %r12,%rdx
    430e:	48 8b 12             	mov    (%rdx),%rdx
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    4311:	83 e2 01             	and    $0x1,%edx
    4314:	0f 84 a4 00 00 00    	je     43be <f2fs_get_lock_data_page+0x1ce>
		unlock_page(page);
    431a:	4c 89 e7             	mov    %r12,%rdi
    431d:	e8 00 00 00 00       	callq  4322 <f2fs_get_lock_data_page+0x132>
    4322:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4327:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    432b:	a8 01                	test   $0x1,%al
    432d:	4c 0f 45 e2          	cmovne %rdx,%r12
    4331:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4336:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    433c:	0f 85 d2 fe ff ff    	jne    4214 <f2fs_get_lock_data_page+0x24>
		__put_page(page);
    4342:	4c 89 e7             	mov    %r12,%rdi
    4345:	e8 00 00 00 00       	callq  434a <f2fs_get_lock_data_page+0x15a>
    434a:	e9 c5 fe ff ff       	jmpq   4214 <f2fs_get_lock_data_page+0x24>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    434f:	49 8b 04 24          	mov    (%r12),%rax
    4353:	48 c1 e8 33          	shr    $0x33,%rax
    4357:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    435a:	83 f8 04             	cmp    $0x4,%eax
    435d:	75 d7                	jne    4336 <f2fs_get_lock_data_page+0x146>
	switch (page->pgmap->type) {
    435f:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4364:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    436a:	83 e8 01             	sub    $0x1,%eax
    436d:	83 f8 02             	cmp    $0x2,%eax
    4370:	77 c4                	ja     4336 <f2fs_get_lock_data_page+0x146>
		__put_devmap_managed_page(page);
    4372:	4c 89 e7             	mov    %r12,%rdi
    4375:	e8 00 00 00 00       	callq  437a <f2fs_get_lock_data_page+0x18a>
		return;
    437a:	e9 95 fe ff ff       	jmpq   4214 <f2fs_get_lock_data_page+0x24>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    437f:	49 8b 04 24          	mov    (%r12),%rax
    4383:	48 c1 e8 33          	shr    $0x33,%rax
    4387:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    438a:	83 f8 04             	cmp    $0x4,%eax
    438d:	0f 85 22 ff ff ff    	jne    42b5 <f2fs_get_lock_data_page+0xc5>
	switch (page->pgmap->type) {
    4393:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4398:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    439e:	83 e8 01             	sub    $0x1,%eax
    43a1:	83 f8 02             	cmp    $0x2,%eax
    43a4:	0f 87 0b ff ff ff    	ja     42b5 <f2fs_get_lock_data_page+0xc5>
		__put_devmap_managed_page(page);
    43aa:	4c 89 e7             	mov    %r12,%rdi
		return ERR_PTR(-EIO);
    43ad:	49 c7 c4 fb ff ff ff 	mov    $0xfffffffffffffffb,%r12
    43b4:	e8 00 00 00 00       	callq  43b9 <f2fs_get_lock_data_page+0x1c9>
		return;
    43b9:	e9 0e ff ff ff       	jmpq   42cc <f2fs_get_lock_data_page+0xdc>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    43be:	0f 0b                	ud2    
	return F2FS_SB(inode->i_sb);
    43c0:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    43c3:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    43c7:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    43ce:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    43d3:	e9 42 ff ff ff       	jmpq   431a <f2fs_get_lock_data_page+0x12a>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    43d8:	0f 0b                	ud2    
	return F2FS_SB(inode->i_sb);
    43da:	49 8b 07             	mov    (%r15),%rax
	return sb->s_fs_info;
    43dd:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    43e1:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    43e8:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    43ed:	e9 a7 fe ff ff       	jmpq   4299 <f2fs_get_lock_data_page+0xa9>
    43f2:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    43f9:	00 00 00 00 
    43fd:	0f 1f 00             	nopl   (%rax)

0000000000004400 <f2fs_get_new_data_page>:
									struct page *ipage, pgoff_t index, bool new_i_size) {
    4400:	f3 0f 1e fa          	endbr64 
    4404:	e8 00 00 00 00       	callq  4409 <f2fs_get_new_data_page+0x9>
    4409:	55                   	push   %rbp
    440a:	48 89 e5             	mov    %rsp,%rbp
    440d:	41 57                	push   %r15
    440f:	41 89 cf             	mov    %ecx,%r15d
    4412:	41 56                	push   %r14
    4414:	49 89 fe             	mov    %rdi,%r14
    4417:	41 55                	push   %r13
    4419:	49 89 f5             	mov    %rsi,%r13
    441c:	41 54                	push   %r12
    441e:	53                   	push   %rbx
    441f:	48 89 d3             	mov    %rdx,%rbx
	return grab_cache_page_write_begin(mapping, index, AOP_FLAG_NOFS);
    4422:	ba 02 00 00 00       	mov    $0x2,%edx
    4427:	48 89 de             	mov    %rbx,%rsi
    442a:	48 83 ec 38          	sub    $0x38,%rsp
    442e:	48 8b 7f 30          	mov    0x30(%rdi),%rdi
    4432:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4439:	00 00 
    443b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    443f:	31 c0                	xor    %eax,%eax
    4441:	e8 00 00 00 00       	callq  4446 <f2fs_get_new_data_page+0x46>
	if (!page) {
    4446:	48 85 c0             	test   %rax,%rax
    4449:	0f 84 5d 01 00 00    	je     45ac <f2fs_get_new_data_page+0x1ac>
	err = f2fs_reserve_block(&dn, index);
    444f:	48 89 de             	mov    %rbx,%rsi
    4452:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
	dn->inode = inode;
    4456:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
    445a:	49 89 c4             	mov    %rax,%r12
    445d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    4464:	00 
    4465:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    446c:	00 
	dn->inode_page = ipage;
    446d:	4c 89 6d b0          	mov    %r13,-0x50(%rbp)
	dn->node_page = npage;
    4471:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    4478:	00 
    4479:	e8 00 00 00 00       	callq  447e <f2fs_get_new_data_page+0x7e>
	if (err) {
    447e:	85 c0                	test   %eax,%eax
    4480:	75 60                	jne    44e2 <f2fs_get_new_data_page+0xe2>
	if (!ipage)
    4482:	4d 85 ed             	test   %r13,%r13
    4485:	0f 84 b7 02 00 00    	je     4742 <f2fs_get_new_data_page+0x342>
    448b:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    4490:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4494:	83 e2 01             	and    $0x1,%edx
    4497:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    449b:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    449e:	a8 08                	test   $0x8,%al
    44a0:	0f 84 8c 00 00 00    	je     4532 <f2fs_get_new_data_page+0x132>
	if (new_i_size && i_size_read(inode) <
    44a6:	45 84 ff             	test   %r15b,%r15b
    44a9:	74 12                	je     44bd <f2fs_get_new_data_page+0xbd>
					  ((loff_t) (index + 1) << PAGE_SHIFT))
    44ab:	48 83 c3 01          	add    $0x1,%rbx
    44af:	48 c1 e3 0c          	shl    $0xc,%rbx
	if (new_i_size && i_size_read(inode) <
    44b3:	49 3b 5e 50          	cmp    0x50(%r14),%rbx
    44b7:	0f 8f 39 02 00 00    	jg     46f6 <f2fs_get_new_data_page+0x2f6>
}
    44bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    44c1:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    44c8:	00 00 
    44ca:	0f 85 79 04 00 00    	jne    4949 <f2fs_get_new_data_page+0x549>
    44d0:	48 83 c4 38          	add    $0x38,%rsp
    44d4:	4c 89 e0             	mov    %r12,%rax
    44d7:	5b                   	pop    %rbx
    44d8:	41 5c                	pop    %r12
    44da:	41 5d                	pop    %r13
    44dc:	41 5e                	pop    %r14
    44de:	41 5f                	pop    %r15
    44e0:	5d                   	pop    %rbp
    44e1:	c3                   	retq   
    44e2:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
		return (struct page *) (head - 1);
    44e7:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    44eb:	83 e1 01             	and    $0x1,%ecx
    44ee:	49 0f 44 d4          	cmove  %r12,%rdx
    44f2:	48 8b 12             	mov    (%rdx),%rdx
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    44f5:	83 e2 01             	and    $0x1,%edx
    44f8:	0f 84 ce 03 00 00    	je     48cc <f2fs_get_new_data_page+0x4cc>
		unlock_page(page);
    44fe:	4c 89 e7             	mov    %r12,%rdi
    4501:	89 45 a0             	mov    %eax,-0x60(%rbp)
    4504:	e8 00 00 00 00       	callq  4509 <f2fs_get_new_data_page+0x109>
    4509:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    450e:	8b 45 a0             	mov    -0x60(%rbp),%eax
    4511:	48 8d 4a ff          	lea    -0x1(%rdx),%rcx
    4515:	83 e2 01             	and    $0x1,%edx
    4518:	4c 0f 45 e1          	cmovne %rcx,%r12
    451c:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4521:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    4527:	0f 84 df 02 00 00    	je     480c <f2fs_get_new_data_page+0x40c>
		return ERR_PTR(err);
    452d:	4c 63 e0             	movslq %eax,%r12
    4530:	eb 8b                	jmp    44bd <f2fs_get_new_data_page+0xbd>
	if (dn.data_blkaddr == NEW_ADDR) {
    4532:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%rbp)
    4536:	0f 84 39 01 00 00    	je     4675 <f2fs_get_new_data_page+0x275>
    453c:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    4541:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4545:	83 e2 01             	and    $0x1,%edx
    4548:	49 0f 44 c4          	cmove  %r12,%rax
    454c:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    454f:	a8 01                	test   $0x1,%al
    4551:	0f 84 b5 03 00 00    	je     490c <f2fs_get_new_data_page+0x50c>
		unlock_page(page);
    4557:	4c 89 e7             	mov    %r12,%rdi
    455a:	e8 00 00 00 00       	callq  455f <f2fs_get_new_data_page+0x15f>
    455f:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    4564:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    4568:	a8 01                	test   $0x1,%al
    456a:	4c 0f 45 e2          	cmovne %rdx,%r12
    456e:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4573:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
    4579:	0f 84 a0 02 00 00    	je     481f <f2fs_get_new_data_page+0x41f>
		f2fs_bug_on(F2FS_I_SB(inode), ipage);
    457f:	4d 85 ed             	test   %r13,%r13
    4582:	0f 85 6d 03 00 00    	jne    48f5 <f2fs_get_new_data_page+0x4f5>
		page = f2fs_get_lock_data_page(inode, index, true);
    4588:	ba 01 00 00 00       	mov    $0x1,%edx
    458d:	48 89 de             	mov    %rbx,%rsi
    4590:	4c 89 f7             	mov    %r14,%rdi
    4593:	e8 00 00 00 00       	callq  4598 <f2fs_get_new_data_page+0x198>
    4598:	49 89 c4             	mov    %rax,%r12
		if (IS_ERR(page))
    459b:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    45a1:	0f 86 ff fe ff ff    	jbe    44a6 <f2fs_get_new_data_page+0xa6>
    45a7:	e9 11 ff ff ff       	jmpq   44bd <f2fs_get_new_data_page+0xbd>
	if (!page)
    45ac:	4d 85 ed             	test   %r13,%r13
    45af:	74 7a                	je     462b <f2fs_get_new_data_page+0x22b>
    45b1:	49 8b 55 08          	mov    0x8(%r13),%rdx
    45b5:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    45b9:	83 e2 01             	and    $0x1,%edx
    45bc:	49 0f 44 c5          	cmove  %r13,%rax
    45c0:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    45c3:	a8 01                	test   $0x1,%al
    45c5:	0f 84 e3 02 00 00    	je     48ae <f2fs_get_new_data_page+0x4ae>
		unlock_page(page);
    45cb:	4c 89 ef             	mov    %r13,%rdi
    45ce:	e8 00 00 00 00       	callq  45d3 <f2fs_get_new_data_page+0x1d3>
    45d3:	49 8b 45 08          	mov    0x8(%r13),%rax
    45d7:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    45db:	a8 01                	test   $0x1,%al
    45dd:	4c 0f 45 ea          	cmovne %rdx,%r13
    45e1:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    45e6:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
    45eb:	75 3e                	jne    462b <f2fs_get_new_data_page+0x22b>
		__put_page(page);
    45ed:	4c 89 ef             	mov    %r13,%rdi
		return ERR_PTR(-ENOMEM);
    45f0:	49 c7 c4 f4 ff ff ff 	mov    $0xfffffffffffffff4,%r12
    45f7:	e8 00 00 00 00       	callq  45fc <f2fs_get_new_data_page+0x1fc>
    45fc:	e9 bc fe ff ff       	jmpq   44bd <f2fs_get_new_data_page+0xbd>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    4601:	49 8b 45 00          	mov    0x0(%r13),%rax
    4605:	48 c1 e8 33          	shr    $0x33,%rax
    4609:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    460c:	83 f8 04             	cmp    $0x4,%eax
    460f:	75 d5                	jne    45e6 <f2fs_get_new_data_page+0x1e6>
	switch (page->pgmap->type) {
    4611:	49 8b 45 08          	mov    0x8(%r13),%rax
    4615:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    461b:	83 e8 01             	sub    $0x1,%eax
    461e:	83 f8 02             	cmp    $0x2,%eax
    4621:	77 c3                	ja     45e6 <f2fs_get_new_data_page+0x1e6>
		__put_devmap_managed_page(page);
    4623:	4c 89 ef             	mov    %r13,%rdi
    4626:	e8 00 00 00 00       	callq  462b <f2fs_get_new_data_page+0x22b>
    462b:	49 c7 c4 f4 ff ff ff 	mov    $0xfffffffffffffff4,%r12
		return;
    4632:	e9 86 fe ff ff       	jmpq   44bd <f2fs_get_new_data_page+0xbd>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    4637:	49 8b 14 24          	mov    (%r12),%rdx
    463b:	48 c1 ea 33          	shr    $0x33,%rdx
    463f:	83 e2 07             	and    $0x7,%edx
	if (!is_zone_device_page(page))
    4642:	83 fa 04             	cmp    $0x4,%edx
    4645:	0f 85 d6 fe ff ff    	jne    4521 <f2fs_get_new_data_page+0x121>
	switch (page->pgmap->type) {
    464b:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    4650:	8b 92 98 00 00 00    	mov    0x98(%rdx),%edx
    4656:	83 ea 01             	sub    $0x1,%edx
    4659:	83 fa 02             	cmp    $0x2,%edx
    465c:	0f 87 bf fe ff ff    	ja     4521 <f2fs_get_new_data_page+0x121>
		__put_devmap_managed_page(page);
    4662:	4c 89 e7             	mov    %r12,%rdi
    4665:	89 45 a0             	mov    %eax,-0x60(%rbp)
    4668:	e8 00 00 00 00       	callq  466d <f2fs_get_new_data_page+0x26d>
		return;
    466d:	8b 45 a0             	mov    -0x60(%rbp),%eax
    4670:	e9 b8 fe ff ff       	jmpq   452d <f2fs_get_new_data_page+0x12d>
    4675:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    467c:	00 00 
	current->pagefault_disabled++;
    467e:	83 82 38 12 00 00 01 	addl   $0x1,0x1238(%rdx)
	return page_to_virt(page);
    4685:	4c 89 e0             	mov    %r12,%rax
    4688:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 468f <f2fs_get_new_data_page+0x28f>
    468f:	48 c1 f8 06          	sar    $0x6,%rax
    4693:	48 c1 e0 0c          	shl    $0xc,%rax
    4697:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 469e <f2fs_get_new_data_page+0x29e>
    469e:	48 8d 78 08          	lea    0x8(%rax),%rdi
    46a2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    46a9:	48 c7 80 f8 0f 00 00 	movq   $0x0,0xff8(%rax)
    46b0:	00 00 00 00 
    46b4:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    46b8:	48 29 f8             	sub    %rdi,%rax
    46bb:	8d 88 00 10 00 00    	lea    0x1000(%rax),%ecx
    46c1:	31 c0                	xor    %eax,%eax
    46c3:	c1 e9 03             	shr    $0x3,%ecx
    46c6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	current->pagefault_disabled--;
    46c9:	83 aa 38 12 00 00 01 	subl   $0x1,0x1238(%rdx)
    46d0:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    46d5:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    46d9:	83 e2 01             	and    $0x1,%edx
    46dc:	49 0f 44 c4          	cmove  %r12,%rax
    46e0:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    46e3:	a8 08                	test   $0x8,%al
    46e5:	0f 85 bb fd ff ff    	jne    44a6 <f2fs_get_new_data_page+0xa6>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    46eb:	f0 41 80 0c 24 08    	lock orb $0x8,(%r12)
}
    46f1:	e9 b0 fd ff ff       	jmpq   44a6 <f2fs_get_new_data_page+0xa6>
	inode->i_size = i_size;
    46f6:	49 89 5e 50          	mov    %rbx,0x50(%r14)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    46fa:	4d 8b ae 78 02 00 00 	mov    0x278(%r14),%r13
	f2fs_mark_inode_dirty_sync(inode, true);
    4701:	be 01 00 00 00       	mov    $0x1,%esi
    4706:	4c 89 f7             	mov    %r14,%rdi
    4709:	4d 8b be 78 02 00 00 	mov    0x278(%r14),%r15
    4710:	e8 00 00 00 00       	callq  4715 <f2fs_get_new_data_page+0x315>
	if (clean || recover)
    4715:	41 83 e5 02          	and    $0x2,%r13d
    4719:	74 0a                	je     4725 <f2fs_get_new_data_page+0x325>
    471b:	41 83 e7 04          	and    $0x4,%r15d
    471f:	0f 84 98 fd ff ff    	je     44bd <f2fs_get_new_data_page+0xbd>
    4725:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    472c:	a8 04                	test   $0x4,%al
    472e:	0f 85 89 fd ff ff    	jne    44bd <f2fs_get_new_data_page+0xbd>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    4734:	f0 41 80 8e 78 02 00 	lock orb $0x4,0x278(%r14)
    473b:	00 04 
    473d:	e9 7b fd ff ff       	jmpq   44bd <f2fs_get_new_data_page+0xbd>
	if (dn->node_page)
    4742:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    4746:	48 85 ff             	test   %rdi,%rdi
    4749:	0f 84 10 01 00 00    	je     485f <f2fs_get_new_data_page+0x45f>
    474f:	48 8b 57 08          	mov    0x8(%rdi),%rdx
		return (struct page *) (head - 1);
    4753:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4757:	83 e2 01             	and    $0x1,%edx
    475a:	48 0f 44 c7          	cmove  %rdi,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    475e:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    4761:	a8 01                	test   $0x1,%al
    4763:	0f 84 c2 01 00 00    	je     492b <f2fs_get_new_data_page+0x52b>
		unlock_page(page);
    4769:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    476d:	e8 00 00 00 00       	callq  4772 <f2fs_get_new_data_page+0x372>
    4772:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
    4776:	48 8b 47 08          	mov    0x8(%rdi),%rax
    477a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    477e:	a8 01                	test   $0x1,%al
    4780:	48 0f 45 fa          	cmovne %rdx,%rdi
    4784:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4789:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
    478d:	0f 84 11 01 00 00    	je     48a4 <f2fs_get_new_data_page+0x4a4>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    4793:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    4797:	48 85 ff             	test   %rdi,%rdi
    479a:	74 23                	je     47bf <f2fs_get_new_data_page+0x3bf>
    479c:	48 3b 7d b8          	cmp    -0x48(%rbp),%rdi
    47a0:	74 1d                	je     47bf <f2fs_get_new_data_page+0x3bf>
    47a2:	48 8b 47 08          	mov    0x8(%rdi),%rax
    47a6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    47aa:	a8 01                	test   $0x1,%al
    47ac:	48 0f 45 fa          	cmovne %rdx,%rdi
    47b0:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    47b5:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    47b9:	0f 84 2c 01 00 00    	je     48eb <f2fs_get_new_data_page+0x4eb>
	dn->node_page = NULL;
    47bf:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    47c6:	00 
	dn->inode_page = NULL;
    47c7:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    47ce:	00 
}
    47cf:	e9 b7 fc ff ff       	jmpq   448b <f2fs_get_new_data_page+0x8b>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    47d4:	49 8b 04 24          	mov    (%r12),%rax
    47d8:	48 c1 e8 33          	shr    $0x33,%rax
    47dc:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    47df:	83 f8 04             	cmp    $0x4,%eax
    47e2:	0f 85 8b fd ff ff    	jne    4573 <f2fs_get_new_data_page+0x173>
	switch (page->pgmap->type) {
    47e8:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    47ed:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    47f3:	83 e8 01             	sub    $0x1,%eax
    47f6:	83 f8 02             	cmp    $0x2,%eax
    47f9:	0f 87 74 fd ff ff    	ja     4573 <f2fs_get_new_data_page+0x173>
		__put_devmap_managed_page(page);
    47ff:	4c 89 e7             	mov    %r12,%rdi
    4802:	e8 00 00 00 00       	callq  4807 <f2fs_get_new_data_page+0x407>
		return;
    4807:	e9 73 fd ff ff       	jmpq   457f <f2fs_get_new_data_page+0x17f>
		__put_page(page);
    480c:	4c 89 e7             	mov    %r12,%rdi
    480f:	89 45 a0             	mov    %eax,-0x60(%rbp)
    4812:	e8 00 00 00 00       	callq  4817 <f2fs_get_new_data_page+0x417>
    4817:	8b 45 a0             	mov    -0x60(%rbp),%eax
    481a:	e9 0e fd ff ff       	jmpq   452d <f2fs_get_new_data_page+0x12d>
    481f:	4c 89 e7             	mov    %r12,%rdi
    4822:	e8 00 00 00 00       	callq  4827 <f2fs_get_new_data_page+0x427>
    4827:	e9 53 fd ff ff       	jmpq   457f <f2fs_get_new_data_page+0x17f>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    482c:	48 8b 07             	mov    (%rdi),%rax
    482f:	48 c1 e8 33          	shr    $0x33,%rax
    4833:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    4836:	83 f8 04             	cmp    $0x4,%eax
    4839:	0f 85 4a ff ff ff    	jne    4789 <f2fs_get_new_data_page+0x389>
	switch (page->pgmap->type) {
    483f:	48 8b 47 08          	mov    0x8(%rdi),%rax
    4843:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    4849:	83 e8 01             	sub    $0x1,%eax
    484c:	83 f8 02             	cmp    $0x2,%eax
    484f:	0f 87 34 ff ff ff    	ja     4789 <f2fs_get_new_data_page+0x389>
		__put_devmap_managed_page(page);
    4855:	e8 00 00 00 00       	callq  485a <f2fs_get_new_data_page+0x45a>
		return;
    485a:	e9 34 ff ff ff       	jmpq   4793 <f2fs_get_new_data_page+0x393>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    485f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    4863:	48 85 ff             	test   %rdi,%rdi
    4866:	0f 85 36 ff ff ff    	jne    47a2 <f2fs_get_new_data_page+0x3a2>
    486c:	e9 4e ff ff ff       	jmpq   47bf <f2fs_get_new_data_page+0x3bf>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    4871:	48 8b 07             	mov    (%rdi),%rax
    4874:	48 c1 e8 33          	shr    $0x33,%rax
    4878:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    487b:	83 f8 04             	cmp    $0x4,%eax
    487e:	0f 85 31 ff ff ff    	jne    47b5 <f2fs_get_new_data_page+0x3b5>
	switch (page->pgmap->type) {
    4884:	48 8b 47 08          	mov    0x8(%rdi),%rax
    4888:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    488e:	83 e8 01             	sub    $0x1,%eax
    4891:	83 f8 02             	cmp    $0x2,%eax
    4894:	0f 87 1b ff ff ff    	ja     47b5 <f2fs_get_new_data_page+0x3b5>
		__put_devmap_managed_page(page);
    489a:	e8 00 00 00 00       	callq  489f <f2fs_get_new_data_page+0x49f>
		return;
    489f:	e9 1b ff ff ff       	jmpq   47bf <f2fs_get_new_data_page+0x3bf>
		__put_page(page);
    48a4:	e8 00 00 00 00       	callq  48a9 <f2fs_get_new_data_page+0x4a9>
    48a9:	e9 e5 fe ff ff       	jmpq   4793 <f2fs_get_new_data_page+0x393>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    48ae:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    48b0:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
    48b4:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    48b7:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    48bb:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    48c2:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    48c7:	e9 ff fc ff ff       	jmpq   45cb <f2fs_get_new_data_page+0x1cb>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    48cc:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    48ce:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
	return F2FS_SB(inode->i_sb);
    48d3:	48 8b 12             	mov    (%rdx),%rdx
	return sb->s_fs_info;
    48d6:	48 8b 52 28          	mov    0x28(%rdx),%rdx
	set_bit(type, &sbi->s_flag);
    48da:	48 8b 92 08 04 00 00 	mov    0x408(%rdx),%rdx
    48e1:	f0 80 4a 48 04       	lock orb $0x4,0x48(%rdx)
}
    48e6:	e9 13 fc ff ff       	jmpq   44fe <f2fs_get_new_data_page+0xfe>
    48eb:	e8 00 00 00 00       	callq  48f0 <f2fs_get_new_data_page+0x4f0>
    48f0:	e9 ca fe ff ff       	jmpq   47bf <f2fs_get_new_data_page+0x3bf>
		f2fs_bug_on(F2FS_I_SB(inode), ipage);
    48f5:	0f 0b                	ud2    
	return sb->s_fs_info;
    48f7:	49 8b 46 28          	mov    0x28(%r14),%rax
	set_bit(type, &sbi->s_flag);
    48fb:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    4902:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    4907:	e9 7c fc ff ff       	jmpq   4588 <f2fs_get_new_data_page+0x188>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    490c:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    490e:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    4913:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    4916:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    491a:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    4921:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    4926:	e9 2c fc ff ff       	jmpq   4557 <f2fs_get_new_data_page+0x157>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    492b:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    492d:	48 8b 47 18          	mov    0x18(%rdi),%rax
	return F2FS_SB(inode->i_sb);
    4931:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    4934:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    4938:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    493f:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    4944:	e9 20 fe ff ff       	jmpq   4769 <f2fs_get_new_data_page+0x369>
}
    4949:	e8 00 00 00 00       	callq  494e <f2fs_get_new_data_page+0x54e>
    494e:	66 90                	xchg   %ax,%ax

0000000000004950 <f2fs_map_blocks>:
					int create, int flag) {
    4950:	f3 0f 1e fa          	endbr64 
    4954:	e8 00 00 00 00       	callq  4959 <f2fs_map_blocks+0x9>
    4959:	55                   	push   %rbp
    495a:	48 89 e5             	mov    %rsp,%rbp
    495d:	41 57                	push   %r15
    495f:	41 56                	push   %r14
    4961:	41 55                	push   %r13
    4963:	41 54                	push   %r12
    4965:	53                   	push   %rbx
    4966:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
	unsigned int maxblocks = map->m_len;
    496d:	8b 5e 08             	mov    0x8(%rsi),%ebx
					int create, int flag) {
    4970:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4977:	00 00 
    4979:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    497d:	31 c0                	xor    %eax,%eax
	return sb->s_fs_info;
    497f:	48 8b 47 28          	mov    0x28(%rdi),%rax
	struct extent_info ei = {0, 0, 0};
    4983:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%rbp)
    498a:	48 c7 45 84 00 00 00 	movq   $0x0,-0x7c(%rbp)
    4991:	00 
    4992:	4c 8b b8 08 04 00 00 	mov    0x408(%rax),%r15
	if (!maxblocks)
    4999:	85 db                	test   %ebx,%ebx
    499b:	0f 85 00 00 00 00    	jne    49a1 <f2fs_map_blocks+0x51>
		return 0;
    49a1:	45 31 ed             	xor    %r13d,%r13d
}
    49a4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    49a8:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    49af:	00 00 
    49b1:	75 12                	jne    49c5 <f2fs_map_blocks+0x75>
    49b3:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    49b7:	44 89 e8             	mov    %r13d,%eax
    49ba:	5b                   	pop    %rbx
    49bb:	41 5c                	pop    %r12
    49bd:	41 5d                	pop    %r13
    49bf:	41 5e                	pop    %r14
    49c1:	41 5f                	pop    %r15
    49c3:	5d                   	pop    %rbp
    49c4:	c3                   	retq   
    49c5:	e8 00 00 00 00       	callq  49ca <f2fs_map_blocks+0x7a>
    49ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000049d0 <f2fs_preallocate_blocks>:
int f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *from) {
    49d0:	f3 0f 1e fa          	endbr64 
    49d4:	e8 00 00 00 00       	callq  49d9 <f2fs_preallocate_blocks+0x9>
    49d9:	55                   	push   %rbp
    49da:	48 89 e5             	mov    %rsp,%rbp
    49dd:	41 56                	push   %r14
    49df:	49 89 f6             	mov    %rsi,%r14
    49e2:	41 55                	push   %r13
    49e4:	41 54                	push   %r12
    49e6:	53                   	push   %rbx
    49e7:	48 89 fb             	mov    %rdi,%rbx
    49ea:	48 83 ec 30          	sub    $0x30,%rsp
	if (direct_io) {
    49ee:	44 8b 6f 20          	mov    0x20(%rdi),%r13d
int f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *from) {
    49f2:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    49f9:	00 00 
    49fb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    49ff:	31 c0                	xor    %eax,%eax
	return f->f_inode;
    4a01:	48 8b 07             	mov    (%rdi),%rax
    4a04:	4c 8b 60 20          	mov    0x20(%rax),%r12
	if (direct_io) {
    4a08:	41 83 e5 04          	and    $0x4,%r13d
    4a0c:	0f 85 af 00 00 00    	jne    4ac1 <f2fs_preallocate_blocks+0xf1>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    4a12:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    4a19:	00 
	if (is_inode_flag_set(inode, FI_NO_PREALLOC))
    4a1a:	a9 00 00 00 01       	test   $0x1000000,%eax
    4a1f:	0f 85 bb 00 00 00    	jne    4ae0 <f2fs_preallocate_blocks+0x110>
	map.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos);
    4a25:	48 8b 53 08          	mov    0x8(%rbx),%rdx
	map.m_next_pgofs = NULL;
    4a29:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    4a30:	00 
	map.m_next_extent = NULL;
    4a31:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    4a38:	00 
	map.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos);
    4a39:	48 8d 82 ff 0f 00 00 	lea    0xfff(%rdx),%rax
	map.m_len = F2FS_BYTES_TO_BLK(iocb->ki_pos + iov_iter_count(from));
    4a40:	49 03 56 10          	add    0x10(%r14),%rdx
	map.m_seg_type = NO_CHECK_TYPE;
    4a44:	c7 45 d0 06 00 00 00 	movl   $0x6,-0x30(%rbp)
	map.m_len = F2FS_BYTES_TO_BLK(iocb->ki_pos + iov_iter_count(from));
    4a4b:	48 89 d6             	mov    %rdx,%rsi
	map.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos);
    4a4e:	48 c1 f8 0c          	sar    $0xc,%rax
	map.m_len = F2FS_BYTES_TO_BLK(iocb->ki_pos + iov_iter_count(from));
    4a52:	48 c1 ee 0c          	shr    $0xc,%rsi
	map.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos);
    4a56:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		map.m_len -= map.m_lblk;
    4a59:	89 f1                	mov    %esi,%ecx
    4a5b:	29 c1                	sub    %eax,%ecx
    4a5d:	39 f0                	cmp    %esi,%eax
    4a5f:	b8 00 00 00 00       	mov    $0x0,%eax
    4a64:	0f 42 c1             	cmovb  %ecx,%eax
    4a67:	89 45 b8             	mov    %eax,-0x48(%rbp)
	if (direct_io) {
    4a6a:	45 85 ed             	test   %r13d,%r13d
    4a6d:	75 7a                	jne    4ae9 <f2fs_preallocate_blocks+0x119>
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
    4a6f:	49 63 8c 24 08 04 00 	movslq 0x408(%r12),%rcx
    4a76:	00 
	if (iocb->ki_pos + iov_iter_count(from) > MAX_INLINE_DATA(inode)) {
    4a77:	b8 9a 03 00 00       	mov    $0x39a,%eax
    4a7c:	41 2b 84 24 10 04 00 	sub    0x410(%r12),%eax
    4a83:	00 
    4a84:	48 c1 e9 02          	shr    $0x2,%rcx
    4a88:	29 c8                	sub    %ecx,%eax
    4a8a:	48 98                	cltq   
    4a8c:	48 c1 e0 02          	shl    $0x2,%rax
    4a90:	48 39 c2             	cmp    %rax,%rdx
    4a93:	0f 86 00 00 00 00    	jbe    4a99 <f2fs_preallocate_blocks+0xc9>
		err = f2fs_convert_inline_inode(inode);
    4a99:	4c 89 e7             	mov    %r12,%rdi
    4a9c:	e8 00 00 00 00       	callq  4aa1 <f2fs_preallocate_blocks+0xd1>
		if (err)
    4aa1:	85 c0                	test   %eax,%eax
    4aa3:	74 64                	je     4b09 <f2fs_preallocate_blocks+0x139>
}
    4aa5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    4aa9:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
    4ab0:	00 00 
    4ab2:	75 30                	jne    4ae4 <f2fs_preallocate_blocks+0x114>
    4ab4:	48 83 c4 30          	add    $0x30,%rsp
    4ab8:	5b                   	pop    %rbx
    4ab9:	41 5c                	pop    %r12
    4abb:	41 5d                	pop    %r13
    4abd:	41 5e                	pop    %r14
    4abf:	5d                   	pop    %rbp
    4ac0:	c3                   	retq   
		err = f2fs_convert_inline_inode(inode);
    4ac1:	4c 89 e7             	mov    %r12,%rdi
    4ac4:	e8 00 00 00 00       	callq  4ac9 <f2fs_preallocate_blocks+0xf9>
		if (err)
    4ac9:	85 c0                	test   %eax,%eax
    4acb:	75 d8                	jne    4aa5 <f2fs_preallocate_blocks+0xd5>
    4acd:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    4ad4:	00 
	if (is_inode_flag_set(inode, FI_NO_PREALLOC))
    4ad5:	a9 00 00 00 01       	test   $0x1000000,%eax
    4ada:	0f 84 45 ff ff ff    	je     4a25 <f2fs_preallocate_blocks+0x55>
		err = 0;
    4ae0:	31 c0                	xor    %eax,%eax
    4ae2:	eb c1                	jmp    4aa5 <f2fs_preallocate_blocks+0xd5>
}
    4ae4:	e8 00 00 00 00       	callq  4ae9 <f2fs_preallocate_blocks+0x119>
		map.m_seg_type = f2fs_rw_hint_to_seg_type(iocb->ki_hint);
    4ae9:	0f b7 7b 24          	movzwl 0x24(%rbx),%edi
    4aed:	e8 00 00 00 00       	callq  4af2 <f2fs_preallocate_blocks+0x122>
    4af2:	89 45 d0             	mov    %eax,-0x30(%rbp)
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
    4af5:	41 f6 84 24 60 02 00 	testb  $0x4,0x260(%r12)
    4afc:	00 04 
    4afe:	0f 84 00 00 00 00    	je     4b04 <f2fs_preallocate_blocks+0x134>
    4b04:	e9 00 00 00 00       	jmpq   4b09 <f2fs_preallocate_blocks+0x139>
    4b09:	e9 00 00 00 00       	jmpq   4b0e <f2fs_preallocate_blocks+0x13e>
    4b0e:	66 90                	xchg   %ax,%ax

0000000000004b10 <__get_data_block>:
							pgoff_t *next_pgofs, int seg_type) {
    4b10:	e8 00 00 00 00       	callq  4b15 <__get_data_block+0x5>
    4b15:	55                   	push   %rbp
    4b16:	48 89 e5             	mov    %rsp,%rbp
    4b19:	41 55                	push   %r13
    4b1b:	41 54                	push   %r12
    4b1d:	49 89 d4             	mov    %rdx,%r12
    4b20:	89 ca                	mov    %ecx,%edx
    4b22:	53                   	push   %rbx
    4b23:	48 89 fb             	mov    %rdi,%rbx
    4b26:	48 83 ec 30          	sub    $0x30,%rsp
	map.m_len = bh->b_size >> inode->i_blkbits;// 映射区域块个数
    4b2a:	8b 8f 90 00 00 00    	mov    0x90(%rdi),%ecx
							pgoff_t *next_pgofs, int seg_type) {
    4b30:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    4b37:	00 00 
    4b39:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    4b3d:	31 c0                	xor    %eax,%eax
	map.m_len = bh->b_size >> inode->i_blkbits;// 映射区域块个数
    4b3f:	49 8b 44 24 20       	mov    0x20(%r12),%rax
	map.m_lblk = iblock;// 文件逻辑块偏移量
    4b44:	89 75 bc             	mov    %esi,-0x44(%rbp)
	err = f2fs_map_blocks(inode, &map, create, flag);
    4b47:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
	map.m_next_pgofs = next_pgofs;
    4b4b:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
	map.m_len = bh->b_size >> inode->i_blkbits;// 映射区域块个数
    4b4f:	48 d3 e8             	shr    %cl,%rax
	err = f2fs_map_blocks(inode, &map, create, flag);
    4b52:	44 89 c1             	mov    %r8d,%ecx
	map.m_next_extent = NULL;
    4b55:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    4b5c:	00 
	map.m_len = bh->b_size >> inode->i_blkbits;// 映射区域块个数
    4b5d:	89 45 c0             	mov    %eax,-0x40(%rbp)
	map.m_seg_type = seg_type;
    4b60:	8b 45 10             	mov    0x10(%rbp),%eax
    4b63:	89 45 d8             	mov    %eax,-0x28(%rbp)
	err = f2fs_map_blocks(inode, &map, create, flag);
    4b66:	e8 00 00 00 00       	callq  4b6b <__get_data_block+0x5b>
    4b6b:	41 89 c5             	mov    %eax,%r13d
	if (!err) {
    4b6e:	85 c0                	test   %eax,%eax
    4b70:	75 78                	jne    4bea <__get_data_block+0xda>
    4b72:	49 8b 0c 24          	mov    (%r12),%rcx
		map_bh(bh, inode->i_sb, map.m_pblk);// 为buffer_head结构赋予物理磁盘块地址
    4b76:	8b 55 b8             	mov    -0x48(%rbp),%edx
    4b79:	48 8b 43 28          	mov    0x28(%rbx),%rax
BUFFER_FNS(Dirty, dirty)
TAS_BUFFER_FNS(Dirty, dirty)
BUFFER_FNS(Lock, locked)
BUFFER_FNS(Req, req)
TAS_BUFFER_FNS(Req, req)
BUFFER_FNS(Mapped, mapped)
    4b7d:	83 e1 20             	and    $0x20,%ecx
    4b80:	0f 84 81 00 00 00    	je     4c07 <__get_data_block+0xf7>

static inline void
map_bh(struct buffer_head *bh, struct super_block *sb, sector_t block)
{
	set_buffer_mapped(bh);
	bh->b_bdev = sb->s_bdev;
    4b86:	48 8b 88 d0 00 00 00 	mov    0xd0(%rax),%rcx
	bh->b_blocknr = block;
    4b8d:	49 89 54 24 18       	mov    %rdx,0x18(%r12)
		nvm_redirect_dio(F2FS_I_SB(inode), bh, map.m_len, test_bit(IOP_WRITE, (volatile unsigned long *) &inode->i_opflags));
    4b92:	4c 89 e6             	mov    %r12,%rsi
		bh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;
    4b95:	8b 55 c4             	mov    -0x3c(%rbp),%edx
	bh->b_bdev = sb->s_bdev;
    4b98:	49 89 4c 24 30       	mov    %rcx,0x30(%r12)
	bh->b_size = sb->s_blocksize;
    4b9d:	48 8b 40 18          	mov    0x18(%rax),%rax
    4ba1:	49 89 44 24 20       	mov    %rax,0x20(%r12)
    4ba6:	49 8b 04 24          	mov    (%r12),%rax
    4baa:	48 25 9f ef ff ff    	and    $0xffffffffffffef9f,%rax
    4bb0:	48 09 d0             	or     %rdx,%rax
    4bb3:	49 89 04 24          	mov    %rax,(%r12)
		bh->b_size = (u64) map.m_len << inode->i_blkbits;
    4bb7:	8b 45 c0             	mov    -0x40(%rbp),%eax
    4bba:	8b 8b 90 00 00 00    	mov    0x90(%rbx),%ecx
    4bc0:	48 89 c2             	mov    %rax,%rdx
    4bc3:	48 d3 e0             	shl    %cl,%rax
    4bc6:	49 89 44 24 20       	mov    %rax,0x20(%r12)
    4bcb:	48 8b 4b 02          	mov    0x2(%rbx),%rcx
	return sb->s_fs_info;
    4bcf:	48 8b 43 28          	mov    0x28(%rbx),%rax
    4bd3:	c0 e9 07             	shr    $0x7,%cl
		nvm_redirect_dio(F2FS_I_SB(inode), bh, map.m_len, test_bit(IOP_WRITE, (volatile unsigned long *) &inode->i_opflags));
    4bd6:	48 8b b8 08 04 00 00 	mov    0x408(%rax),%rdi
    4bdd:	0f b6 c9             	movzbl %cl,%ecx
    4be0:	e8 00 00 00 00       	callq  4be5 <__get_data_block+0xd5>
		asm volatile(LOCK_PREFIX "andb %1,%0"
    4be5:	f0 80 63 02 7f       	lock andb $0x7f,0x2(%rbx)
}
    4bea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    4bee:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    4bf5:	00 00 
    4bf7:	75 19                	jne    4c12 <__get_data_block+0x102>
    4bf9:	48 83 c4 30          	add    $0x30,%rsp
    4bfd:	44 89 e8             	mov    %r13d,%eax
    4c00:	5b                   	pop    %rbx
    4c01:	41 5c                	pop    %r12
    4c03:	41 5d                	pop    %r13
    4c05:	5d                   	pop    %rbp
    4c06:	c3                   	retq   
		asm volatile(LOCK_PREFIX "orb %1,%0"
    4c07:	f0 41 80 0c 24 20    	lock orb $0x20,(%r12)
}
    4c0d:	e9 74 ff ff ff       	jmpq   4b86 <__get_data_block+0x76>
    4c12:	e8 00 00 00 00       	callq  4c17 <__get_data_block+0x107>
    4c17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4c1e:	00 00 

0000000000004c20 <get_data_block_dio>:
							  struct buffer_head *bh_result, int create) {
    4c20:	f3 0f 1e fa          	endbr64 
    4c24:	e8 00 00 00 00       	callq  4c29 <get_data_block_dio+0x9>
    4c29:	55                   	push   %rbp
    4c2a:	48 89 e5             	mov    %rsp,%rbp
    4c2d:	41 57                	push   %r15
    4c2f:	41 89 cf             	mov    %ecx,%r15d
    4c32:	41 56                	push   %r14
    4c34:	49 89 d6             	mov    %rdx,%r14
    4c37:	41 55                	push   %r13
    4c39:	49 89 f5             	mov    %rsi,%r13
    4c3c:	41 54                	push   %r12
    4c3e:	49 89 fc             	mov    %rdi,%r12
	return __get_data_block(inode, iblock, bh_result, create,
    4c41:	8b bf 94 00 00 00    	mov    0x94(%rdi),%edi
    4c47:	e8 00 00 00 00       	callq  4c4c <get_data_block_dio+0x2c>
    4c4c:	44 89 f9             	mov    %r15d,%ecx
    4c4f:	4c 89 f2             	mov    %r14,%rdx
    4c52:	4c 89 ee             	mov    %r13,%rsi
    4c55:	50                   	push   %rax
    4c56:	4c 89 e7             	mov    %r12,%rdi
    4c59:	45 31 c9             	xor    %r9d,%r9d
    4c5c:	45 31 c0             	xor    %r8d,%r8d
    4c5f:	e8 ac fe ff ff       	callq  4b10 <__get_data_block>
}
    4c64:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
    4c68:	41 5c                	pop    %r12
    4c6a:	41 5d                	pop    %r13
    4c6c:	41 5e                	pop    %r14
    4c6e:	41 5f                	pop    %r15
    4c70:	5d                   	pop    %rbp
    4c71:	c3                   	retq   
    4c72:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    4c79:	00 00 00 00 
    4c7d:	0f 1f 00             	nopl   (%rax)

0000000000004c80 <get_data_block_bmap>:
							   struct buffer_head *bh_result, int create) {
    4c80:	f3 0f 1e fa          	endbr64 
    4c84:	e8 00 00 00 00       	callq  4c89 <get_data_block_bmap+0x9>
    4c89:	48 8b 47 28          	mov    0x28(%rdi),%rax
	if (unlikely(iblock >= F2FS_I_SB(inode)->max_file_blocks))
    4c8d:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    4c94:	48 39 b0 40 04 00 00 	cmp    %rsi,0x440(%rax)
    4c9b:	76 17                	jbe    4cb4 <get_data_block_bmap+0x34>
							   struct buffer_head *bh_result, int create) {
    4c9d:	55                   	push   %rbp
	return __get_data_block(inode, iblock, bh_result, create,
    4c9e:	45 31 c9             	xor    %r9d,%r9d
    4ca1:	41 b8 02 00 00 00    	mov    $0x2,%r8d
							   struct buffer_head *bh_result, int create) {
    4ca7:	48 89 e5             	mov    %rsp,%rbp
	return __get_data_block(inode, iblock, bh_result, create,
    4caa:	6a 06                	pushq  $0x6
    4cac:	e8 5f fe ff ff       	callq  4b10 <__get_data_block>
    4cb1:	5a                   	pop    %rdx
}
    4cb2:	c9                   	leaveq 
    4cb3:	c3                   	retq   
		return -EFBIG;
    4cb4:	b8 e5 ff ff ff       	mov    $0xffffffe5,%eax
}
    4cb9:	c3                   	retq   
    4cba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000004cc0 <f2fs_mpage_readpages>:
								unsigned nr_pages) {
    4cc0:	e8 00 00 00 00       	callq  4cc5 <f2fs_mpage_readpages+0x5>
    4cc5:	55                   	push   %rbp
    4cc6:	89 c8                	mov    %ecx,%eax
    4cc8:	48 89 e5             	mov    %rsp,%rbp
    4ccb:	41 57                	push   %r15
    4ccd:	41 56                	push   %r14
    4ccf:	49 89 d6             	mov    %rdx,%r14
    4cd2:	41 55                	push   %r13
    4cd4:	41 54                	push   %r12
    4cd6:	53                   	push   %rbx
    4cd7:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
	struct inode *inode = mapping->host;
    4cde:	4c 8b 2f             	mov    (%rdi),%r13
								unsigned nr_pages) {
    4ce1:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
    4ce5:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
    4cec:	49 8b 55 28          	mov    0x28(%r13),%rdx
	const unsigned blkbits = inode->i_blkbits;
    4cf0:	41 8b b5 90 00 00 00 	mov    0x90(%r13),%esi
								unsigned nr_pages) {
    4cf7:	65 48 8b 1c 25 28 00 	mov    %gs:0x28,%rbx
    4cfe:	00 00 
    4d00:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
    4d04:	31 db                	xor    %ebx,%ebx
	const unsigned blocksize = 1 << blkbits;
    4d06:	89 f1                	mov    %esi,%ecx
    4d08:	48 8b 9a 08 04 00 00 	mov    0x408(%rdx),%rbx
    4d0f:	ba 01 00 00 00       	mov    $0x1,%edx
    4d14:	d3 e2                	shl    %cl,%edx
	struct inode *inode = mapping->host;
    4d16:	4c 89 ad 58 ff ff ff 	mov    %r13,-0xa8(%rbp)
    4d1d:	48 89 9d 60 ff ff ff 	mov    %rbx,-0xa0(%rbp)
	const unsigned blkbits = inode->i_blkbits;
    4d24:	89 75 90             	mov    %esi,-0x70(%rbp)
	const unsigned blocksize = 1 << blkbits;
    4d27:	89 55 94             	mov    %edx,-0x6c(%rbp)
	map.m_pblk = 0;
    4d2a:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
    4d31:	00 
	map.m_len = 0;
    4d32:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    4d39:	00 
	map.m_next_pgofs = NULL;
    4d3a:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    4d41:	00 
	map.m_next_extent = NULL;
    4d42:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    4d49:	00 
	map.m_seg_type = NO_CHECK_TYPE;
    4d4a:	c7 45 c8 06 00 00 00 	movl   $0x6,-0x38(%rbp)
	for (; nr_pages; nr_pages--) {
    4d51:	85 c0                	test   %eax,%eax
    4d53:	0f 84 db 09 00 00    	je     5734 <f2fs_mpage_readpages+0xa74>
    4d59:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	struct bio *bio = NULL;
    4d5d:	45 31 ff             	xor    %r15d,%r15d
    4d60:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    4d67:	00 00 
	sector_t last_block_in_bio = 0;
    4d69:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
    4d70:	00 00 00 00 
    4d74:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    4d7b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    4d82:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    4d89:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    4d90:	8b 45 a0             	mov    -0x60(%rbp),%eax
    4d93:	89 45 84             	mov    %eax,-0x7c(%rbp)
		if (pages) {
    4d96:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    4d9a:	48 85 c0             	test   %rax,%rax
    4d9d:	74 5b                	je     4dfa <f2fs_mpage_readpages+0x13a>
			page = list_last_entry(pages, struct page, lru);
    4d9f:	48 8b 40 08          	mov    0x8(%rax),%rax
    4da3:	4c 8d 70 f8          	lea    -0x8(%rax),%r14
 * Useful for spinlocks to avoid one state transition in the
 * cache coherency protocol:
 */
static inline void prefetchw(const void *x)
{
	alternative_input(BASE_PREFETCH, "prefetchw %P1",
    4da7:	0f 18 48 f8          	prefetcht0 -0x8(%rax)
	__list_del(entry->prev, entry->next);
    4dab:	48 8b 08             	mov    (%rax),%rcx
    4dae:	48 8b 50 08          	mov    0x8(%rax),%rdx
			if (add_to_page_cache_lru(page, mapping,
    4db2:	4c 89 f7             	mov    %r14,%rdi
	entry->next = LIST_POISON1;
    4db5:	48 be 00 01 00 00 00 	movabs $0xdead000000000100,%rsi
    4dbc:	00 ad de 
	next->prev = prev;
    4dbf:	48 89 51 08          	mov    %rdx,0x8(%rcx)
	case 8: *(volatile __u64 *)p = *(__u64 *)res; break;
    4dc3:	48 89 0a             	mov    %rcx,(%rdx)
    4dc6:	48 8b 50 18          	mov    0x18(%rax),%rdx
	entry->next = LIST_POISON1;
    4dca:	48 89 30             	mov    %rsi,(%rax)
	entry->prev = LIST_POISON2;
    4dcd:	48 81 c6 00 01 00 00 	add    $0x100,%rsi
    4dd4:	48 89 70 08          	mov    %rsi,0x8(%rax)
	return mapping_gfp_mask(x) | __GFP_NORETRY | __GFP_NOWARN;
    4dd8:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
    4ddf:	8b 9e 84 00 00 00    	mov    0x84(%rsi),%ebx
    4de5:	89 d9                	mov    %ebx,%ecx
    4de7:	89 5d 88             	mov    %ebx,-0x78(%rbp)
    4dea:	80 cd 12             	or     $0x12,%ch
    4ded:	e8 00 00 00 00       	callq  4df2 <f2fs_mpage_readpages+0x132>
    4df2:	85 c0                	test   %eax,%eax
    4df4:	0f 85 d5 00 00 00    	jne    4ecf <f2fs_mpage_readpages+0x20f>
		last_block = block_in_file + nr_pages;// 读取范围中的最后一个文件逻辑块
    4dfa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
		block_in_file = (sector_t) page->index;// 文件中的逻辑块号
    4dfe:	49 8b 5e 20          	mov    0x20(%r14),%rbx
		last_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;// 文件的最后一个逻辑块
    4e02:	49 8b 4d 50          	mov    0x50(%r13),%rcx
		last_block = block_in_file + nr_pages;// 读取范围中的最后一个文件逻辑块
    4e06:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
		last_block_in_file = (i_size_read(inode) + blocksize - 1) >> blkbits;// 文件的最后一个逻辑块
    4e0a:	8b 45 94             	mov    -0x6c(%rbp),%eax
    4e0d:	48 8d 44 01 ff       	lea    -0x1(%rcx,%rax,1),%rax
    4e12:	0f b6 4d 90          	movzbl -0x70(%rbp),%ecx
    4e16:	48 d3 f8             	sar    %cl,%rax
    4e19:	48 39 d0             	cmp    %rdx,%rax
    4e1c:	48 0f 47 c2          	cmova  %rdx,%rax
		if ((map.m_flags & F2FS_MAP_MAPPED) &&
    4e20:	f6 45 b4 20          	testb  $0x20,-0x4c(%rbp)
    4e24:	74 17                	je     4e3d <f2fs_mpage_readpages+0x17d>
			block_in_file > map.m_lblk &&
    4e26:	8b 55 ac             	mov    -0x54(%rbp),%edx
    4e29:	48 89 d1             	mov    %rdx,%rcx
		if ((map.m_flags & F2FS_MAP_MAPPED) &&
    4e2c:	48 39 da             	cmp    %rbx,%rdx
    4e2f:	73 0c                	jae    4e3d <f2fs_mpage_readpages+0x17d>
			block_in_file < (map.m_lblk + map.m_len))
    4e31:	03 4d b0             	add    -0x50(%rbp),%ecx
			block_in_file > map.m_lblk &&
    4e34:	48 39 d9             	cmp    %rbx,%rcx
    4e37:	0f 87 d2 01 00 00    	ja     500f <f2fs_mpage_readpages+0x34f>
		map.m_flags = 0;
    4e3d:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
		if (block_in_file < last_block) {
    4e44:	48 39 d8             	cmp    %rbx,%rax
    4e47:	0f 87 91 01 00 00    	ja     4fde <f2fs_mpage_readpages+0x31e>
	current->pagefault_disabled++;
    4e4d:	48 8b b5 68 ff ff ff 	mov    -0x98(%rbp),%rsi
    4e54:	83 86 38 12 00 00 01 	addl   $0x1,0x1238(%rsi)
	return page_to_virt(page);
    4e5b:	4c 89 f1             	mov    %r14,%rcx
    4e5e:	48 2b 0d 00 00 00 00 	sub    0x0(%rip),%rcx        # 4e65 <f2fs_mpage_readpages+0x1a5>
    4e65:	31 c0                	xor    %eax,%eax
    4e67:	48 c1 f9 06          	sar    $0x6,%rcx
    4e6b:	48 c1 e1 0c          	shl    $0xc,%rcx
    4e6f:	48 03 0d 00 00 00 00 	add    0x0(%rip),%rcx        # 4e76 <f2fs_mpage_readpages+0x1b6>
    4e76:	48 8d 79 08          	lea    0x8(%rcx),%rdi
    4e7a:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
    4e81:	48 c7 81 f8 0f 00 00 	movq   $0x0,0xff8(%rcx)
    4e88:	00 00 00 00 
    4e8c:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    4e90:	48 29 f9             	sub    %rdi,%rcx
    4e93:	81 c1 00 10 00 00    	add    $0x1000,%ecx
    4e99:	c1 e9 03             	shr    $0x3,%ecx
    4e9c:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	current->pagefault_disabled--;
    4e9f:	83 ae 38 12 00 00 01 	subl   $0x1,0x1238(%rsi)
	__READ_ONCE_SIZE;
    4ea6:	49 8b 56 08          	mov    0x8(%r14),%rdx
    4eaa:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    4eae:	83 e2 01             	and    $0x1,%edx
    4eb1:	49 0f 44 c6          	cmove  %r14,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    4eb5:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    4eb8:	a8 08                	test   $0x8,%al
    4eba:	0f 84 fe 05 00 00    	je     54be <f2fs_mpage_readpages+0x7fe>
			unlock_page(page);
    4ec0:	4c 89 f7             	mov    %r14,%rdi
    4ec3:	e8 00 00 00 00       	callq  4ec8 <f2fs_mpage_readpages+0x208>
		if (pages)
    4ec8:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
    4ecd:	74 1d                	je     4eec <f2fs_mpage_readpages+0x22c>
    4ecf:	49 8b 46 08          	mov    0x8(%r14),%rax
		return (struct page *) (head - 1);
    4ed3:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
    4ed7:	a8 01                	test   $0x1,%al
    4ed9:	49 0f 44 fe          	cmove  %r14,%rdi
    4edd:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    4ee2:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
    4ee6:	0f 84 b2 03 00 00    	je     529e <f2fs_mpage_readpages+0x5de>
	for (; nr_pages; nr_pages--) {
    4eec:	48 83 6d a0 01       	subq   $0x1,-0x60(%rbp)
    4ef1:	0f 85 99 fe ff ff    	jne    4d90 <f2fs_mpage_readpages+0xd0>
	BUG_ON(pages && !list_empty(pages));
    4ef7:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
    4efc:	0f 85 44 09 00 00    	jne    5846 <f2fs_mpage_readpages+0xb86>
	if (bio)
    4f02:	4d 85 ff             	test   %r15,%r15
    4f05:	0f 84 ac 00 00 00    	je     4fb7 <f2fs_mpage_readpages+0x2f7>
    4f0b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
	if (!is_read_io(bio_op(bio))) {
    4f12:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    4f17:	48 8b 40 28          	mov    0x28(%rax),%rax
    4f1b:	4c 8b a8 08 04 00 00 	mov    0x408(%rax),%r13
    4f22:	49 8b 45 00          	mov    0x0(%r13),%rax
    4f26:	49 89 c4             	mov    %rax,%r12
    4f29:	0f 84 22 06 00 00    	je     5551 <f2fs_mpage_readpages+0x891>
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
    4f2f:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
    4f36:	48 8b 52 10          	mov    0x10(%rdx),%rdx
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    4f3a:	f6 82 84 08 00 00 02 	testb  $0x2,0x884(%rdx)
    4f41:	0f 84 8d 06 00 00    	je     55d4 <f2fs_mpage_readpages+0x914>
    4f47:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    4f4e:	00 00 
    4f50:	48 83 ba 48 0b 00 00 	cmpq   $0x0,0xb48(%rdx)
    4f57:	00 
    4f58:	0f 84 76 06 00 00    	je     55d4 <f2fs_mpage_readpages+0x914>
			blk_finish_plug(current->plug);
    4f5e:	48 8b ba 48 0b 00 00 	mov    0xb48(%rdx),%rdi
    4f65:	e8 00 00 00 00       	callq  4f6a <f2fs_mpage_readpages+0x2aa>
		start %= F2FS_IO_SIZE(sbi);
    4f6a:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    4f71:	41 8b 47 30          	mov    0x30(%r15),%eax
		start %= F2FS_IO_SIZE(sbi);
    4f75:	ba 01 00 00 00       	mov    $0x1,%edx
    4f7a:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    4f7c:	c1 e8 0c             	shr    $0xc,%eax
		start %= F2FS_IO_SIZE(sbi);
    4f7f:	8d 5a ff             	lea    -0x1(%rdx),%ebx
		if (start == 0)
    4f82:	21 c3                	and    %eax,%ebx
    4f84:	74 08                	je     4f8e <f2fs_mpage_readpages+0x2ce>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    4f86:	39 da                	cmp    %ebx,%edx
    4f88:	0f 87 6e 06 00 00    	ja     55fc <f2fs_mpage_readpages+0x93c>
	if (is_read_io(bio_op(bio)))
    4f8e:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    4f93:	4d 8b 65 00          	mov    0x0(%r13),%r12
    4f97:	0f 84 b4 05 00 00    	je     5551 <f2fs_mpage_readpages+0x891>
    4f9d:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    4fa2:	4c 89 ef             	mov    %r13,%rdi
    4fa5:	31 d2                	xor    %edx,%edx
    4fa7:	4c 89 fe             	mov    %r15,%rsi
    4faa:	e8 00 00 00 00       	callq  4faf <f2fs_mpage_readpages+0x2ef>
	submit_bio(bio);//提交进行io操作
    4faf:	4c 89 ff             	mov    %r15,%rdi
    4fb2:	e8 00 00 00 00       	callq  4fb7 <f2fs_mpage_readpages+0x2f7>
}
    4fb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    4fbb:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    4fc2:	00 00 
    4fc4:	0f 85 a1 08 00 00    	jne    586b <f2fs_mpage_readpages+0xbab>
    4fca:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    4fd1:	31 c0                	xor    %eax,%eax
    4fd3:	5b                   	pop    %rbx
    4fd4:	41 5c                	pop    %r12
    4fd6:	41 5d                	pop    %r13
    4fd8:	41 5e                	pop    %r14
    4fda:	41 5f                	pop    %r15
    4fdc:	5d                   	pop    %rbp
    4fdd:	c3                   	retq   
			map.m_len = last_block - block_in_file;
    4fde:	29 d8                	sub    %ebx,%eax
			if (f2fs_map_blocks(inode, &map, 0,
    4fe0:	31 c9                	xor    %ecx,%ecx
    4fe2:	31 d2                	xor    %edx,%edx
    4fe4:	4c 89 ef             	mov    %r13,%rdi
    4fe7:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
			map.m_lblk = block_in_file;
    4feb:	89 5d ac             	mov    %ebx,-0x54(%rbp)
			map.m_len = last_block - block_in_file;
    4fee:	89 45 b0             	mov    %eax,-0x50(%rbp)
			if (f2fs_map_blocks(inode, &map, 0,
    4ff1:	e8 00 00 00 00       	callq  4ff6 <f2fs_mpage_readpages+0x336>
    4ff6:	85 c0                	test   %eax,%eax
    4ff8:	0f 85 cd 04 00 00    	jne    54cb <f2fs_mpage_readpages+0x80b>
    4ffe:	f3 0f 1e fa          	endbr64 
		if ((map.m_flags & F2FS_MAP_MAPPED)) {
    5002:	f6 45 b4 20          	testb  $0x20,-0x4c(%rbp)
    5006:	0f 84 41 fe ff ff    	je     4e4d <f2fs_mpage_readpages+0x18d>
    500c:	8b 55 ac             	mov    -0x54(%rbp),%edx
			block_nr = map.m_pblk + block_in_file - map.m_lblk; //ZN：block_in_file的对应物理地址
    500f:	8b 45 a8             	mov    -0x58(%rbp),%eax
    5012:	48 01 c3             	add    %rax,%rbx
    5015:	48 29 d3             	sub    %rdx,%rbx
    5018:	49 8b 56 08          	mov    0x8(%r14),%rdx
    501c:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
    5020:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    5024:	83 e2 01             	and    $0x1,%edx
    5027:	49 0f 44 c6          	cmove  %r14,%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    502b:	f0 80 48 02 01       	lock orb $0x1,0x2(%rax)
    5030:	49 8b 56 08          	mov    0x8(%r14),%rdx
    5034:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    5038:	83 e2 01             	and    $0x1,%edx
    503b:	49 0f 44 c6          	cmove  %r14,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    503f:	48 8b 00             	mov    (%rax),%rax
	if (ret)
    5042:	a8 08                	test   $0x8,%al
    5044:	0f 84 d5 00 00 00    	je     511f <f2fs_mpage_readpages+0x45f>
		if (bio && (last_block_in_bio != block_nr - 1 ||
    504a:	4d 85 ff             	test   %r15,%r15
    504d:	0f 84 6f 02 00 00    	je     52c2 <f2fs_mpage_readpages+0x602>
    5053:	49 8b 45 28          	mov    0x28(%r13),%rax
    5057:	4c 8b a0 08 04 00 00 	mov    0x408(%rax),%r12
    505e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    5062:	48 83 e8 01          	sub    $0x1,%rax
    5066:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
    506d:	0f 84 66 06 00 00    	je     56d9 <f2fs_mpage_readpages+0xa19>
	if (!is_read_io(bio_op(bio))) {
    5073:	49 8b 04 24          	mov    (%r12),%rax
    5077:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    507c:	49 89 c0             	mov    %rax,%r8
    507f:	0f 84 23 02 00 00    	je     52a8 <f2fs_mpage_readpages+0x5e8>
    5085:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
    508c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    5090:	f6 82 84 08 00 00 02 	testb  $0x2,0x884(%rdx)
    5097:	0f 84 d0 02 00 00    	je     536d <f2fs_mpage_readpages+0x6ad>
    509d:	48 8b 9d 48 ff ff ff 	mov    -0xb8(%rbp),%rbx
    50a4:	48 83 bb 48 0b 00 00 	cmpq   $0x0,0xb48(%rbx)
    50ab:	00 
    50ac:	0f 84 bb 02 00 00    	je     536d <f2fs_mpage_readpages+0x6ad>
			blk_finish_plug(current->plug);
    50b2:	48 8b bb 48 0b 00 00 	mov    0xb48(%rbx),%rdi
    50b9:	e8 00 00 00 00       	callq  50be <f2fs_mpage_readpages+0x3fe>
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    50be:	41 8b 47 30          	mov    0x30(%r15),%eax
		start %= F2FS_IO_SIZE(sbi);
    50c2:	ba 01 00 00 00       	mov    $0x1,%edx
    50c7:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    50ce:	00 
    50cf:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    50d1:	c1 e8 0c             	shr    $0xc,%eax
		start %= F2FS_IO_SIZE(sbi);
    50d4:	8d 5a ff             	lea    -0x1(%rdx),%ebx
		if (start == 0)
    50d7:	21 c3                	and    %eax,%ebx
    50d9:	0f 84 4d 03 00 00    	je     542c <f2fs_mpage_readpages+0x76c>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    50df:	39 d3                	cmp    %edx,%ebx
    50e1:	0f 82 af 02 00 00    	jb     5396 <f2fs_mpage_readpages+0x6d6>
    50e7:	e9 40 03 00 00       	jmpq   542c <f2fs_mpage_readpages+0x76c>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    50ec:	48 8b 07             	mov    (%rdi),%rax
    50ef:	48 c1 e8 33          	shr    $0x33,%rax
    50f3:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    50f6:	83 f8 04             	cmp    $0x4,%eax
    50f9:	0f 85 e3 fd ff ff    	jne    4ee2 <f2fs_mpage_readpages+0x222>
	switch (page->pgmap->type) {
    50ff:	48 8b 47 08          	mov    0x8(%rdi),%rax
    5103:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    5109:	83 e8 01             	sub    $0x1,%eax
    510c:	83 f8 02             	cmp    $0x2,%eax
    510f:	0f 87 cd fd ff ff    	ja     4ee2 <f2fs_mpage_readpages+0x222>
		__put_devmap_managed_page(page);
    5115:	e8 00 00 00 00       	callq  511a <f2fs_mpage_readpages+0x45a>
		return;
    511a:	e9 cd fd ff ff       	jmpq   4eec <f2fs_mpage_readpages+0x22c>

#ifdef CONFIG_CLEANCACHE
#define cleancache_enabled (1)
static inline bool cleancache_fs_enabled_mapping(struct address_space *mapping)
{
	return mapping->host->i_sb->cleancache_poolid >= 0;
    511f:	49 8b 46 18          	mov    0x18(%r14),%rax
    5123:	48 8b 00             	mov    (%rax),%rax
    5126:	48 8b 40 28          	mov    0x28(%rax),%rax
		__cleancache_init_shared_fs(sb);
}

static inline int cleancache_get_page(struct page *page)
{
	if (cleancache_enabled && cleancache_fs_enabled(page))
    512a:	8b 80 50 04 00 00    	mov    0x450(%rax),%eax
    5130:	85 c0                	test   %eax,%eax
    5132:	0f 88 12 ff ff ff    	js     504a <f2fs_mpage_readpages+0x38a>
		return __cleancache_get_page(page);
    5138:	4c 89 f7             	mov    %r14,%rdi
    513b:	e8 00 00 00 00       	callq  5140 <f2fs_mpage_readpages+0x480>
			if (!PageUptodate(page) && !cleancache_get_page(page)) {
    5140:	85 c0                	test   %eax,%eax
    5142:	0f 85 02 ff ff ff    	jne    504a <f2fs_mpage_readpages+0x38a>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    5148:	f0 41 80 0e 08       	lock orb $0x8,(%r14)
		if (bio) {
    514d:	4d 85 ff             	test   %r15,%r15
    5150:	0f 84 38 01 00 00    	je     528e <f2fs_mpage_readpages+0x5ce>
	return sb->s_fs_info;
    5156:	49 8b 45 28          	mov    0x28(%r13),%rax
	if (!is_read_io(bio_op(bio))) {
    515a:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    515f:	4c 8b a0 08 04 00 00 	mov    0x408(%rax),%r12
    5166:	49 8b 04 24          	mov    (%r12),%rax
    516a:	49 89 c0             	mov    %rax,%r8
    516d:	0f 84 eb 05 00 00    	je     575e <f2fs_mpage_readpages+0xa9e>
F2FS_FEATURE_FUNCS(blkzoned, BLKZONED);
    5173:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
    517a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
		if (f2fs_sb_has_blkzoned(sbi->sb) && current->plug)
    517e:	f6 82 84 08 00 00 02 	testb  $0x2,0x884(%rdx)
    5185:	0f 84 18 04 00 00    	je     55a3 <f2fs_mpage_readpages+0x8e3>
    518b:	48 8b 9d 40 ff ff ff 	mov    -0xc0(%rbp),%rbx
    5192:	48 83 bb 48 0b 00 00 	cmpq   $0x0,0xb48(%rbx)
    5199:	00 
    519a:	0f 84 03 04 00 00    	je     55a3 <f2fs_mpage_readpages+0x8e3>
			blk_finish_plug(current->plug);
    51a0:	48 8b bb 48 0b 00 00 	mov    0xb48(%rbx),%rdi
    51a7:	e8 00 00 00 00       	callq  51ac <f2fs_mpage_readpages+0x4ec>
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    51ac:	41 8b 47 30          	mov    0x30(%r15),%eax
		start %= F2FS_IO_SIZE(sbi);
    51b0:	ba 01 00 00 00       	mov    $0x1,%edx
    51b5:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    51bc:	00 
    51bd:	d3 e2                	shl    %cl,%edx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    51bf:	c1 e8 0c             	shr    $0xc,%eax
		start %= F2FS_IO_SIZE(sbi);
    51c2:	8d 5a ff             	lea    -0x1(%rdx),%ebx
		if (start == 0)
    51c5:	21 c3                	and    %eax,%ebx
    51c7:	0f 84 98 00 00 00    	je     5265 <f2fs_mpage_readpages+0x5a5>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    51cd:	39 da                	cmp    %ebx,%edx
    51cf:	0f 86 90 00 00 00    	jbe    5265 <f2fs_mpage_readpages+0x5a5>
    51d5:	4c 89 6d 88          	mov    %r13,-0x78(%rbp)
					mempool_alloc(sbi->write_io_dummy,
    51d9:	49 8b bc 24 70 01 00 	mov    0x170(%r12),%rdi
    51e0:	00 
    51e1:	be 00 88 60 00       	mov    $0x608800,%esi
    51e6:	e8 00 00 00 00       	callq  51eb <f2fs_mpage_readpages+0x52b>
    51eb:	49 89 c5             	mov    %rax,%r13
			f2fs_bug_on(sbi, !page);
    51ee:	48 85 c0             	test   %rax,%rax
    51f1:	0f 84 41 06 00 00    	je     5838 <f2fs_mpage_readpages+0xb78>
    51f7:	f0 41 80 4d 01 10    	lock orb $0x10,0x1(%r13)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    51fd:	49 c7 45 28 fe ff ff 	movq   $0xfffffffffffffffe,0x28(%r13)
    5204:	ff 
	might_sleep();
    5205:	e8 00 00 00 00       	callq  520a <f2fs_mpage_readpages+0x54a>
    520a:	49 8b 55 08          	mov    0x8(%r13),%rdx
		return (struct page *) (head - 1);
    520e:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    5212:	83 e2 01             	and    $0x1,%edx
    5215:	49 0f 44 c5          	cmove  %r13,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    5219:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    521f:	0f 82 06 06 00 00    	jb     582b <f2fs_mpage_readpages+0xb6b>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    5225:	31 c9                	xor    %ecx,%ecx
    5227:	ba 00 10 00 00       	mov    $0x1000,%edx
    522c:	4c 89 ee             	mov    %r13,%rsi
    522f:	4c 89 ff             	mov    %r15,%rdi
    5232:	e8 00 00 00 00       	callq  5237 <f2fs_mpage_readpages+0x577>
    5237:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    523c:	77 09                	ja     5247 <f2fs_mpage_readpages+0x587>
				f2fs_bug_on(sbi, 1);
    523e:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    5240:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    5247:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    524e:	00 
    524f:	b8 01 00 00 00       	mov    $0x1,%eax
    5254:	83 c3 01             	add    $0x1,%ebx
    5257:	d3 e0                	shl    %cl,%eax
    5259:	39 c3                	cmp    %eax,%ebx
    525b:	0f 82 78 ff ff ff    	jb     51d9 <f2fs_mpage_readpages+0x519>
    5261:	4c 8b 6d 88          	mov    -0x78(%rbp),%r13
	if (is_read_io(bio_op(bio)))
    5265:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    526a:	4d 8b 04 24          	mov    (%r12),%r8
    526e:	0f 84 ea 04 00 00    	je     575e <f2fs_mpage_readpages+0xa9e>
    5274:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    5279:	4c 89 e7             	mov    %r12,%rdi
    527c:	31 d2                	xor    %edx,%edx
    527e:	4c 89 fe             	mov    %r15,%rsi
    5281:	e8 00 00 00 00       	callq  5286 <f2fs_mpage_readpages+0x5c6>
	submit_bio(bio);//提交进行io操作
    5286:	4c 89 ff             	mov    %r15,%rdi
    5289:	e8 00 00 00 00       	callq  528e <f2fs_mpage_readpages+0x5ce>
		unlock_page(page);
    528e:	4c 89 f7             	mov    %r14,%rdi
    5291:	45 31 ff             	xor    %r15d,%r15d
    5294:	e8 00 00 00 00       	callq  5299 <f2fs_mpage_readpages+0x5d9>
    5299:	e9 2a fc ff ff       	jmpq   4ec8 <f2fs_mpage_readpages+0x208>
		__put_page(page);
    529e:	e8 00 00 00 00       	callq  52a3 <f2fs_mpage_readpages+0x5e3>
    52a3:	e9 44 fc ff ff       	jmpq   4eec <f2fs_mpage_readpages+0x22c>
    52a8:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	nvm_redirect_bio(sbi, bio, type);
    52ad:	4c 89 e7             	mov    %r12,%rdi
    52b0:	31 d2                	xor    %edx,%edx
    52b2:	4c 89 fe             	mov    %r15,%rsi
    52b5:	e8 00 00 00 00       	callq  52ba <f2fs_mpage_readpages+0x5fa>
	submit_bio(bio);//提交进行io操作
    52ba:	4c 89 ff             	mov    %r15,%rdi
    52bd:	e8 00 00 00 00       	callq  52c2 <f2fs_mpage_readpages+0x602>
			bio = f2fs_grab_read_bio(inode, block_nr, nr_pages);
    52c2:	8b 55 84             	mov    -0x7c(%rbp),%edx
    52c5:	8b 75 88             	mov    -0x78(%rbp),%esi
    52c8:	4c 89 ef             	mov    %r13,%rdi
    52cb:	e8 20 c5 ff ff       	callq  17f0 <f2fs_grab_read_bio>
    52d0:	49 89 c7             	mov    %rax,%r15
			if (IS_ERR(bio)) {
    52d3:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    52d9:	0f 87 e9 01 00 00    	ja     54c8 <f2fs_mpage_readpages+0x808>
		if (bio_add_page(bio, page, blocksize, 0) < blocksize)
    52df:	8b 5d 94             	mov    -0x6c(%rbp),%ebx
    52e2:	31 c9                	xor    %ecx,%ecx
    52e4:	4c 89 f6             	mov    %r14,%rsi
    52e7:	4c 89 ff             	mov    %r15,%rdi
    52ea:	89 da                	mov    %ebx,%edx
    52ec:	e8 00 00 00 00       	callq  52f1 <f2fs_mpage_readpages+0x631>
    52f1:	39 d8                	cmp    %ebx,%eax
    52f3:	0f 83 b5 01 00 00    	jae    54ae <f2fs_mpage_readpages+0x7ee>
    52f9:	49 8b 45 28          	mov    0x28(%r13),%rax
    52fd:	4c 8b a0 08 04 00 00 	mov    0x408(%rax),%r12
    5304:	e9 6a fd ff ff       	jmpq   5073 <f2fs_mpage_readpages+0x3b3>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    5309:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5310 <f2fs_mpage_readpages+0x650>
    5310:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    5312:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 531a <f2fs_mpage_readpages+0x65a>
    5319:	00 
    531a:	0f 92 c0             	setb   %al
    531d:	4d 85 ff             	test   %r15,%r15
    5320:	74 8b                	je     52ad <f2fs_mpage_readpages+0x5ed>
    5322:	84 c0                	test   %al,%al
    5324:	74 87                	je     52ad <f2fs_mpage_readpages+0x5ed>
    5326:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 532d <f2fs_mpage_readpages+0x66d>
    532d:	48 85 db             	test   %rbx,%rbx
    5330:	74 36                	je     5368 <f2fs_mpage_readpages+0x6a8>
    5332:	4c 89 a5 38 ff ff ff 	mov    %r12,-0xc8(%rbp)
    5339:	48 8b 03             	mov    (%rbx),%rax
    533c:	49 89 dc             	mov    %rbx,%r12
    533f:	4c 89 c3             	mov    %r8,%rbx
    5342:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    5347:	49 83 c4 18          	add    $0x18,%r12
    534b:	4c 89 f9             	mov    %r15,%rcx
    534e:	31 d2                	xor    %edx,%edx
    5350:	48 89 de             	mov    %rbx,%rsi
    5353:	e8 00 00 00 00       	callq  5358 <f2fs_mpage_readpages+0x698>
    5358:	49 8b 04 24          	mov    (%r12),%rax
    535c:	48 85 c0             	test   %rax,%rax
    535f:	75 e1                	jne    5342 <f2fs_mpage_readpages+0x682>
    5361:	4c 8b a5 38 ff ff ff 	mov    -0xc8(%rbp),%r12
    5368:	e9 40 ff ff ff       	jmpq   52ad <f2fs_mpage_readpages+0x5ed>
		start %= F2FS_IO_SIZE(sbi);
    536d:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    5374:	00 
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    5375:	41 8b 57 30          	mov    0x30(%r15),%edx
		start %= F2FS_IO_SIZE(sbi);
    5379:	be 01 00 00 00       	mov    $0x1,%esi
    537e:	d3 e6                	shl    %cl,%esi
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    5380:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    5383:	8d 5e ff             	lea    -0x1(%rsi),%ebx
		if (start == 0)
    5386:	21 d3                	and    %edx,%ebx
    5388:	0f 84 ad 00 00 00    	je     543b <f2fs_mpage_readpages+0x77b>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    538e:	39 de                	cmp    %ebx,%esi
    5390:	0f 86 c5 04 00 00    	jbe    585b <f2fs_mpage_readpages+0xb9b>
    5396:	4c 89 ad 38 ff ff ff 	mov    %r13,-0xc8(%rbp)
					mempool_alloc(sbi->write_io_dummy,
    539d:	49 8b bc 24 70 01 00 	mov    0x170(%r12),%rdi
    53a4:	00 
    53a5:	be 00 88 60 00       	mov    $0x608800,%esi
    53aa:	e8 00 00 00 00       	callq  53af <f2fs_mpage_readpages+0x6ef>
    53af:	49 89 c5             	mov    %rax,%r13
			f2fs_bug_on(sbi, !page);
    53b2:	48 85 c0             	test   %rax,%rax
    53b5:	0f 84 88 01 00 00    	je     5543 <f2fs_mpage_readpages+0x883>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    53bb:	f0 41 80 4d 01 10    	lock orb $0x10,0x1(%r13)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    53c1:	49 c7 45 28 fe ff ff 	movq   $0xfffffffffffffffe,0x28(%r13)
    53c8:	ff 
	might_sleep();
    53c9:	e8 00 00 00 00       	callq  53ce <f2fs_mpage_readpages+0x70e>
    53ce:	49 8b 55 08          	mov    0x8(%r13),%rdx
    53d2:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    53d6:	83 e2 01             	and    $0x1,%edx
    53d9:	49 0f 44 c5          	cmove  %r13,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    53dd:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    53e3:	0f 82 4d 01 00 00    	jb     5536 <f2fs_mpage_readpages+0x876>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    53e9:	31 c9                	xor    %ecx,%ecx
    53eb:	ba 00 10 00 00       	mov    $0x1000,%edx
    53f0:	4c 89 ee             	mov    %r13,%rsi
    53f3:	4c 89 ff             	mov    %r15,%rdi
    53f6:	e8 00 00 00 00       	callq  53fb <f2fs_mpage_readpages+0x73b>
    53fb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    5400:	77 09                	ja     540b <f2fs_mpage_readpages+0x74b>
				f2fs_bug_on(sbi, 1);
    5402:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    5404:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    540b:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    5412:	00 
    5413:	b8 01 00 00 00       	mov    $0x1,%eax
    5418:	83 c3 01             	add    $0x1,%ebx
    541b:	d3 e0                	shl    %cl,%eax
    541d:	39 c3                	cmp    %eax,%ebx
    541f:	0f 82 78 ff ff ff    	jb     539d <f2fs_mpage_readpages+0x6dd>
    5425:	4c 8b ad 38 ff ff ff 	mov    -0xc8(%rbp),%r13
	if (is_read_io(bio_op(bio)))
    542c:	41 80 7f 10 00       	cmpb   $0x0,0x10(%r15)
    5431:	4d 8b 04 24          	mov    (%r12),%r8
    5435:	0f 84 6d fe ff ff    	je     52a8 <f2fs_mpage_readpages+0x5e8>
    543b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5440:	e9 68 fe ff ff       	jmpq   52ad <f2fs_mpage_readpages+0x5ed>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    5445:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 544c <f2fs_mpage_readpages+0x78c>
    544c:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    544e:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 5456 <f2fs_mpage_readpages+0x796>
    5455:	00 
    5456:	0f 92 c0             	setb   %al
    5459:	4d 85 ff             	test   %r15,%r15
    545c:	0f 84 4b fe ff ff    	je     52ad <f2fs_mpage_readpages+0x5ed>
    5462:	84 c0                	test   %al,%al
    5464:	0f 84 43 fe ff ff    	je     52ad <f2fs_mpage_readpages+0x5ed>
    546a:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 5471 <f2fs_mpage_readpages+0x7b1>
    5471:	48 85 db             	test   %rbx,%rbx
    5474:	0f 84 ee fe ff ff    	je     5368 <f2fs_mpage_readpages+0x6a8>
    547a:	4c 89 a5 38 ff ff ff 	mov    %r12,-0xc8(%rbp)
    5481:	48 8b 03             	mov    (%rbx),%rax
    5484:	49 89 dc             	mov    %rbx,%r12
    5487:	4c 89 c3             	mov    %r8,%rbx
    548a:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    548f:	49 83 c4 18          	add    $0x18,%r12
    5493:	4c 89 f9             	mov    %r15,%rcx
    5496:	31 d2                	xor    %edx,%edx
    5498:	48 89 de             	mov    %rbx,%rsi
    549b:	e8 00 00 00 00       	callq  54a0 <f2fs_mpage_readpages+0x7e0>
    54a0:	49 8b 04 24          	mov    (%r12),%rax
    54a4:	48 85 c0             	test   %rax,%rax
    54a7:	75 e1                	jne    548a <f2fs_mpage_readpages+0x7ca>
    54a9:	e9 b3 fe ff ff       	jmpq   5361 <f2fs_mpage_readpages+0x6a1>
		last_block_in_bio = block_nr;
    54ae:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    54b2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    54b9:	e9 0a fa ff ff       	jmpq   4ec8 <f2fs_mpage_readpages+0x208>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    54be:	f0 41 80 0e 08       	lock orb $0x8,(%r14)
}
    54c3:	e9 f8 f9 ff ff       	jmpq   4ec0 <f2fs_mpage_readpages+0x200>
				bio = NULL;
    54c8:	45 31 ff             	xor    %r15d,%r15d
    54cb:	f0 41 80 0e 02       	lock orb $0x2,(%r14)
	current->pagefault_disabled++;
    54d0:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
    54d7:	83 86 38 12 00 00 01 	addl   $0x1,0x1238(%rsi)
	return page_to_virt(page);
    54de:	4c 89 f0             	mov    %r14,%rax
    54e1:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # 54e8 <f2fs_mpage_readpages+0x828>
    54e8:	48 c1 f8 06          	sar    $0x6,%rax
    54ec:	48 c1 e0 0c          	shl    $0xc,%rax
    54f0:	48 03 05 00 00 00 00 	add    0x0(%rip),%rax        # 54f7 <f2fs_mpage_readpages+0x837>
    54f7:	48 8d 78 08          	lea    0x8(%rax),%rdi
    54fb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    5502:	48 c7 80 f8 0f 00 00 	movq   $0x0,0xff8(%rax)
    5509:	00 00 00 00 
    550d:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    5511:	48 29 f8             	sub    %rdi,%rax
    5514:	8d 88 00 10 00 00    	lea    0x1000(%rax),%ecx
    551a:	31 c0                	xor    %eax,%eax
    551c:	c1 e9 03             	shr    $0x3,%ecx
    551f:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	current->pagefault_disabled--;
    5522:	83 ae 38 12 00 00 01 	subl   $0x1,0x1238(%rsi)
		unlock_page(page);
    5529:	4c 89 f7             	mov    %r14,%rdi
    552c:	e8 00 00 00 00       	callq  5531 <f2fs_mpage_readpages+0x871>
		goto next_page;
    5531:	e9 92 f9 ff ff       	jmpq   4ec8 <f2fs_mpage_readpages+0x208>
		__lock_page(page);
    5536:	4c 89 ef             	mov    %r13,%rdi
    5539:	e8 00 00 00 00       	callq  553e <f2fs_mpage_readpages+0x87e>
    553e:	e9 a6 fe ff ff       	jmpq   53e9 <f2fs_mpage_readpages+0x729>
			f2fs_bug_on(sbi, !page);
    5543:	0f 0b                	ud2    
    5545:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
}
    554c:	e9 6a fe ff ff       	jmpq   53bb <f2fs_mpage_readpages+0x6fb>
    5551:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5556:	e9 47 fa ff ff       	jmpq   4fa2 <f2fs_mpage_readpages+0x2e2>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    555b:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5562 <f2fs_mpage_readpages+0x8a2>
    5562:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    5564:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 556c <f2fs_mpage_readpages+0x8ac>
    556b:	00 
    556c:	0f 83 30 fa ff ff    	jae    4fa2 <f2fs_mpage_readpages+0x2e2>
    5572:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 5579 <f2fs_mpage_readpages+0x8b9>
    5579:	48 85 db             	test   %rbx,%rbx
    557c:	74 20                	je     559e <f2fs_mpage_readpages+0x8de>
    557e:	48 8b 03             	mov    (%rbx),%rax
    5581:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    5585:	48 83 c3 18          	add    $0x18,%rbx
    5589:	4c 89 f9             	mov    %r15,%rcx
    558c:	31 d2                	xor    %edx,%edx
    558e:	4c 89 e6             	mov    %r12,%rsi
    5591:	e8 00 00 00 00       	callq  5596 <f2fs_mpage_readpages+0x8d6>
    5596:	48 8b 03             	mov    (%rbx),%rax
    5599:	48 85 c0             	test   %rax,%rax
    559c:	75 e3                	jne    5581 <f2fs_mpage_readpages+0x8c1>
    559e:	e9 ff f9 ff ff       	jmpq   4fa2 <f2fs_mpage_readpages+0x2e2>
		start %= F2FS_IO_SIZE(sbi);
    55a3:	41 8b 8c 24 f4 04 00 	mov    0x4f4(%r12),%ecx
    55aa:	00 
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    55ab:	41 8b 57 30          	mov    0x30(%r15),%edx
		start %= F2FS_IO_SIZE(sbi);
    55af:	be 01 00 00 00       	mov    $0x1,%esi
    55b4:	d3 e6                	shl    %cl,%esi
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    55b6:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    55b9:	8d 5e ff             	lea    -0x1(%rsi),%ebx
		if (start == 0)
    55bc:	21 d3                	and    %edx,%ebx
    55be:	0f 84 b0 fc ff ff    	je     5274 <f2fs_mpage_readpages+0x5b4>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    55c4:	39 f3                	cmp    %esi,%ebx
    55c6:	0f 82 09 fc ff ff    	jb     51d5 <f2fs_mpage_readpages+0x515>
	if (is_read_io(bio_op(bio)))
    55cc:	49 89 c0             	mov    %rax,%r8
    55cf:	e9 a0 fc ff ff       	jmpq   5274 <f2fs_mpage_readpages+0x5b4>
		start %= F2FS_IO_SIZE(sbi);
    55d4:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    55db:	41 8b 57 30          	mov    0x30(%r15),%edx
		start %= F2FS_IO_SIZE(sbi);
    55df:	be 01 00 00 00       	mov    $0x1,%esi
    55e4:	d3 e6                	shl    %cl,%esi
		start = bio->bi_iter.bi_size >> F2FS_BLKSIZE_BITS;// 2^12 = 4096B = 4KB
    55e6:	c1 ea 0c             	shr    $0xc,%edx
		start %= F2FS_IO_SIZE(sbi);
    55e9:	8d 5e ff             	lea    -0x1(%rsi),%ebx
		if (start == 0)
    55ec:	21 d3                	and    %edx,%ebx
    55ee:	0f 84 a9 f9 ff ff    	je     4f9d <f2fs_mpage_readpages+0x2dd>
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    55f4:	39 f3                	cmp    %esi,%ebx
    55f6:	0f 83 67 02 00 00    	jae    5863 <f2fs_mpage_readpages+0xba3>
    55fc:	41 be 01 00 00 00    	mov    $0x1,%r14d
					mempool_alloc(sbi->write_io_dummy,
    5602:	49 8b bd 70 01 00 00 	mov    0x170(%r13),%rdi
    5609:	be 00 88 60 00       	mov    $0x608800,%esi
    560e:	e8 00 00 00 00       	callq  5613 <f2fs_mpage_readpages+0x953>
    5613:	49 89 c4             	mov    %rax,%r12
			f2fs_bug_on(sbi, !page);
    5616:	48 85 c0             	test   %rax,%rax
    5619:	0f 84 56 01 00 00    	je     5775 <f2fs_mpage_readpages+0xab5>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    561f:	f0 41 80 4c 24 01 10 	lock orb $0x10,0x1(%r12)
			set_page_private(page, (unsigned long) DUMMY_WRITTEN_PAGE);
    5626:	49 c7 44 24 28 fe ff 	movq   $0xfffffffffffffffe,0x28(%r12)
    562d:	ff ff 
	might_sleep();
    562f:	e8 00 00 00 00       	callq  5634 <f2fs_mpage_readpages+0x974>
    5634:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
    5639:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    563d:	83 e2 01             	and    $0x1,%edx
    5640:	49 0f 44 c4          	cmove  %r12,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    5644:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    564a:	0f 82 18 01 00 00    	jb     5768 <f2fs_mpage_readpages+0xaa8>
			if (bio_add_page(bio, page, PAGE_SIZE, 0) < PAGE_SIZE)
    5650:	31 c9                	xor    %ecx,%ecx
    5652:	ba 00 10 00 00       	mov    $0x1000,%edx
    5657:	4c 89 e6             	mov    %r12,%rsi
    565a:	4c 89 ff             	mov    %r15,%rdi
    565d:	e8 00 00 00 00       	callq  5662 <f2fs_mpage_readpages+0x9a2>
    5662:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    5667:	77 08                	ja     5671 <f2fs_mpage_readpages+0x9b1>
				f2fs_bug_on(sbi, 1);
    5669:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    566b:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
		for (; start < F2FS_IO_SIZE(sbi); start++) {
    5671:	41 8b 8d f4 04 00 00 	mov    0x4f4(%r13),%ecx
    5678:	44 89 f0             	mov    %r14d,%eax
    567b:	83 c3 01             	add    $0x1,%ebx
    567e:	d3 e0                	shl    %cl,%eax
    5680:	39 c3                	cmp    %eax,%ebx
    5682:	0f 82 7a ff ff ff    	jb     5602 <f2fs_mpage_readpages+0x942>
    5688:	e9 01 f9 ff ff       	jmpq   4f8e <f2fs_mpage_readpages+0x2ce>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    568d:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5694 <f2fs_mpage_readpages+0x9d4>
    5694:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    5696:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 569e <f2fs_mpage_readpages+0x9de>
    569d:	00 
    569e:	0f 83 fe f8 ff ff    	jae    4fa2 <f2fs_mpage_readpages+0x2e2>
    56a4:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 56ab <f2fs_mpage_readpages+0x9eb>
    56ab:	48 85 db             	test   %rbx,%rbx
    56ae:	0f 84 ea fe ff ff    	je     559e <f2fs_mpage_readpages+0x8de>
    56b4:	48 8b 03             	mov    (%rbx),%rax
    56b7:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    56bb:	48 83 c3 18          	add    $0x18,%rbx
    56bf:	4c 89 f9             	mov    %r15,%rcx
    56c2:	31 d2                	xor    %edx,%edx
    56c4:	4c 89 e6             	mov    %r12,%rsi
    56c7:	e8 00 00 00 00       	callq  56cc <f2fs_mpage_readpages+0xa0c>
    56cc:	48 8b 03             	mov    (%rbx),%rax
    56cf:	48 85 c0             	test   %rax,%rax
    56d2:	75 e3                	jne    56b7 <f2fs_mpage_readpages+0x9f7>
	preempt_enable_notrace();
    56d4:	e9 c9 f8 ff ff       	jmpq   4fa2 <f2fs_mpage_readpages+0x2e2>
					!__same_bdev(F2FS_I_SB(inode), block_nr, bio))) {
    56d9:	8b 75 88             	mov    -0x78(%rbp),%esi
    56dc:	49 8d 4f 1b          	lea    0x1b(%r15),%rcx
    56e0:	49 8d 57 08          	lea    0x8(%r15),%rdx
    56e4:	4c 89 e7             	mov    %r12,%rdi
    56e7:	e8 24 bd ff ff       	callq  1410 <__same_bdev.isra.0>
		if (bio && (last_block_in_bio != block_nr - 1 ||
    56ec:	84 c0                	test   %al,%al
    56ee:	0f 84 7f f9 ff ff    	je     5073 <f2fs_mpage_readpages+0x3b3>
	return (struct f2fs_sm_info *)(sbi->sm_info);
    56f4:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
    56fb:	48 8b 43 68          	mov    0x68(%rbx),%rax
			unsigned int main_segno = GET_SEGNO_FROM_SEG0(sbi, sbi->raw_super->main_blkaddr);
    56ff:	8b 8b 20 04 00 00    	mov    0x420(%rbx),%ecx
			unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, last_block_in_bio);
    5705:	48 85 c0             	test   %rax,%rax
    5708:	74 47                	je     5751 <f2fs_mpage_readpages+0xa91>
    570a:	8b 40 48             	mov    0x48(%rax),%eax
			unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, block_nr);
    570d:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
			unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, last_block_in_bio);
    5711:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
			unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, block_nr);
    5718:	48 29 c3             	sub    %rax,%rbx
			unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, last_block_in_bio);
    571b:	48 29 c2             	sub    %rax,%rdx
			unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, block_nr);
    571e:	48 89 d8             	mov    %rbx,%rax
			unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, last_block_in_bio);
    5721:	48 d3 ea             	shr    %cl,%rdx
			unsigned int new_segno = GET_SEGNO_FROM_SEG0(sbi, block_nr);
    5724:	48 d3 e8             	shr    %cl,%rax
			if (old_segno != new_segno) {
    5727:	39 c2                	cmp    %eax,%edx
    5729:	0f 85 44 f9 ff ff    	jne    5073 <f2fs_mpage_readpages+0x3b3>
    572f:	e9 ab fb ff ff       	jmpq   52df <f2fs_mpage_readpages+0x61f>
	BUG_ON(pages && !list_empty(pages));
    5734:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
    5739:	0f 84 78 f8 ff ff    	je     4fb7 <f2fs_mpage_readpages+0x2f7>
    573f:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
    5743:	48 8b 06             	mov    (%rsi),%rax
    5746:	48 39 c6             	cmp    %rax,%rsi
    5749:	0f 84 68 f8 ff ff    	je     4fb7 <f2fs_mpage_readpages+0x2f7>
    574f:	0f 0b                	ud2    
			unsigned int old_segno = GET_SEGNO_FROM_SEG0(sbi, last_block_in_bio);
    5751:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
    5758:	48 8b 40 10          	mov    0x10(%rax),%rax
    575c:	eb ac                	jmp    570a <f2fs_mpage_readpages+0xa4a>
    575e:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5763:	e9 11 fb ff ff       	jmpq   5279 <f2fs_mpage_readpages+0x5b9>
		__lock_page(page);
    5768:	4c 89 e7             	mov    %r12,%rdi
    576b:	e8 00 00 00 00       	callq  5770 <f2fs_mpage_readpages+0xab0>
    5770:	e9 db fe ff ff       	jmpq   5650 <f2fs_mpage_readpages+0x990>
			f2fs_bug_on(sbi, !page);
    5775:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    5777:	f0 41 80 4d 48 04    	lock orb $0x4,0x48(%r13)
}
    577d:	e9 9d fe ff ff       	jmpq   561f <f2fs_mpage_readpages+0x95f>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_read_bio,
    5782:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5789 <f2fs_mpage_readpages+0xac9>
    5789:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    578b:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 5793 <f2fs_mpage_readpages+0xad3>
    5792:	00 
    5793:	0f 83 e0 fa ff ff    	jae    5279 <f2fs_mpage_readpages+0x5b9>
    5799:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 57a0 <f2fs_mpage_readpages+0xae0>
    57a0:	48 85 db             	test   %rbx,%rbx
    57a3:	74 30                	je     57d5 <f2fs_mpage_readpages+0xb15>
    57a5:	4c 89 65 88          	mov    %r12,-0x78(%rbp)
    57a9:	48 8b 03             	mov    (%rbx),%rax
    57ac:	49 89 dc             	mov    %rbx,%r12
    57af:	4c 89 c3             	mov    %r8,%rbx
    57b2:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    57b7:	49 83 c4 18          	add    $0x18,%r12
    57bb:	4c 89 f9             	mov    %r15,%rcx
    57be:	31 d2                	xor    %edx,%edx
    57c0:	48 89 de             	mov    %rbx,%rsi
    57c3:	e8 00 00 00 00       	callq  57c8 <f2fs_mpage_readpages+0xb08>
    57c8:	49 8b 04 24          	mov    (%r12),%rax
    57cc:	48 85 c0             	test   %rax,%rax
    57cf:	75 e1                	jne    57b2 <f2fs_mpage_readpages+0xaf2>
    57d1:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
}
    57d5:	e9 9f fa ff ff       	jmpq   5279 <f2fs_mpage_readpages+0x5b9>
DEFINE_EVENT_CONDITION(f2fs__bio, f2fs_submit_write_bio,
    57da:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 57e1 <f2fs_mpage_readpages+0xb21>
    57e1:	89 c0                	mov    %eax,%eax
    57e3:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 57eb <f2fs_mpage_readpages+0xb2b>
    57ea:	00 
    57eb:	0f 83 88 fa ff ff    	jae    5279 <f2fs_mpage_readpages+0x5b9>
    57f1:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 57f8 <f2fs_mpage_readpages+0xb38>
    57f8:	48 85 db             	test   %rbx,%rbx
    57fb:	74 d8                	je     57d5 <f2fs_mpage_readpages+0xb15>
    57fd:	4c 89 65 88          	mov    %r12,-0x78(%rbp)
    5801:	48 8b 03             	mov    (%rbx),%rax
    5804:	49 89 dc             	mov    %rbx,%r12
    5807:	4c 89 c3             	mov    %r8,%rbx
    580a:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    580f:	49 83 c4 18          	add    $0x18,%r12
    5813:	4c 89 f9             	mov    %r15,%rcx
    5816:	31 d2                	xor    %edx,%edx
    5818:	48 89 de             	mov    %rbx,%rsi
    581b:	e8 00 00 00 00       	callq  5820 <f2fs_mpage_readpages+0xb60>
    5820:	49 8b 04 24          	mov    (%r12),%rax
    5824:	48 85 c0             	test   %rax,%rax
    5827:	75 e1                	jne    580a <f2fs_mpage_readpages+0xb4a>
    5829:	eb a6                	jmp    57d1 <f2fs_mpage_readpages+0xb11>
    582b:	4c 89 ef             	mov    %r13,%rdi
    582e:	e8 00 00 00 00       	callq  5833 <f2fs_mpage_readpages+0xb73>
    5833:	e9 ed f9 ff ff       	jmpq   5225 <f2fs_mpage_readpages+0x565>
    5838:	0f 0b                	ud2    
		asm volatile(LOCK_PREFIX "orb %1,%0"
    583a:	f0 41 80 4c 24 48 04 	lock orb $0x4,0x48(%r12)
    5841:	e9 b1 f9 ff ff       	jmpq   51f7 <f2fs_mpage_readpages+0x537>
    5846:	48 8b 5d 98          	mov    -0x68(%rbp),%rbx
    584a:	48 8b 03             	mov    (%rbx),%rax
	BUG_ON(pages && !list_empty(pages));
    584d:	48 39 c3             	cmp    %rax,%rbx
    5850:	0f 84 ac f6 ff ff    	je     4f02 <f2fs_mpage_readpages+0x242>
    5856:	e9 f4 fe ff ff       	jmpq   574f <f2fs_mpage_readpages+0xa8f>
	if (is_read_io(bio_op(bio)))
    585b:	49 89 c0             	mov    %rax,%r8
    585e:	e9 d8 fb ff ff       	jmpq   543b <f2fs_mpage_readpages+0x77b>
    5863:	49 89 c4             	mov    %rax,%r12
    5866:	e9 32 f7 ff ff       	jmpq   4f9d <f2fs_mpage_readpages+0x2dd>
}
    586b:	e8 00 00 00 00       	callq  5870 <f2fs_read_data_pages>

0000000000005870 <f2fs_read_data_pages>:
								struct list_head *pages, unsigned nr_pages) {
    5870:	f3 0f 1e fa          	endbr64 
    5874:	e8 00 00 00 00       	callq  5879 <f2fs_read_data_pages+0x9>
    5879:	55                   	push   %rbp
    587a:	48 89 e5             	mov    %rsp,%rbp
    587d:	41 57                	push   %r15
    587f:	41 89 cf             	mov    %ecx,%r15d
    5882:	41 56                	push   %r14
    5884:	41 55                	push   %r13
    5886:	41 54                	push   %r12
    5888:	49 89 f4             	mov    %rsi,%r12
    588b:	53                   	push   %rbx
    588c:	48 83 ec 08          	sub    $0x8,%rsp
    5890:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
	struct inode *inode = mapping->host;
    5894:	4c 8b 2e             	mov    (%rsi),%r13
    5897:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    589c:	49 8b 95 78 02 00 00 	mov    0x278(%r13),%rdx
		return 0;
    58a3:	31 c0                	xor    %eax,%eax
	if (f2fs_has_inline_data(inode))
    58a5:	80 e6 04             	and    $0x4,%dh
    58a8:	75 11                	jne    58bb <f2fs_read_data_pages+0x4b>
	return f2fs_mpage_readpages(mapping, pages, NULL, nr_pages);
    58aa:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    58ae:	44 89 f9             	mov    %r15d,%ecx
    58b1:	31 d2                	xor    %edx,%edx
    58b3:	4c 89 e7             	mov    %r12,%rdi
    58b6:	e8 05 f4 ff ff       	callq  4cc0 <f2fs_mpage_readpages>
}
    58bb:	48 83 c4 08          	add    $0x8,%rsp
    58bf:	5b                   	pop    %rbx
    58c0:	41 5c                	pop    %r12
    58c2:	41 5d                	pop    %r13
    58c4:	41 5e                	pop    %r14
    58c6:	41 5f                	pop    %r15
    58c8:	5d                   	pop    %rbp
    58c9:	c3                   	retq   
		__entry->for_reclaim,
		__entry->range_cyclic,
		__entry->for_sync)
);

TRACE_EVENT(f2fs_readpages,
    58ca:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 58d1 <f2fs_read_data_pages+0x61>
    58d1:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    58d3:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 58db <f2fs_read_data_pages+0x6b>
    58da:	00 
    58db:	73 bf                	jae    589c <f2fs_read_data_pages+0x2c>
	struct page *page = list_last_entry(pages, struct page, lru);
    58dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    58e1:	4c 8b 70 08          	mov    0x8(%rax),%r14
    58e5:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 58ec <f2fs_read_data_pages+0x7c>
    58ec:	48 85 db             	test   %rbx,%rbx
    58ef:	74 25                	je     5916 <f2fs_read_data_pages+0xa6>
    58f1:	48 8b 03             	mov    (%rbx),%rax
    58f4:	49 83 ee 08          	sub    $0x8,%r14
    58f8:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    58fc:	48 83 c3 18          	add    $0x18,%rbx
    5900:	44 89 f9             	mov    %r15d,%ecx
    5903:	4c 89 f2             	mov    %r14,%rdx
    5906:	4c 89 ee             	mov    %r13,%rsi
    5909:	e8 00 00 00 00       	callq  590e <f2fs_read_data_pages+0x9e>
    590e:	48 8b 03             	mov    (%rbx),%rax
    5911:	48 85 c0             	test   %rax,%rax
    5914:	75 e2                	jne    58f8 <f2fs_read_data_pages+0x88>
    5916:	eb 84                	jmp    589c <f2fs_read_data_pages+0x2c>
    5918:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    591f:	00 

0000000000005920 <f2fs_read_data_page>:
static int f2fs_read_data_page(struct file *file, struct page *page) {
    5920:	f3 0f 1e fa          	endbr64 
    5924:	e8 00 00 00 00       	callq  5929 <f2fs_read_data_page+0x9>
    5929:	55                   	push   %rbp
    592a:	48 89 e5             	mov    %rsp,%rbp
    592d:	41 55                	push   %r13
    592f:	41 54                	push   %r12
    5931:	49 89 f4             	mov    %rsi,%r12
    5934:	53                   	push   %rbx
	struct inode *inode = page->mapping->host;
    5935:	48 8b 46 18          	mov    0x18(%rsi),%rax
    5939:	4c 8b 28             	mov    (%rax),%r13
    593c:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    5941:	49 8b 85 78 02 00 00 	mov    0x278(%r13),%rax
	if (f2fs_has_inline_data(inode))
    5948:	f6 c4 04             	test   $0x4,%ah
    594b:	74 17                	je     5964 <f2fs_read_data_page+0x44>
		ret = f2fs_read_inline_data(inode, page);
    594d:	4c 89 e6             	mov    %r12,%rsi
    5950:	4c 89 ef             	mov    %r13,%rdi
    5953:	e8 00 00 00 00       	callq  5958 <f2fs_read_data_page+0x38>
	if (ret == -EAGAIN)
    5958:	83 f8 f5             	cmp    $0xfffffff5,%eax
    595b:	74 07                	je     5964 <f2fs_read_data_page+0x44>
}
    595d:	5b                   	pop    %rbx
    595e:	41 5c                	pop    %r12
    5960:	41 5d                	pop    %r13
    5962:	5d                   	pop    %rbp
    5963:	c3                   	retq   
		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1);
    5964:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
    5969:	4c 89 e2             	mov    %r12,%rdx
    596c:	b9 01 00 00 00       	mov    $0x1,%ecx
    5971:	31 f6                	xor    %esi,%esi
    5973:	e8 48 f3 ff ff       	callq  4cc0 <f2fs_mpage_readpages>
}
    5978:	5b                   	pop    %rbx
    5979:	41 5c                	pop    %r12
    597b:	41 5d                	pop    %r13
    597d:	5d                   	pop    %rbp
    597e:	c3                   	retq   
DEFINE_EVENT(f2fs__page, f2fs_readpage,
    597f:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 5986 <f2fs_read_data_page+0x66>
    5986:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    5988:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 5990 <f2fs_read_data_page+0x70>
    598f:	00 
    5990:	73 af                	jae    5941 <f2fs_read_data_page+0x21>
    5992:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 5999 <f2fs_read_data_page+0x79>
    5999:	48 85 db             	test   %rbx,%rbx
    599c:	74 1d                	je     59bb <f2fs_read_data_page+0x9b>
    599e:	48 8b 03             	mov    (%rbx),%rax
    59a1:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    59a5:	48 83 c3 18          	add    $0x18,%rbx
    59a9:	31 d2                	xor    %edx,%edx
    59ab:	4c 89 e6             	mov    %r12,%rsi
    59ae:	e8 00 00 00 00       	callq  59b3 <f2fs_read_data_page+0x93>
    59b3:	48 8b 03             	mov    (%rbx),%rax
    59b6:	48 85 c0             	test   %rax,%rax
    59b9:	75 e6                	jne    59a1 <f2fs_read_data_page+0x81>
    59bb:	eb 84                	jmp    5941 <f2fs_read_data_page+0x21>
    59bd:	0f 1f 00             	nopl   (%rax)

00000000000059c0 <f2fs_overwrite_io>:
bool f2fs_overwrite_io(struct inode *inode, loff_t pos, size_t len) {
    59c0:	f3 0f 1e fa          	endbr64 
    59c4:	e8 00 00 00 00       	callq  59c9 <f2fs_overwrite_io+0x9>
    59c9:	55                   	push   %rbp
	if (pos + len > i_size_read(inode))
    59ca:	48 01 f2             	add    %rsi,%rdx
bool f2fs_overwrite_io(struct inode *inode, loff_t pos, size_t len) {
    59cd:	48 89 e5             	mov    %rsp,%rbp
    59d0:	41 54                	push   %r12
    59d2:	53                   	push   %rbx
    59d3:	48 83 ec 30          	sub    $0x30,%rsp
    59d7:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    59de:	00 00 
    59e0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    59e4:	31 c0                	xor    %eax,%eax
	if (pos + len > i_size_read(inode))
    59e6:	48 3b 57 50          	cmp    0x50(%rdi),%rdx
    59ea:	77 62                	ja     5a4e <f2fs_overwrite_io+0x8e>
	last_lblk = F2FS_BLK_ALIGN(pos + len);
    59ec:	48 81 c2 ff 0f 00 00 	add    $0xfff,%rdx
	map.m_lblk = F2FS_BYTES_TO_BLK(pos);
    59f3:	48 c1 fe 0c          	sar    $0xc,%rsi
	map.m_next_pgofs = NULL;
    59f7:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    59fe:	00 
    59ff:	49 89 fc             	mov    %rdi,%r12
	last_lblk = F2FS_BLK_ALIGN(pos + len);
    5a02:	48 c1 ea 0c          	shr    $0xc,%rdx
	map.m_lblk = F2FS_BYTES_TO_BLK(pos);
    5a06:	89 75 c4             	mov    %esi,-0x3c(%rbp)
    5a09:	89 f0                	mov    %esi,%eax
	map.m_next_extent = NULL;
    5a0b:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    5a12:	00 
	last_lblk = F2FS_BLK_ALIGN(pos + len);
    5a13:	89 d3                	mov    %edx,%ebx
	map.m_seg_type = NO_CHECK_TYPE;
    5a15:	c7 45 e0 06 00 00 00 	movl   $0x6,-0x20(%rbp)
	while (map.m_lblk < last_lblk) {
    5a1c:	39 d6                	cmp    %edx,%esi
    5a1e:	72 13                	jb     5a33 <f2fs_overwrite_io+0x73>
    5a20:	eb 46                	jmp    5a68 <f2fs_overwrite_io+0xa8>
		if (err || map.m_len == 0)
    5a22:	8b 45 c8             	mov    -0x38(%rbp),%eax
    5a25:	85 c0                	test   %eax,%eax
    5a27:	74 25                	je     5a4e <f2fs_overwrite_io+0x8e>
		map.m_lblk += map.m_len;
    5a29:	03 45 c4             	add    -0x3c(%rbp),%eax
    5a2c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	while (map.m_lblk < last_lblk) {
    5a2f:	39 d8                	cmp    %ebx,%eax
    5a31:	73 35                	jae    5a68 <f2fs_overwrite_io+0xa8>
		map.m_len = last_lblk - map.m_lblk;
    5a33:	89 d9                	mov    %ebx,%ecx
		err = f2fs_map_blocks(inode, &map, 0, F2FS_GET_BLOCK_DEFAULT);
    5a35:	31 d2                	xor    %edx,%edx
    5a37:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    5a3b:	4c 89 e7             	mov    %r12,%rdi
		map.m_len = last_lblk - map.m_lblk;
    5a3e:	29 c1                	sub    %eax,%ecx
    5a40:	89 4d c8             	mov    %ecx,-0x38(%rbp)
		err = f2fs_map_blocks(inode, &map, 0, F2FS_GET_BLOCK_DEFAULT);
    5a43:	31 c9                	xor    %ecx,%ecx
    5a45:	e8 00 00 00 00       	callq  5a4a <f2fs_overwrite_io+0x8a>
		if (err || map.m_len == 0)
    5a4a:	85 c0                	test   %eax,%eax
    5a4c:	74 d4                	je     5a22 <f2fs_overwrite_io+0x62>
		return false;
    5a4e:	31 c0                	xor    %eax,%eax
}
    5a50:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    5a54:	65 48 33 3c 25 28 00 	xor    %gs:0x28,%rdi
    5a5b:	00 00 
    5a5d:	75 10                	jne    5a6f <f2fs_overwrite_io+0xaf>
    5a5f:	48 83 c4 30          	add    $0x30,%rsp
    5a63:	5b                   	pop    %rbx
    5a64:	41 5c                	pop    %r12
    5a66:	5d                   	pop    %rbp
    5a67:	c3                   	retq   
	return true;
    5a68:	b8 01 00 00 00       	mov    $0x1,%eax
    5a6d:	eb e1                	jmp    5a50 <f2fs_overwrite_io+0x90>
}
    5a6f:	e8 00 00 00 00       	callq  5a74 <f2fs_overwrite_io+0xb4>
    5a74:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    5a7b:	00 00 00 00 
    5a7f:	90                   	nop

0000000000005a80 <f2fs_fiemap>:
				u64 start, u64 len) {
    5a80:	f3 0f 1e fa          	endbr64 
    5a84:	e8 00 00 00 00       	callq  5a89 <f2fs_fiemap+0x9>
    5a89:	55                   	push   %rbp
    5a8a:	48 89 e5             	mov    %rsp,%rbp
    5a8d:	41 57                	push   %r15
    5a8f:	41 56                	push   %r14
    5a91:	49 89 fe             	mov    %rdi,%r14
    5a94:	41 55                	push   %r13
    5a96:	41 54                	push   %r12
    5a98:	53                   	push   %rbx
    5a99:	48 89 d3             	mov    %rdx,%rbx
    5a9c:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
    5aa3:	48 89 b5 38 ff ff ff 	mov    %rsi,-0xc8(%rbp)
    5aaa:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
    5ab1:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    5ab8:	00 00 
    5aba:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5abe:	31 c0                	xor    %eax,%eax
	if (fieinfo->fi_flags & FIEMAP_FLAG_CACHE) {
    5ac0:	f6 06 04             	testb  $0x4,(%rsi)
    5ac3:	74 0f                	je     5ad4 <f2fs_fiemap+0x54>
		ret = f2fs_precache_extents(inode);
    5ac5:	e8 00 00 00 00       	callq  5aca <f2fs_fiemap+0x4a>
    5aca:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
		if (ret)
    5ad0:	85 c0                	test   %eax,%eax
    5ad2:	75 1b                	jne    5aef <f2fs_fiemap+0x6f>
	ret = fiemap_check_flags(fieinfo, FIEMAP_FLAG_SYNC | FIEMAP_FLAG_XATTR);
    5ad4:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
    5adb:	be 03 00 00 00       	mov    $0x3,%esi
    5ae0:	e8 00 00 00 00       	callq  5ae5 <f2fs_fiemap+0x65>
    5ae5:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
	if (ret)
    5aeb:	85 c0                	test   %eax,%eax
    5aed:	74 28                	je     5b17 <f2fs_fiemap+0x97>
}
    5aef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    5af3:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    5afa:	00 00 
    5afc:	0f 85 18 05 00 00    	jne    601a <f2fs_fiemap+0x59a>
    5b02:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
    5b08:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    5b0c:	5b                   	pop    %rbx
    5b0d:	41 5c                	pop    %r12
    5b0f:	41 5d                	pop    %r13
    5b11:	41 5e                	pop    %r14
    5b13:	41 5f                	pop    %r15
    5b15:	5d                   	pop    %rbp
    5b16:	c3                   	retq   
	down_write(&inode->i_rwsem);
    5b17:	49 8d 86 a8 00 00 00 	lea    0xa8(%r14),%rax
    5b1e:	48 89 c7             	mov    %rax,%rdi
    5b21:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
    5b28:	e8 00 00 00 00       	callq  5b2d <f2fs_fiemap+0xad>
	if (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {
    5b2d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    5b34:	f6 00 02             	testb  $0x2,(%rax)
    5b37:	0f 85 fe 02 00 00    	jne    5e3b <f2fs_fiemap+0x3bb>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    5b3d:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (f2fs_has_inline_data(inode)) {
    5b44:	f6 c4 04             	test   $0x4,%ah
    5b47:	0f 85 cb 02 00 00    	jne    5e18 <f2fs_fiemap+0x398>
	return (offset >> inode->i_blkbits);
    5b4d:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
	return (blk << inode->i_blkbits);
    5b54:	b8 01 00 00 00       	mov    $0x1,%eax
	return (offset >> inode->i_blkbits);
    5b59:	41 8b 8e 90 00 00 00 	mov    0x90(%r14),%ecx
	u64 logical = 0, phys = 0, size = 0;
    5b60:	48 c7 85 48 ff ff ff 	movq   $0x0,-0xb8(%rbp)
    5b67:	00 00 00 00 
    5b6b:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
    5b72:	00 00 00 00 
	return (offset >> inode->i_blkbits);
    5b76:	49 89 df             	mov    %rbx,%r15
    5b79:	4c 8d a5 68 ff ff ff 	lea    -0x98(%rbp),%r12
    5b80:	48 89 fa             	mov    %rdi,%rdx
	return (blk << inode->i_blkbits);
    5b83:	48 d3 e0             	shl    %cl,%rax
	return (offset >> inode->i_blkbits);
    5b86:	48 d3 fa             	sar    %cl,%rdx
	return (blk << inode->i_blkbits);
    5b89:	48 85 d2             	test   %rdx,%rdx
    5b8c:	48 0f 45 c7          	cmovne %rdi,%rax
	return (offset >> inode->i_blkbits);
    5b90:	49 d3 ff             	sar    %cl,%r15
	u64 logical = 0, phys = 0, size = 0;
    5b93:	45 31 ed             	xor    %r13d,%r13d
	return (blk << inode->i_blkbits);
    5b96:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
	last_blk = logical_to_blk(inode, start + len - 1);
    5b9d:	48 8d 44 03 ff       	lea    -0x1(%rbx,%rax,1),%rax
	u32 flags = 0;
    5ba2:	31 db                	xor    %ebx,%ebx
	return (offset >> inode->i_blkbits);
    5ba4:	48 d3 f8             	sar    %cl,%rax
    5ba7:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
    5bae:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    5bb5:	00 00 
    5bb7:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    5bbe:	31 c0                	xor    %eax,%eax
    5bc0:	b9 0d 00 00 00       	mov    $0xd,%ecx
    5bc5:	4c 89 e7             	mov    %r12,%rdi
	return __get_data_block(inode, iblock, bh_result, create,
    5bc8:	4c 89 e2             	mov    %r12,%rdx
    5bcb:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    5bce:	6a 06                	pushq  $0x6
	map_bh.b_size = len;
    5bd0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
	return __get_data_block(inode, iblock, bh_result, create,
    5bd7:	4c 89 fe             	mov    %r15,%rsi
    5bda:	4c 8d 8d 60 ff ff ff 	lea    -0xa0(%rbp),%r9
    5be1:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    5be7:	4c 89 f7             	mov    %r14,%rdi
	map_bh.b_size = len;
    5bea:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	return __get_data_block(inode, iblock, bh_result, create,
    5bee:	e8 1d ef ff ff       	callq  4b10 <__get_data_block>
	if (ret)
    5bf3:	5a                   	pop    %rdx
    5bf4:	85 c0                	test   %eax,%eax
    5bf6:	0f 85 fb 01 00 00    	jne    5df7 <f2fs_fiemap+0x377>
    5bfc:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
	if (!buffer_mapped(&map_bh)) {
    5c03:	83 e2 20             	and    $0x20,%edx
    5c06:	75 35                	jne    5c3d <f2fs_fiemap+0x1bd>
	return sb->s_fs_info;
    5c08:	49 8b 56 28          	mov    0x28(%r14),%rdx
		start_blk = next_pgofs;
    5c0c:	4c 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%r15
	return (blk << inode->i_blkbits);
    5c13:	41 8b 8e 90 00 00 00 	mov    0x90(%r14),%ecx
															  F2FS_I_SB(inode)->max_file_blocks))
    5c1a:	48 8b 92 08 04 00 00 	mov    0x408(%rdx),%rdx
	return (blk << inode->i_blkbits);
    5c21:	4c 89 fe             	mov    %r15,%rsi
    5c24:	48 d3 e6             	shl    %cl,%rsi
    5c27:	48 8b 92 40 04 00 00 	mov    0x440(%rdx),%rdx
    5c2e:	48 d3 e2             	shl    %cl,%rdx
		if (blk_to_logical(inode, start_blk) < blk_to_logical(inode,
    5c31:	48 39 f2             	cmp    %rsi,%rdx
    5c34:	0f 8f 95 00 00 00    	jg     5ccf <f2fs_fiemap+0x24f>
		flags |= FIEMAP_EXTENT_LAST;
    5c3a:	83 cb 01             	or     $0x1,%ebx
	if (size) {
    5c3d:	31 d2                	xor    %edx,%edx
    5c3f:	4d 85 ed             	test   %r13,%r13
    5c42:	74 35                	je     5c79 <f2fs_fiemap+0x1f9>
			flags |= FIEMAP_EXTENT_DATA_ENCRYPTED;
    5c44:	41 89 d8             	mov    %ebx,%r8d
		ret = fiemap_fill_next_extent(fieinfo, logical,
    5c47:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
    5c4e:	4c 89 e9             	mov    %r13,%rcx
    5c51:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
			flags |= FIEMAP_EXTENT_DATA_ENCRYPTED;
    5c58:	41 80 c8 80          	or     $0x80,%r8b
    5c5c:	41 f6 86 60 02 00 00 	testb  $0x4,0x260(%r14)
    5c63:	04 
		ret = fiemap_fill_next_extent(fieinfo, logical,
    5c64:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
    5c6b:	44 0f 44 c3          	cmove  %ebx,%r8d
    5c6f:	e8 00 00 00 00       	callq  5c74 <f2fs_fiemap+0x1f4>
    5c74:	85 c0                	test   %eax,%eax
    5c76:	0f 95 c2             	setne  %dl
	if (start_blk > last_blk || ret)
    5c79:	4c 3b bd 30 ff ff ff 	cmp    -0xd0(%rbp),%r15
    5c80:	0f 87 71 01 00 00    	ja     5df7 <f2fs_fiemap+0x377>
    5c86:	84 d2                	test   %dl,%dl
    5c88:	0f 85 69 01 00 00    	jne    5df7 <f2fs_fiemap+0x377>
	return (blk << inode->i_blkbits);
    5c8e:	41 8b 8e 90 00 00 00 	mov    0x90(%r14),%ecx
    5c95:	4c 89 f8             	mov    %r15,%rax
	size = map_bh.b_size;
    5c98:	4c 8b 6d 88          	mov    -0x78(%rbp),%r13
		flags = FIEMAP_EXTENT_UNWRITTEN;
    5c9c:	31 db                	xor    %ebx,%ebx
	return (blk << inode->i_blkbits);
    5c9e:	48 d3 e0             	shl    %cl,%rax
    5ca1:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    5ca8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
    5cac:	48 d3 e0             	shl    %cl,%rax
    5caf:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    5cb6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
		flags = FIEMAP_EXTENT_UNWRITTEN;
    5cbd:	f6 c4 10             	test   $0x10,%ah
	return (offset >> inode->i_blkbits);
    5cc0:	4c 89 e8             	mov    %r13,%rax
		flags = FIEMAP_EXTENT_UNWRITTEN;
    5cc3:	0f 95 c3             	setne  %bl
	return (offset >> inode->i_blkbits);
    5cc6:	48 d3 f8             	sar    %cl,%rax
		flags = FIEMAP_EXTENT_UNWRITTEN;
    5cc9:	c1 e3 0b             	shl    $0xb,%ebx
	start_blk += logical_to_blk(inode, size);
    5ccc:	49 01 c7             	add    %rax,%r15
	cond_resched();
    5ccf:	e8 00 00 00 00       	callq  5cd4 <f2fs_fiemap+0x254>
    5cd4:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    5cdb:	48 8b 00             	mov    (%rax),%rax
	return unlikely(sigismember(&p->pending.signal, SIGKILL));
}

static inline int fatal_signal_pending(struct task_struct *p)
{
	return signal_pending(p) && __fatal_signal_pending(p);
    5cde:	a8 04                	test   $0x4,%al
    5ce0:	0f 84 d8 fe ff ff    	je     5bbe <f2fs_fiemap+0x13e>
    5ce6:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    5ced:	f6 80 b9 0a 00 00 01 	testb  $0x1,0xab9(%rax)
    5cf4:	0f 84 c4 fe ff ff    	je     5bbe <f2fs_fiemap+0x13e>
		ret = -EINTR;
    5cfa:	c7 85 2c ff ff ff fc 	movl   $0xfffffffc,-0xd4(%rbp)
    5d01:	ff ff ff 
    5d04:	e9 fe 00 00 00       	jmpq   5e07 <f2fs_fiemap+0x387>
		err = fiemap_fill_next_extent(fieinfo, 0, phys, len, flags);
    5d09:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
    5d10:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
    5d17:	31 f6                	xor    %esi,%esi
    5d19:	4c 89 e2             	mov    %r12,%rdx
    5d1c:	41 b8 00 03 00 00    	mov    $0x300,%r8d
    5d22:	e8 00 00 00 00       	callq  5d27 <f2fs_fiemap+0x2a7>
		if (err || err == 1)
    5d27:	85 c0                	test   %eax,%eax
    5d29:	0f 85 c8 00 00 00    	jne    5df7 <f2fs_fiemap+0x377>
	return sbi->node_inode->i_mapping;
    5d2f:	48 8b 43 60          	mov    0x60(%rbx),%rax
		page = f2fs_grab_cache_page(NODE_MAPPING(sbi), xnid, false);
    5d33:	44 89 ee             	mov    %r13d,%esi
	return pagecache_get_page(mapping, offset,
    5d36:	ba 07 00 00 00       	mov    $0x7,%edx
    5d3b:	48 8b 78 30          	mov    0x30(%rax),%rdi
    5d3f:	8b 8f 84 00 00 00    	mov    0x84(%rdi),%ecx
    5d45:	e8 00 00 00 00       	callq  5d4a <f2fs_fiemap+0x2ca>
    5d4a:	49 89 c7             	mov    %rax,%r15
		if (!page)
    5d4d:	48 85 c0             	test   %rax,%rax
    5d50:	0f 84 c9 02 00 00    	je     601f <f2fs_fiemap+0x59f>
		f2fs_get_node_info(sbi, xnid, &ni);
    5d56:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
    5d5d:	44 89 ee             	mov    %r13d,%esi
    5d60:	48 89 df             	mov    %rbx,%rdi
    5d63:	e8 00 00 00 00       	callq  5d68 <f2fs_fiemap+0x2e8>
		phys = (__u64) blk_to_logical(inode, ni.blk_addr);
    5d68:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
	return (blk << inode->i_blkbits);
    5d6e:	41 8b 8e 90 00 00 00 	mov    0x90(%r14),%ecx
    5d75:	49 8b 57 08          	mov    0x8(%r15),%rdx
    5d79:	48 d3 e0             	shl    %cl,%rax
    5d7c:	49 89 c4             	mov    %rax,%r12
		len = inode->i_sb->s_blocksize;
    5d7f:	49 8b 46 28          	mov    0x28(%r14),%rax
    5d83:	48 8b 40 18          	mov    0x18(%rax),%rax
    5d87:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    5d8e:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    5d92:	83 e2 01             	and    $0x1,%edx
    5d95:	49 0f 44 c7          	cmove  %r15,%rax
    5d99:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    5d9c:	a8 01                	test   $0x1,%al
    5d9e:	0f 84 58 02 00 00    	je     5ffc <f2fs_fiemap+0x57c>
		unlock_page(page);
    5da4:	4c 89 ff             	mov    %r15,%rdi
    5da7:	e8 00 00 00 00       	callq  5dac <f2fs_fiemap+0x32c>
    5dac:	49 8b 47 08          	mov    0x8(%r15),%rax
    5db0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    5db4:	a8 01                	test   $0x1,%al
    5db6:	4c 0f 45 fa          	cmovne %rdx,%r15
    5dba:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5dbf:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
		flags = FIEMAP_EXTENT_LAST;
    5dc4:	41 b8 01 00 00 00    	mov    $0x1,%r8d
	if (put_page_testzero(page))
    5dca:	0f 84 f3 01 00 00    	je     5fc3 <f2fs_fiemap+0x543>
	if (phys)
    5dd0:	4d 85 e4             	test   %r12,%r12
    5dd3:	74 32                	je     5e07 <f2fs_fiemap+0x387>
		err = fiemap_fill_next_extent(fieinfo, 0, phys, len, flags);
    5dd5:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
    5ddc:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
    5de3:	4c 89 e2             	mov    %r12,%rdx
    5de6:	31 f6                	xor    %esi,%esi
    5de8:	e8 00 00 00 00       	callq  5ded <f2fs_fiemap+0x36d>
    5ded:	ba 00 00 00 00       	mov    $0x0,%edx
    5df2:	85 c0                	test   %eax,%eax
    5df4:	0f 4f c2             	cmovg  %edx,%eax
	if (ret == 1)
    5df7:	83 f8 01             	cmp    $0x1,%eax
    5dfa:	0f 44 85 2c ff ff ff 	cmove  -0xd4(%rbp),%eax
    5e01:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
	up_write(&inode->i_rwsem);
    5e07:	48 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%rdi
    5e0e:	e8 00 00 00 00       	callq  5e13 <f2fs_fiemap+0x393>
	return ret;
    5e13:	e9 d7 fc ff ff       	jmpq   5aef <f2fs_fiemap+0x6f>
		ret = f2fs_inline_data_fiemap(inode, fieinfo, start, len);
    5e18:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
    5e1f:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
    5e26:	48 89 da             	mov    %rbx,%rdx
    5e29:	4c 89 f7             	mov    %r14,%rdi
    5e2c:	e8 00 00 00 00       	callq  5e31 <f2fs_fiemap+0x3b1>
		if (ret != -EAGAIN)
    5e31:	83 f8 f5             	cmp    $0xfffffff5,%eax
    5e34:	75 c1                	jne    5df7 <f2fs_fiemap+0x377>
    5e36:	e9 12 fd ff ff       	jmpq   5b4d <f2fs_fiemap+0xcd>
	return sb->s_fs_info;
    5e3b:	49 8b 46 28          	mov    0x28(%r14),%rax
	nid_t xnid = F2FS_I(inode)->i_xattr_nid;
    5e3f:	45 8b ae c8 02 00 00 	mov    0x2c8(%r14),%r13d
    5e46:	48 8b 98 08 04 00 00 	mov    0x408(%rax),%rbx
    5e4d:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (f2fs_has_inline_xattr(inode)) {
    5e54:	f6 c4 02             	test   $0x2,%ah
    5e57:	75 0a                	jne    5e63 <f2fs_fiemap+0x3e3>
	if (xnid) {
    5e59:	45 85 ed             	test   %r13d,%r13d
    5e5c:	74 a9                	je     5e07 <f2fs_fiemap+0x387>
    5e5e:	e9 cc fe ff ff       	jmpq   5d2f <f2fs_fiemap+0x2af>
	return sbi->node_inode->i_mapping;
    5e63:	48 8b 43 60          	mov    0x60(%rbx),%rax
    5e67:	49 8b 76 40          	mov    0x40(%r14),%rsi
    5e6b:	ba 07 00 00 00       	mov    $0x7,%edx
    5e70:	48 8b 78 30          	mov    0x30(%rax),%rdi
    5e74:	8b 8f 84 00 00 00    	mov    0x84(%rdi),%ecx
    5e7a:	e8 00 00 00 00       	callq  5e7f <f2fs_fiemap+0x3ff>
    5e7f:	49 89 c7             	mov    %rax,%r15
		if (!page)
    5e82:	48 85 c0             	test   %rax,%rax
    5e85:	0f 84 94 01 00 00    	je     601f <f2fs_fiemap+0x59f>
		f2fs_get_node_info(sbi, inode->i_ino, &ni);
    5e8b:	41 8b 76 40          	mov    0x40(%r14),%esi
    5e8f:	48 8d 95 68 ff ff ff 	lea    -0x98(%rbp),%rdx
    5e96:	48 89 df             	mov    %rbx,%rdi
    5e99:	e8 00 00 00 00       	callq  5e9e <f2fs_fiemap+0x41e>
	return (blk << inode->i_blkbits);
    5e9e:	41 8b 8e 90 00 00 00 	mov    0x90(%r14),%ecx
		phys = (__u64) blk_to_logical(inode, ni.blk_addr);
    5ea5:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
	return F2FS_I(inode)->i_inline_xattr_size;
    5eab:	41 8b 96 10 04 00 00 	mov    0x410(%r14),%edx
	return (blk << inode->i_blkbits);
    5eb2:	48 d3 e0             	shl    %cl,%rax
    5eb5:	48 89 c1             	mov    %rax,%rcx
		offset = offsetof(struct f2fs_inode, i_addr) +
    5eb8:	b8 f5 03 00 00       	mov    $0x3f5,%eax
    5ebd:	29 d0                	sub    %edx,%eax
	return get_inline_xattr_addrs(inode) * sizeof(__le32);
    5ebf:	c1 e2 02             	shl    $0x2,%edx
    5ec2:	c1 e0 02             	shl    $0x2,%eax
		phys += offset;
    5ec5:	48 98                	cltq   
    5ec7:	4c 8d 24 01          	lea    (%rcx,%rax,1),%r12
		len = inline_xattr_size(inode);
    5ecb:	48 63 c2             	movslq %edx,%rax
    5ece:	49 8b 57 08          	mov    0x8(%r15),%rdx
    5ed2:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    5ed9:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    5edd:	83 e2 01             	and    $0x1,%edx
    5ee0:	49 0f 44 c7          	cmove  %r15,%rax
    5ee4:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    5ee7:	a8 01                	test   $0x1,%al
    5ee9:	0f 84 ef 00 00 00    	je     5fde <f2fs_fiemap+0x55e>
		unlock_page(page);
    5eef:	4c 89 ff             	mov    %r15,%rdi
    5ef2:	e8 00 00 00 00       	callq  5ef7 <f2fs_fiemap+0x477>
    5ef7:	49 8b 47 08          	mov    0x8(%r15),%rax
    5efb:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    5eff:	a8 01                	test   $0x1,%al
    5f01:	4c 0f 45 fa          	cmovne %rdx,%r15
    5f05:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5f0a:	f0 41 ff 4f 34       	lock decl 0x34(%r15)
    5f0f:	0f 84 a1 00 00 00    	je     5fb6 <f2fs_fiemap+0x536>
		if (!xnid)
    5f15:	45 85 ed             	test   %r13d,%r13d
    5f18:	0f 85 eb fd ff ff    	jne    5d09 <f2fs_fiemap+0x289>
		err = fiemap_fill_next_extent(fieinfo, 0, phys, len, flags);
    5f1e:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
    5f25:	48 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%rdi
    5f2c:	31 f6                	xor    %esi,%esi
    5f2e:	4c 89 e2             	mov    %r12,%rdx
    5f31:	41 b8 01 03 00 00    	mov    $0x301,%r8d
    5f37:	e8 00 00 00 00       	callq  5f3c <f2fs_fiemap+0x4bc>
		if (err || err == 1)
    5f3c:	85 c0                	test   %eax,%eax
    5f3e:	0f 85 b3 fe ff ff    	jne    5df7 <f2fs_fiemap+0x377>
			flags |= FIEMAP_EXTENT_LAST;
    5f44:	41 b8 01 03 00 00    	mov    $0x301,%r8d
    5f4a:	e9 81 fe ff ff       	jmpq   5dd0 <f2fs_fiemap+0x350>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    5f4f:	49 8b 07             	mov    (%r15),%rax
    5f52:	48 c1 e8 33          	shr    $0x33,%rax
    5f56:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    5f59:	83 f8 04             	cmp    $0x4,%eax
    5f5c:	75 ac                	jne    5f0a <f2fs_fiemap+0x48a>
	switch (page->pgmap->type) {
    5f5e:	49 8b 47 08          	mov    0x8(%r15),%rax
    5f62:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    5f68:	83 e8 01             	sub    $0x1,%eax
    5f6b:	83 f8 02             	cmp    $0x2,%eax
    5f6e:	77 9a                	ja     5f0a <f2fs_fiemap+0x48a>
		__put_devmap_managed_page(page);
    5f70:	4c 89 ff             	mov    %r15,%rdi
    5f73:	e8 00 00 00 00       	callq  5f78 <f2fs_fiemap+0x4f8>
		return;
    5f78:	eb 9b                	jmp    5f15 <f2fs_fiemap+0x495>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    5f7a:	49 8b 07             	mov    (%r15),%rax
    5f7d:	48 c1 e8 33          	shr    $0x33,%rax
    5f81:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    5f84:	83 f8 04             	cmp    $0x4,%eax
    5f87:	0f 85 32 fe ff ff    	jne    5dbf <f2fs_fiemap+0x33f>
	switch (page->pgmap->type) {
    5f8d:	49 8b 47 08          	mov    0x8(%r15),%rax
    5f91:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    5f97:	83 e8 01             	sub    $0x1,%eax
    5f9a:	83 f8 02             	cmp    $0x2,%eax
    5f9d:	0f 87 1c fe ff ff    	ja     5dbf <f2fs_fiemap+0x33f>
		__put_devmap_managed_page(page);
    5fa3:	4c 89 ff             	mov    %r15,%rdi
    5fa6:	e8 00 00 00 00       	callq  5fab <f2fs_fiemap+0x52b>
		flags = FIEMAP_EXTENT_LAST;
    5fab:	41 b8 01 00 00 00    	mov    $0x1,%r8d
		return;
    5fb1:	e9 1a fe ff ff       	jmpq   5dd0 <f2fs_fiemap+0x350>
		__put_page(page);
    5fb6:	4c 89 ff             	mov    %r15,%rdi
    5fb9:	e8 00 00 00 00       	callq  5fbe <f2fs_fiemap+0x53e>
    5fbe:	e9 52 ff ff ff       	jmpq   5f15 <f2fs_fiemap+0x495>
    5fc3:	4c 89 ff             	mov    %r15,%rdi
    5fc6:	44 89 85 50 ff ff ff 	mov    %r8d,-0xb0(%rbp)
    5fcd:	e8 00 00 00 00       	callq  5fd2 <f2fs_fiemap+0x552>
    5fd2:	44 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%r8d
    5fd9:	e9 f2 fd ff ff       	jmpq   5dd0 <f2fs_fiemap+0x350>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    5fde:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    5fe0:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
    5fe4:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    5fe7:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    5feb:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    5ff2:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    5ff7:	e9 f3 fe ff ff       	jmpq   5eef <f2fs_fiemap+0x46f>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    5ffc:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    5ffe:	49 8b 47 18          	mov    0x18(%r15),%rax
	return F2FS_SB(inode->i_sb);
    6002:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    6005:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    6009:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    6010:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    6015:	e9 8a fd ff ff       	jmpq   5da4 <f2fs_fiemap+0x324>
}
    601a:	e8 00 00 00 00       	callq  601f <f2fs_fiemap+0x59f>
			return -ENOMEM;
    601f:	c7 85 2c ff ff ff f4 	movl   $0xfffffff4,-0xd4(%rbp)
    6026:	ff ff ff 
    6029:	e9 d9 fd ff ff       	jmpq   5e07 <f2fs_fiemap+0x387>
    602e:	66 90                	xchg   %ax,%ax

0000000000006030 <f2fs_should_update_inplace>:
bool f2fs_should_update_inplace(struct inode *inode, struct f2fs_io_info *fio) {
    6030:	f3 0f 1e fa          	endbr64 
    6034:	e8 00 00 00 00       	callq  6039 <f2fs_should_update_inplace+0x9>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6039:	48 8b 87 78 02 00 00 	mov    0x278(%rdi),%rax
    6040:	48 c1 e8 1c          	shr    $0x1c,%rax
	if (f2fs_is_pinned_file(inode))
    6044:	83 e0 01             	and    $0x1,%eax
    6047:	75 19                	jne    6062 <f2fs_should_update_inplace+0x32>
		return true;
    6049:	b8 01 00 00 00       	mov    $0x1,%eax
	if (file_is_cold(inode))
    604e:	f6 87 60 02 00 00 01 	testb  $0x1,0x260(%rdi)
    6055:	75 0b                	jne    6062 <f2fs_should_update_inplace+0x32>
bool f2fs_should_update_inplace(struct inode *inode, struct f2fs_io_info *fio) {
    6057:	55                   	push   %rbp
    6058:	48 89 e5             	mov    %rsp,%rbp
    605b:	e8 90 b4 ff ff       	callq  14f0 <f2fs_should_update_inplace.part.0>
}
    6060:	5d                   	pop    %rbp
    6061:	c3                   	retq   
    6062:	c3                   	retq   
    6063:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    606a:	00 00 00 00 
    606e:	66 90                	xchg   %ax,%ax

0000000000006070 <f2fs_should_update_outplace>:
bool f2fs_should_update_outplace(struct inode *inode, struct f2fs_io_info *fio) {
    6070:	f3 0f 1e fa          	endbr64 
    6074:	e8 00 00 00 00       	callq  6079 <f2fs_should_update_outplace+0x9>
	return sb->s_fs_info;
    6079:	48 8b 47 28          	mov    0x28(%rdi),%rax
    607d:	55                   	push   %rbp
	if (test_opt(sbi, LFS))
    607e:	48 8b 90 08 04 00 00 	mov    0x408(%rax),%rdx
		return true;
    6085:	b8 01 00 00 00       	mov    $0x1,%eax
bool f2fs_should_update_outplace(struct inode *inode, struct f2fs_io_info *fio) {
    608a:	48 89 e5             	mov    %rsp,%rbp
	if (test_opt(sbi, LFS))
    608d:	f6 82 f2 04 00 00 04 	testb  $0x4,0x4f2(%rdx)
    6094:	75 3c                	jne    60d2 <f2fs_should_update_outplace+0x62>
	if (S_ISDIR(inode->i_mode))
    6096:	0f b7 17             	movzwl (%rdi),%edx
    6099:	66 81 e2 00 f0       	and    $0xf000,%dx
    609e:	66 81 fa 00 40       	cmp    $0x4000,%dx
    60a3:	74 2d                	je     60d2 <f2fs_should_update_outplace+0x62>
    60a5:	48 8b 87 78 02 00 00 	mov    0x278(%rdi),%rax
    60ac:	48 c1 e8 0f          	shr    $0xf,%rax
	if (f2fs_is_atomic_file(inode))
    60b0:	83 e0 01             	and    $0x1,%eax
    60b3:	75 1d                	jne    60d2 <f2fs_should_update_outplace+0x62>
	if (fio) {
    60b5:	48 85 f6             	test   %rsi,%rsi
    60b8:	74 18                	je     60d2 <f2fs_should_update_outplace+0x62>
		if (is_cold_data(fio->page))
    60ba:	48 8b 56 28          	mov    0x28(%rsi),%rdx
    60be:	48 8b 02             	mov    (%rdx),%rax
    60c1:	48 c1 e8 09          	shr    $0x9,%rax
    60c5:	83 e0 01             	and    $0x1,%eax
    60c8:	75 08                	jne    60d2 <f2fs_should_update_outplace+0x62>
		if (IS_ATOMIC_WRITTEN_PAGE(fio->page))
    60ca:	48 83 7a 28 ff       	cmpq   $0xffffffffffffffff,0x28(%rdx)
    60cf:	0f 94 c0             	sete   %al
}
    60d2:	5d                   	pop    %rbp
    60d3:	c3                   	retq   
    60d4:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    60db:	00 00 00 00 
    60df:	90                   	nop

00000000000060e0 <f2fs_do_write_data_page>:
int f2fs_do_write_data_page(struct f2fs_io_info *fio) {
    60e0:	f3 0f 1e fa          	endbr64 
    60e4:	e8 00 00 00 00       	callq  60e9 <f2fs_do_write_data_page+0x9>
    60e9:	55                   	push   %rbp
	if (f2fs_should_update_outplace(inode, fio))
    60ea:	48 89 fe             	mov    %rdi,%rsi
int f2fs_do_write_data_page(struct f2fs_io_info *fio) {
    60ed:	48 89 e5             	mov    %rsp,%rbp
    60f0:	41 57                	push   %r15
    60f2:	41 56                	push   %r14
    60f4:	41 55                	push   %r13
    60f6:	41 54                	push   %r12
    60f8:	53                   	push   %rbx
    60f9:	48 89 fb             	mov    %rdi,%rbx
    60fc:	48 83 ec 40          	sub    $0x40,%rsp
	struct page *page = fio->page;
    6100:	4c 8b 6f 28          	mov    0x28(%rdi),%r13
int f2fs_do_write_data_page(struct f2fs_io_info *fio) {
    6104:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    610b:	00 00 
    610d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6111:	31 c0                	xor    %eax,%eax
	struct inode *inode = page->mapping->host;
    6113:	49 8b 45 18          	mov    0x18(%r13),%rax
    6117:	4c 8b 30             	mov    (%rax),%r14
    611a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    6121:	00 
    6122:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    6129:	00 
	struct inode *inode = fio->page->mapping->host;
    612a:	49 8b 45 18          	mov    0x18(%r13),%rax
	struct extent_info ei = {0, 0, 0};
    612e:	48 c7 45 9c 00 00 00 	movq   $0x0,-0x64(%rbp)
    6135:	00 
    6136:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)
	dn->inode = inode;
    613d:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
	dn->inode_page = ipage;
    6141:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    6148:	00 
	dn->node_page = npage;
    6149:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    6150:	00 
	struct inode *inode = fio->page->mapping->host;
    6151:	4c 8b 20             	mov    (%rax),%r12
	if (f2fs_should_update_outplace(inode, fio))
    6154:	4c 89 e7             	mov    %r12,%rdi
    6157:	e8 00 00 00 00       	callq  615c <f2fs_do_write_data_page+0x7c>
    615c:	84 c0                	test   %al,%al
    615e:	0f 84 4f 01 00 00    	je     62b3 <f2fs_do_write_data_page+0x1d3>
	if (fio->need_lock == LOCK_REQ && !f2fs_trylock_op(fio->sbi))
    6164:	8b 4b 4c             	mov    0x4c(%rbx),%ecx
    6167:	85 c9                	test   %ecx,%ecx
    6169:	0f 84 25 01 00 00    	je     6294 <f2fs_do_write_data_page+0x1b4>
	err = f2fs_get_dnode_of_data(&dn, page->index, LOOKUP_NODE);
    616f:	49 8b 75 20          	mov    0x20(%r13),%rsi
    6173:	ba 01 00 00 00       	mov    $0x1,%edx
    6178:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
    617c:	e8 00 00 00 00       	callq  6181 <f2fs_do_write_data_page+0xa1>
    6181:	41 89 c4             	mov    %eax,%r12d
	if (err)
    6184:	85 c0                	test   %eax,%eax
    6186:	0f 85 d8 00 00 00    	jne    6264 <f2fs_do_write_data_page+0x184>
	fio->old_blkaddr = dn.data_blkaddr;
    618c:	8b 45 cc             	mov    -0x34(%rbp),%eax
    618f:	89 43 20             	mov    %eax,0x20(%rbx)
	if (fio->old_blkaddr == NULL_ADDR) {
    6192:	85 c0                	test   %eax,%eax
    6194:	0f 84 b1 02 00 00    	je     644b <f2fs_do_write_data_page+0x36b>
	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
    619a:	83 f8 ff             	cmp    $0xffffffff,%eax
    619d:	74 1e                	je     61bd <f2fs_do_write_data_page+0xdd>
	struct inode *inode = fio->page->mapping->host;
    619f:	48 8b 43 28          	mov    0x28(%rbx),%rax
	if (f2fs_should_update_outplace(inode, fio))
    61a3:	48 89 de             	mov    %rbx,%rsi
	struct inode *inode = fio->page->mapping->host;
    61a6:	48 8b 40 18          	mov    0x18(%rax),%rax
    61aa:	4c 8b 20             	mov    (%rax),%r12
	if (f2fs_should_update_outplace(inode, fio))
    61ad:	4c 89 e7             	mov    %r12,%rdi
    61b0:	e8 00 00 00 00       	callq  61b5 <f2fs_do_write_data_page+0xd5>
    61b5:	84 c0                	test   %al,%al
    61b7:	0f 84 55 03 00 00    	je     6512 <f2fs_do_write_data_page+0x432>
	if (fio->need_lock == LOCK_RETRY) {
    61bd:	83 7b 4c 02          	cmpl   $0x2,0x4c(%rbx)
    61c1:	0f 84 85 03 00 00    	je     654c <f2fs_do_write_data_page+0x46c>
	err = encrypt_one_page(fio);
    61c7:	48 89 df             	mov    %rbx,%rdi
    61ca:	e8 c1 b2 ff ff       	callq  1490 <encrypt_one_page>
    61cf:	41 89 c4             	mov    %eax,%r12d
	if (err)
    61d2:	85 c0                	test   %eax,%eax
    61d4:	0f 84 d7 02 00 00    	je     64b1 <f2fs_do_write_data_page+0x3d1>
	if (dn->node_page)
    61da:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    61de:	4d 85 ed             	test   %r13,%r13
    61e1:	0f 84 85 02 00 00    	je     646c <f2fs_do_write_data_page+0x38c>
    61e7:	49 8b 55 08          	mov    0x8(%r13),%rdx
    61eb:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    61ef:	83 e2 01             	and    $0x1,%edx
    61f2:	49 0f 44 c5          	cmove  %r13,%rax
    61f6:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    61f9:	a8 01                	test   $0x1,%al
    61fb:	0f 84 20 04 00 00    	je     6621 <f2fs_do_write_data_page+0x541>
		unlock_page(page);
    6201:	4c 89 ef             	mov    %r13,%rdi
    6204:	e8 00 00 00 00       	callq  6209 <f2fs_do_write_data_page+0x129>
    6209:	49 8b 45 08          	mov    0x8(%r13),%rax
    620d:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    6211:	a8 01                	test   $0x1,%al
    6213:	4c 0f 45 ea          	cmovne %rdx,%r13
    6217:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    621c:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
	if (put_page_testzero(page))
    6221:	0f 84 4e 03 00 00    	je     6575 <f2fs_do_write_data_page+0x495>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    6227:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    622b:	48 85 ff             	test   %rdi,%rdi
    622e:	74 24                	je     6254 <f2fs_do_write_data_page+0x174>
    6230:	48 3b 7d b8          	cmp    -0x48(%rbp),%rdi
    6234:	74 1e                	je     6254 <f2fs_do_write_data_page+0x174>
    6236:	48 8b 47 08          	mov    0x8(%rdi),%rax
    623a:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    623e:	a8 01                	test   $0x1,%al
    6240:	48 0f 45 fa          	cmovne %rdx,%rdi
    6244:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    6249:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    624d:	75 05                	jne    6254 <f2fs_do_write_data_page+0x174>
		__put_page(page);
    624f:	e8 00 00 00 00       	callq  6254 <f2fs_do_write_data_page+0x174>
	dn->node_page = NULL;
    6254:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    625b:	00 
	dn->inode_page = NULL;
    625c:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    6263:	00 
	if (fio->need_lock == LOCK_REQ)
    6264:	8b 43 4c             	mov    0x4c(%rbx),%eax
    6267:	85 c0                	test   %eax,%eax
    6269:	0f 84 91 01 00 00    	je     6400 <f2fs_do_write_data_page+0x320>
}
    626f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    6273:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    627a:	00 00 
    627c:	0f 85 79 04 00 00    	jne    66fb <f2fs_do_write_data_page+0x61b>
    6282:	48 83 c4 40          	add    $0x40,%rsp
    6286:	44 89 e0             	mov    %r12d,%eax
    6289:	5b                   	pop    %rbx
    628a:	41 5c                	pop    %r12
    628c:	41 5d                	pop    %r13
    628e:	41 5e                	pop    %r14
    6290:	41 5f                	pop    %r15
    6292:	5d                   	pop    %rbp
    6293:	c3                   	retq   
	return down_read_trylock(&sbi->cp_rwsem);
    6294:	48 8b 03             	mov    (%rbx),%rax
    6297:	48 8d b8 b0 01 00 00 	lea    0x1b0(%rax),%rdi
    629e:	e8 00 00 00 00       	callq  62a3 <f2fs_do_write_data_page+0x1c3>
	if (fio->need_lock == LOCK_REQ && !f2fs_trylock_op(fio->sbi))
    62a3:	85 c0                	test   %eax,%eax
    62a5:	0f 85 c4 fe ff ff    	jne    616f <f2fs_do_write_data_page+0x8f>
		return -EAGAIN;
    62ab:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
    62b1:	eb bc                	jmp    626f <f2fs_do_write_data_page+0x18f>
    62b3:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    62ba:	00 
	if (f2fs_is_pinned_file(inode))
    62bb:	a9 00 00 00 10       	test   $0x10000000,%eax
    62c0:	75 1e                	jne    62e0 <f2fs_do_write_data_page+0x200>
	if (file_is_cold(inode))
    62c2:	41 f6 84 24 60 02 00 	testb  $0x1,0x260(%r12)
    62c9:	00 01 
    62cb:	75 13                	jne    62e0 <f2fs_do_write_data_page+0x200>
    62cd:	48 89 de             	mov    %rbx,%rsi
    62d0:	4c 89 e7             	mov    %r12,%rdi
    62d3:	e8 18 b2 ff ff       	callq  14f0 <f2fs_should_update_inplace.part.0>
	if (need_inplace_update(fio) &&
    62d8:	84 c0                	test   %al,%al
    62da:	0f 84 84 fe ff ff    	je     6164 <f2fs_do_write_data_page+0x84>
		f2fs_lookup_extent_cache(inode, page->index, &ei)) {
    62e0:	49 8b 75 20          	mov    0x20(%r13),%rsi
    62e4:	48 8d 55 9c          	lea    -0x64(%rbp),%rdx
    62e8:	4c 89 f7             	mov    %r14,%rdi
    62eb:	e8 00 00 00 00       	callq  62f0 <f2fs_do_write_data_page+0x210>
	if (need_inplace_update(fio) &&
    62f0:	84 c0                	test   %al,%al
    62f2:	0f 84 6c fe ff ff    	je     6164 <f2fs_do_write_data_page+0x84>
		fio->old_blkaddr = ei.blk + page->index - ei.fofs;
    62f8:	8b 45 a4             	mov    -0x5c(%rbp),%eax
    62fb:	2b 45 9c             	sub    -0x64(%rbp),%eax
    62fe:	41 03 45 20          	add    0x20(%r13),%eax
    6302:	89 43 20             	mov    %eax,0x20(%rbx)
	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
    6305:	83 e8 01             	sub    $0x1,%eax
    6308:	83 f8 fd             	cmp    $0xfffffffd,%eax
    630b:	0f 87 53 fe ff ff    	ja     6164 <f2fs_do_write_data_page+0x84>
			fio->need_lock = LOCK_DONE;
    6311:	c7 43 4c 01 00 00 00 	movl   $0x1,0x4c(%rbx)
		err = encrypt_one_page(fio);
    6318:	48 89 df             	mov    %rbx,%rdi
    631b:	e8 70 b1 ff ff       	callq  1490 <encrypt_one_page>
    6320:	41 89 c4             	mov    %eax,%r12d
		if (err)
    6323:	85 c0                	test   %eax,%eax
    6325:	0f 85 af fe ff ff    	jne    61da <f2fs_do_write_data_page+0xfa>
	test_set_page_writeback(page);
    632b:	31 f6                	xor    %esi,%esi
    632d:	4c 89 ef             	mov    %r13,%rdi
    6330:	e8 00 00 00 00       	callq  6335 <f2fs_do_write_data_page+0x255>
		asm volatile(LOCK_PREFIX "andb %1,%0"
    6335:	f0 41 80 65 00 fd    	lock andb $0xfd,0x0(%r13)
	if (dn->node_page)
    633b:	4c 8b 65 b8          	mov    -0x48(%rbp),%r12
    633f:	4d 85 e4             	test   %r12,%r12
    6342:	0f 84 57 03 00 00    	je     669f <f2fs_do_write_data_page+0x5bf>
    6348:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
    634d:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    6351:	83 e2 01             	and    $0x1,%edx
    6354:	49 0f 44 c4          	cmove  %r12,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6358:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    635b:	a8 01                	test   $0x1,%al
    635d:	0f 84 9f 02 00 00    	je     6602 <f2fs_do_write_data_page+0x522>
		unlock_page(page);
    6363:	4c 89 e7             	mov    %r12,%rdi
    6366:	e8 00 00 00 00       	callq  636b <f2fs_do_write_data_page+0x28b>
    636b:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    6370:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    6374:	a8 01                	test   $0x1,%al
    6376:	4c 0f 45 e2          	cmovne %rdx,%r12
    637a:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    637f:	f0 41 ff 4c 24 34    	lock decl 0x34(%r12)
	if (put_page_testzero(page))
    6385:	0f 84 59 03 00 00    	je     66e4 <f2fs_do_write_data_page+0x604>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    638b:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    638f:	48 85 ff             	test   %rdi,%rdi
    6392:	74 23                	je     63b7 <f2fs_do_write_data_page+0x2d7>
    6394:	48 3b 7d b8          	cmp    -0x48(%rbp),%rdi
    6398:	74 1d                	je     63b7 <f2fs_do_write_data_page+0x2d7>
    639a:	48 8b 47 08          	mov    0x8(%rdi),%rax
    639e:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    63a2:	a8 01                	test   $0x1,%al
    63a4:	48 0f 45 fa          	cmovne %rdx,%rdi
    63a8:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    63ad:	f0 ff 4f 34          	lock decl 0x34(%rdi)
    63b1:	0f 84 3a 03 00 00    	je     66f1 <f2fs_do_write_data_page+0x611>
		if (fio->need_lock == LOCK_REQ)
    63b7:	8b 53 4c             	mov    0x4c(%rbx),%edx
	dn->node_page = NULL;
    63ba:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    63c1:	00 
	dn->inode_page = NULL;
    63c2:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    63c9:	00 
    63ca:	85 d2                	test   %edx,%edx
    63cc:	0f 84 b9 02 00 00    	je     668b <f2fs_do_write_data_page+0x5ab>
		err = f2fs_inplace_write_data(fio);
    63d2:	48 89 df             	mov    %rbx,%rdi
    63d5:	e8 00 00 00 00       	callq  63da <f2fs_do_write_data_page+0x2fa>
    63da:	41 89 c4             	mov    %eax,%r12d
    63dd:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    63e2:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    63e9:	f6 c4 20             	test   $0x20,%ah
    63ec:	0f 85 7d fe ff ff    	jne    626f <f2fs_do_write_data_page+0x18f>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    63f2:	f0 41 80 8e 79 02 00 	lock orb $0x20,0x279(%r14)
    63f9:	00 20 
    63fb:	e9 6f fe ff ff       	jmpq   626f <f2fs_do_write_data_page+0x18f>
	up_read(&sbi->cp_rwsem);
    6400:	48 8b 3b             	mov    (%rbx),%rdi
    6403:	48 81 c7 b0 01 00 00 	add    $0x1b0,%rdi
    640a:	e8 00 00 00 00       	callq  640f <f2fs_do_write_data_page+0x32f>
}
    640f:	e9 5b fe ff ff       	jmpq   626f <f2fs_do_write_data_page+0x18f>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    6414:	49 8b 45 00          	mov    0x0(%r13),%rax
    6418:	48 c1 e8 33          	shr    $0x33,%rax
    641c:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    641f:	83 f8 04             	cmp    $0x4,%eax
    6422:	0f 85 f4 fd ff ff    	jne    621c <f2fs_do_write_data_page+0x13c>
	switch (page->pgmap->type) {
    6428:	49 8b 45 08          	mov    0x8(%r13),%rax
    642c:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    6432:	83 e8 01             	sub    $0x1,%eax
    6435:	83 f8 02             	cmp    $0x2,%eax
    6438:	0f 87 de fd ff ff    	ja     621c <f2fs_do_write_data_page+0x13c>
		__put_devmap_managed_page(page);
    643e:	4c 89 ef             	mov    %r13,%rdi
    6441:	e8 00 00 00 00       	callq  6446 <f2fs_do_write_data_page+0x366>
		return;
    6446:	e9 dc fd ff ff       	jmpq   6227 <f2fs_do_write_data_page+0x147>
    644b:	49 8b 45 08          	mov    0x8(%r13),%rax
    644f:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
    6453:	a8 01                	test   $0x1,%al
    6455:	4c 0f 45 ea          	cmovne %rdx,%r13
		asm volatile(LOCK_PREFIX "andb %1,%0"
    6459:	f0 41 80 65 00 f7    	lock andb $0xf7,0x0(%r13)
	if (dn->node_page)
    645f:	4c 8b 6d b8          	mov    -0x48(%rbp),%r13
    6463:	4d 85 ed             	test   %r13,%r13
    6466:	0f 85 7b fd ff ff    	jne    61e7 <f2fs_do_write_data_page+0x107>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    646c:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    6470:	48 85 ff             	test   %rdi,%rdi
    6473:	0f 85 bd fd ff ff    	jne    6236 <f2fs_do_write_data_page+0x156>
    6479:	e9 d6 fd ff ff       	jmpq   6254 <f2fs_do_write_data_page+0x174>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    647e:	48 8b 07             	mov    (%rdi),%rax
    6481:	48 c1 e8 33          	shr    $0x33,%rax
    6485:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    6488:	83 f8 04             	cmp    $0x4,%eax
    648b:	0f 85 b8 fd ff ff    	jne    6249 <f2fs_do_write_data_page+0x169>
	switch (page->pgmap->type) {
    6491:	48 8b 47 08          	mov    0x8(%rdi),%rax
    6495:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    649b:	83 e8 01             	sub    $0x1,%eax
    649e:	83 f8 02             	cmp    $0x2,%eax
    64a1:	0f 87 a2 fd ff ff    	ja     6249 <f2fs_do_write_data_page+0x169>
		__put_devmap_managed_page(page);
    64a7:	e8 00 00 00 00       	callq  64ac <f2fs_do_write_data_page+0x3cc>
		return;
    64ac:	e9 a3 fd ff ff       	jmpq   6254 <f2fs_do_write_data_page+0x174>
	test_set_page_writeback(page);
    64b1:	31 f6                	xor    %esi,%esi
    64b3:	4c 89 ef             	mov    %r13,%rdi
    64b6:	e8 00 00 00 00       	callq  64bb <f2fs_do_write_data_page+0x3db>
    64bb:	f0 41 80 65 00 fd    	lock andb $0xfd,0x0(%r13)
	f2fs_outplace_write_data(&dn, fio);
    64c1:	48 89 de             	mov    %rbx,%rsi
    64c4:	48 8d 7d a8          	lea    -0x58(%rbp),%rdi
    64c8:	e8 00 00 00 00       	callq  64cd <f2fs_do_write_data_page+0x3ed>
    64cd:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    64d2:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    64d9:	f6 c4 10             	test   $0x10,%ah
    64dc:	75 09                	jne    64e7 <f2fs_do_write_data_page+0x407>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    64de:	f0 41 80 8e 79 02 00 	lock orb $0x10,0x279(%r14)
    64e5:	00 10 
	if (page->index == 0)
    64e7:	49 83 7d 20 00       	cmpq   $0x0,0x20(%r13)
    64ec:	0f 85 e8 fc ff ff    	jne    61da <f2fs_do_write_data_page+0xfa>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    64f2:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
    64f9:	a9 00 00 04 00       	test   $0x40000,%eax
    64fe:	0f 85 d6 fc ff ff    	jne    61da <f2fs_do_write_data_page+0xfa>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    6504:	f0 41 80 8e 7a 02 00 	lock orb $0x4,0x27a(%r14)
    650b:	00 04 
    650d:	e9 c8 fc ff ff       	jmpq   61da <f2fs_do_write_data_page+0xfa>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6512:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    6519:	00 
	if (f2fs_is_pinned_file(inode))
    651a:	a9 00 00 00 10       	test   $0x10000000,%eax
    651f:	0f 85 f3 fd ff ff    	jne    6318 <f2fs_do_write_data_page+0x238>
	if (file_is_cold(inode))
    6525:	41 f6 84 24 60 02 00 	testb  $0x1,0x260(%r12)
    652c:	00 01 
    652e:	0f 85 e4 fd ff ff    	jne    6318 <f2fs_do_write_data_page+0x238>
    6534:	48 89 de             	mov    %rbx,%rsi
    6537:	4c 89 e7             	mov    %r12,%rdi
    653a:	e8 b1 af ff ff       	callq  14f0 <f2fs_should_update_inplace.part.0>
	if (ipu_force || (is_valid_blkaddr(fio->old_blkaddr) &&
    653f:	84 c0                	test   %al,%al
    6541:	0f 84 76 fc ff ff    	je     61bd <f2fs_do_write_data_page+0xdd>
    6547:	e9 cc fd ff ff       	jmpq   6318 <f2fs_do_write_data_page+0x238>
	return down_read_trylock(&sbi->cp_rwsem);
    654c:	48 8b 03             	mov    (%rbx),%rax
			err = -EAGAIN;
    654f:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
    6555:	48 8d b8 b0 01 00 00 	lea    0x1b0(%rax),%rdi
    655c:	e8 00 00 00 00       	callq  6561 <f2fs_do_write_data_page+0x481>
		if (!f2fs_trylock_op(fio->sbi)) {
    6561:	85 c0                	test   %eax,%eax
    6563:	0f 84 71 fc ff ff    	je     61da <f2fs_do_write_data_page+0xfa>
		fio->need_lock = LOCK_REQ;
    6569:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%rbx)
    6570:	e9 52 fc ff ff       	jmpq   61c7 <f2fs_do_write_data_page+0xe7>
		__put_page(page);
    6575:	4c 89 ef             	mov    %r13,%rdi
    6578:	e8 00 00 00 00       	callq  657d <f2fs_do_write_data_page+0x49d>
    657d:	e9 a5 fc ff ff       	jmpq   6227 <f2fs_do_write_data_page+0x147>
DEFINE_EVENT(f2fs__page, f2fs_do_write_data_page,
    6582:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 6589 <f2fs_do_write_data_page+0x4a9>
    6589:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    658b:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 6593 <f2fs_do_write_data_page+0x4b3>
    6592:	00 
    6593:	0f 83 39 ff ff ff    	jae    64d2 <f2fs_do_write_data_page+0x3f2>
    6599:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # 65a0 <f2fs_do_write_data_page+0x4c0>
    65a0:	4d 85 ff             	test   %r15,%r15
    65a3:	74 20                	je     65c5 <f2fs_do_write_data_page+0x4e5>
    65a5:	49 8b 07             	mov    (%r15),%rax
    65a8:	49 8b 7f 08          	mov    0x8(%r15),%rdi
    65ac:	49 83 c7 18          	add    $0x18,%r15
    65b0:	ba 0a 00 00 00       	mov    $0xa,%edx
    65b5:	4c 89 ee             	mov    %r13,%rsi
    65b8:	e8 00 00 00 00       	callq  65bd <f2fs_do_write_data_page+0x4dd>
    65bd:	49 8b 07             	mov    (%r15),%rax
    65c0:	48 85 c0             	test   %rax,%rax
    65c3:	75 e3                	jne    65a8 <f2fs_do_write_data_page+0x4c8>
    65c5:	e9 08 ff ff ff       	jmpq   64d2 <f2fs_do_write_data_page+0x3f2>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    65ca:	49 8b 04 24          	mov    (%r12),%rax
    65ce:	48 c1 e8 33          	shr    $0x33,%rax
    65d2:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    65d5:	83 f8 04             	cmp    $0x4,%eax
    65d8:	0f 85 a1 fd ff ff    	jne    637f <f2fs_do_write_data_page+0x29f>
	switch (page->pgmap->type) {
    65de:	49 8b 44 24 08       	mov    0x8(%r12),%rax
    65e3:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    65e9:	83 e8 01             	sub    $0x1,%eax
    65ec:	83 f8 02             	cmp    $0x2,%eax
    65ef:	0f 87 8a fd ff ff    	ja     637f <f2fs_do_write_data_page+0x29f>
		__put_devmap_managed_page(page);
    65f5:	4c 89 e7             	mov    %r12,%rdi
    65f8:	e8 00 00 00 00       	callq  65fd <f2fs_do_write_data_page+0x51d>
		return;
    65fd:	e9 89 fd ff ff       	jmpq   638b <f2fs_do_write_data_page+0x2ab>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    6602:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    6604:	49 8b 44 24 18       	mov    0x18(%r12),%rax
	return F2FS_SB(inode->i_sb);
    6609:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    660c:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    6610:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
    6617:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    661c:	e9 42 fd ff ff       	jmpq   6363 <f2fs_do_write_data_page+0x283>
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
    6621:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
    6623:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
    6627:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
    662a:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
    662e:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    6635:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
}
    663a:	e9 c2 fb ff ff       	jmpq   6201 <f2fs_do_write_data_page+0x121>
    663f:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 6646 <f2fs_do_write_data_page+0x566>
    6646:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    6648:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 6650 <f2fs_do_write_data_page+0x570>
    664f:	00 
    6650:	0f 83 8c fd ff ff    	jae    63e2 <f2fs_do_write_data_page+0x302>
		trace_f2fs_do_write_data_page(fio->page, IPU);
    6656:	4c 8b 6b 28          	mov    0x28(%rbx),%r13
    665a:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 6661 <f2fs_do_write_data_page+0x581>
    6661:	48 85 db             	test   %rbx,%rbx
    6664:	74 20                	je     6686 <f2fs_do_write_data_page+0x5a6>
    6666:	48 8b 03             	mov    (%rbx),%rax
    6669:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    666d:	48 83 c3 18          	add    $0x18,%rbx
    6671:	ba 09 00 00 00       	mov    $0x9,%edx
    6676:	4c 89 ee             	mov    %r13,%rsi
    6679:	e8 00 00 00 00       	callq  667e <f2fs_do_write_data_page+0x59e>
    667e:	48 8b 03             	mov    (%rbx),%rax
    6681:	48 85 c0             	test   %rax,%rax
    6684:	75 e3                	jne    6669 <f2fs_do_write_data_page+0x589>
    6686:	e9 57 fd ff ff       	jmpq   63e2 <f2fs_do_write_data_page+0x302>
	up_read(&sbi->cp_rwsem);
    668b:	48 8b 03             	mov    (%rbx),%rax
    668e:	48 8d b8 b0 01 00 00 	lea    0x1b0(%rax),%rdi
    6695:	e8 00 00 00 00       	callq  669a <f2fs_do_write_data_page+0x5ba>
}
    669a:	e9 33 fd ff ff       	jmpq   63d2 <f2fs_do_write_data_page+0x2f2>
	if (dn->inode_page && dn->node_page != dn->inode_page)
    669f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    66a3:	48 85 ff             	test   %rdi,%rdi
    66a6:	0f 85 ee fc ff ff    	jne    639a <f2fs_do_write_data_page+0x2ba>
    66ac:	e9 06 fd ff ff       	jmpq   63b7 <f2fs_do_write_data_page+0x2d7>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
    66b1:	48 8b 07             	mov    (%rdi),%rax
    66b4:	48 c1 e8 33          	shr    $0x33,%rax
    66b8:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
    66bb:	83 f8 04             	cmp    $0x4,%eax
    66be:	0f 85 e9 fc ff ff    	jne    63ad <f2fs_do_write_data_page+0x2cd>
	switch (page->pgmap->type) {
    66c4:	48 8b 47 08          	mov    0x8(%rdi),%rax
    66c8:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
    66ce:	83 e8 01             	sub    $0x1,%eax
    66d1:	83 f8 02             	cmp    $0x2,%eax
    66d4:	0f 87 d3 fc ff ff    	ja     63ad <f2fs_do_write_data_page+0x2cd>
		__put_devmap_managed_page(page);
    66da:	e8 00 00 00 00       	callq  66df <f2fs_do_write_data_page+0x5ff>
		return;
    66df:	e9 d3 fc ff ff       	jmpq   63b7 <f2fs_do_write_data_page+0x2d7>
		__put_page(page);
    66e4:	4c 89 e7             	mov    %r12,%rdi
    66e7:	e8 00 00 00 00       	callq  66ec <f2fs_do_write_data_page+0x60c>
    66ec:	e9 9a fc ff ff       	jmpq   638b <f2fs_do_write_data_page+0x2ab>
    66f1:	e8 00 00 00 00       	callq  66f6 <f2fs_do_write_data_page+0x616>
    66f6:	e9 bc fc ff ff       	jmpq   63b7 <f2fs_do_write_data_page+0x2d7>
}
    66fb:	e8 00 00 00 00       	callq  6700 <__write_data_page>

0000000000006700 <__write_data_page>:
							 enum iostat_type io_type) {
    6700:	e8 00 00 00 00       	callq  6705 <__write_data_page+0x5>
    6705:	55                   	push   %rbp
    6706:	48 89 e5             	mov    %rsp,%rbp
    6709:	41 57                	push   %r15
    670b:	41 56                	push   %r14
    670d:	41 55                	push   %r13
    670f:	41 54                	push   %r12
    6711:	49 89 fc             	mov    %rdi,%r12
    6714:	53                   	push   %rbx
    6715:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    671c:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
    6723:	48 89 d6             	mov    %rdx,%rsi
    6726:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
    672d:	89 ca                	mov    %ecx,%edx
	struct f2fs_io_info fio = {
    672f:	b9 0b 00 00 00       	mov    $0xb,%ecx
							 enum iostat_type io_type) {
    6734:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    673b:	00 00 
    673d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6741:	31 c0                	xor    %eax,%eax
	struct inode *inode = page->mapping->host;
    6743:	48 8b 47 18          	mov    0x18(%rdi),%rax
    6747:	4c 8b 30             	mov    (%rax),%r14
	return sb->s_fs_info;
    674a:	49 8b 46 28          	mov    0x28(%r14),%rax
	return inode->i_size;
    674e:	49 8b 5e 50          	mov    0x50(%r14),%rbx
    6752:	4c 8b a8 08 04 00 00 	mov    0x408(%rax),%r13
	const pgoff_t end_index = ((unsigned long long) i_size)
    6759:	48 89 d8             	mov    %rbx,%rax
    675c:	48 c1 e8 0c          	shr    $0xc,%rax
    6760:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
	loff_t psize = (page->index + 1) << PAGE_SHIFT;
    6767:	48 8b 47 20          	mov    0x20(%rdi),%rax
	struct f2fs_io_info fio = {
    676b:	48 8d bd 78 ff ff ff 	lea    -0x88(%rbp),%rdi
    6772:	4c 89 ad 70 ff ff ff 	mov    %r13,-0x90(%rbp)
	loff_t psize = (page->index + 1) << PAGE_SHIFT;
    6779:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
	struct f2fs_io_info fio = {
    6780:	31 c0                	xor    %eax,%eax
	if (wbc->sync_mode == WB_SYNC_ALL)
    6782:	83 7e 20 01          	cmpl   $0x1,0x20(%rsi)
    6786:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    6789:	c7 45 84 01 00 00 00 	movl   $0x1,-0x7c(%rbp)
    6790:	49 8b 46 40          	mov    0x40(%r14),%rax
    6794:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
    679a:	0f 84 20 05 00 00    	je     6cc0 <__write_data_page+0x5c0>
		return REQ_BACKGROUND;
    67a0:	31 c0                	xor    %eax,%eax
    67a2:	f6 46 24 03          	testb  $0x3,0x24(%rsi)
    67a6:	0f 95 c0             	setne  %al
    67a9:	c1 e0 14             	shl    $0x14,%eax
    67ac:	89 45 88             	mov    %eax,-0x78(%rbp)
    67af:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    67b6:	4c 89 65 98          	mov    %r12,-0x68(%rbp)
    67ba:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%rbp)
    67c1:	89 55 c4             	mov    %edx,-0x3c(%rbp)
    67c4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    67c8:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	unsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);
    67cd:	49 8b 85 78 01 00 00 	mov    0x178(%r13),%rax
	if (unlikely(f2fs_cp_error(sbi))) {
    67d4:	f6 80 84 00 00 00 08 	testb  $0x8,0x84(%rax)
    67db:	0f 85 42 03 00 00    	jne    6b23 <__write_data_page+0x423>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    67e1:	49 8b 45 48          	mov    0x48(%r13),%rax
    67e5:	48 c1 e8 03          	shr    $0x3,%rax
	if (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))
    67e9:	83 e0 01             	and    $0x1,%eax
    67ec:	0f 85 5e 03 00 00    	jne    6b50 <__write_data_page+0x450>
	if (page->index < end_index)
    67f2:	49 8b 54 24 20       	mov    0x20(%r12),%rdx
    67f7:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
    67fe:	48 39 fa             	cmp    %rdi,%rdx
    6801:	0f 82 a6 00 00 00    	jb     68ad <__write_data_page+0x1ad>
	if ((page->index >= end_index + 1) || !offset)
    6807:	48 83 c7 01          	add    $0x1,%rdi
	offset = i_size & (PAGE_SIZE - 1);
    680b:	81 e3 ff 0f 00 00    	and    $0xfff,%ebx
	if ((page->index >= end_index + 1) || !offset)
    6811:	48 39 fa             	cmp    %rdi,%rdx
    6814:	0f 83 ad 01 00 00    	jae    69c7 <__write_data_page+0x2c7>
    681a:	85 db                	test   %ebx,%ebx
    681c:	0f 84 a5 01 00 00    	je     69c7 <__write_data_page+0x2c7>
    6822:	65 48 8b 14 25 00 00 	mov    %gs:0x0,%rdx
    6829:	00 00 
	current->pagefault_disabled++;
    682b:	83 82 38 12 00 00 01 	addl   $0x1,0x1238(%rdx)
	return page_to_virt(page);
    6832:	4c 89 e2             	mov    %r12,%rdx
    6835:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # 683c <__write_data_page+0x13c>
    683c:	b9 00 10 00 00       	mov    $0x1000,%ecx
    6841:	48 c1 fa 06          	sar    $0x6,%rdx
    6845:	29 d9                	sub    %ebx,%ecx
    6847:	48 c1 e2 0c          	shl    $0xc,%rdx
    684b:	48 03 15 00 00 00 00 	add    0x0(%rip),%rdx        # 6852 <__write_data_page+0x152>
    6852:	48 01 d3             	add    %rdx,%rbx
    6855:	83 f9 08             	cmp    $0x8,%ecx
    6858:	73 1e                	jae    6878 <__write_data_page+0x178>
    685a:	f6 c1 04             	test   $0x4,%cl
    685d:	0f 85 aa 05 00 00    	jne    6e0d <__write_data_page+0x70d>
    6863:	85 c9                	test   %ecx,%ecx
    6865:	74 36                	je     689d <__write_data_page+0x19d>
    6867:	c6 03 00             	movb   $0x0,(%rbx)
    686a:	f6 c1 02             	test   $0x2,%cl
    686d:	74 2e                	je     689d <__write_data_page+0x19d>
    686f:	31 c0                	xor    %eax,%eax
    6871:	66 89 44 0b fe       	mov    %ax,-0x2(%rbx,%rcx,1)
    6876:	eb 25                	jmp    689d <__write_data_page+0x19d>
    6878:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
    687c:	89 ca                	mov    %ecx,%edx
    687e:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
    6885:	48 c7 44 13 f8 00 00 	movq   $0x0,-0x8(%rbx,%rdx,1)
    688c:	00 00 
    688e:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    6892:	48 29 fb             	sub    %rdi,%rbx
    6895:	01 d9                	add    %ebx,%ecx
    6897:	c1 e9 03             	shr    $0x3,%ecx
    689a:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    689d:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    68a4:	00 00 
	current->pagefault_disabled--;
    68a6:	83 a8 38 12 00 00 01 	subl   $0x1,0x1238(%rax)
    68ad:	49 8b 9e 78 02 00 00 	mov    0x278(%r14),%rbx
    68b4:	48 c1 eb 13          	shr    $0x13,%rbx
	if (f2fs_is_drop_cache(inode))
    68b8:	83 e3 01             	and    $0x1,%ebx
    68bb:	0f 85 06 01 00 00    	jne    69c7 <__write_data_page+0x2c7>
    68c1:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (f2fs_is_volatile_file(inode) && (!page->index ||
    68c8:	a9 00 00 02 00       	test   $0x20000,%eax
    68cd:	0f 84 ef 02 00 00    	je     6bc2 <__write_data_page+0x4c2>
    68d3:	49 83 7c 24 20 00    	cmpq   $0x0,0x20(%r12)
    68d9:	0f 84 71 02 00 00    	je     6b50 <__write_data_page+0x450>
    68df:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    68e6:	f6 40 24 08          	testb  $0x8,0x24(%rax)
    68ea:	0f 84 c1 02 00 00    	je     6bb1 <__write_data_page+0x4b1>
	if (S_ISDIR(inode->i_mode)) {
    68f0:	41 0f b7 06          	movzwl (%r14),%eax
    68f4:	66 25 00 f0          	and    $0xf000,%ax
    68f8:	66 3d 00 40          	cmp    $0x4000,%ax
    68fc:	0f 84 d5 04 00 00    	je     6dd7 <__write_data_page+0x6d7>
    6902:	41 8b 85 80 04 00 00 	mov    0x480(%r13),%eax
    6909:	45 8b 9d 74 04 00 00 	mov    0x474(%r13),%r11d
    6910:	45 8b 8d 8c 04 00 00 	mov    0x48c(%r13),%r9d
	unsigned int pages_per_sec = sbi->segs_per_sec * sbi->blocks_per_seg;
    6917:	41 8b b5 28 04 00 00 	mov    0x428(%r13),%esi
    691e:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
    6924:	49 8b 45 48          	mov    0x48(%r13),%rax
    6928:	41 8b 8d 24 04 00 00 	mov    0x424(%r13),%ecx
	if (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))
    692f:	a8 08                	test   $0x8,%al
    6931:	75 72                	jne    69a5 <__write_data_page+0x2a5>
	return (struct f2fs_sm_info *)(sbi->sm_info);
    6933:	49 8b 7d 68          	mov    0x68(%r13),%rdi
	return GET_SEC_FROM_SEG(sbi, (unsigned int)reserved_segments(sbi));
    6937:	31 d2                	xor    %edx,%edx
	return FREE_I(sbi)->free_sections;
    6939:	48 8b 47 08          	mov    0x8(%rdi),%rax
    693d:	44 8b 50 08          	mov    0x8(%rax),%r10d
	return GET_SEC_FROM_SEG(sbi, (unsigned int)reserved_segments(sbi));
    6941:	8b 47 5c             	mov    0x5c(%rdi),%eax
    6944:	f7 f6                	div    %esi
    6946:	41 89 c7             	mov    %eax,%r15d
	if (free_sections(sbi) + freed == reserved_sections(sbi) + needed &&
    6949:	41 39 c2             	cmp    %eax,%r10d
    694c:	0f 84 dc 03 00 00    	je     6d2e <__write_data_page+0x62e>
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    6952:	41 89 c8             	mov    %ecx,%r8d
	return atomic_read(&sbi->nr_pages[count_type]);
    6955:	48 63 85 58 ff ff ff 	movslq -0xa8(%rbp),%rax
						sbi->log_blocks_per_seg;
    695c:	41 8b 8d 20 04 00 00 	mov    0x420(%r13),%ecx
	return segs / sbi->segs_per_sec;
    6963:	31 d2                	xor    %edx,%edx
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    6965:	44 0f af c6          	imul   %esi,%r8d
    6969:	49 8d 44 00 ff       	lea    -0x1(%r8,%rax,1),%rax
    696e:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    6971:	f7 f6                	div    %esi
    6973:	31 d2                	xor    %edx,%edx
    6975:	89 c7                	mov    %eax,%edi
	return atomic_read(&sbi->nr_pages[count_type]);
    6977:	49 63 c1             	movslq %r9d,%rax
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    697a:	49 8d 44 00 ff       	lea    -0x1(%r8,%rax,1),%rax
    697f:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    6982:	f7 f6                	div    %esi
    6984:	31 d2                	xor    %edx,%edx
		(node_secs + 2 * dent_secs + imeta_secs +
    6986:	01 f8                	add    %edi,%eax
    6988:	41 01 c7             	add    %eax,%r15d
	return atomic_read(&sbi->nr_pages[count_type]);
    698b:	49 63 c3             	movslq %r11d,%rax
	unsigned int segs = (get_pages(sbi, block_type) + pages_per_sec - 1) >>
    698e:	49 8d 44 00 ff       	lea    -0x1(%r8,%rax,1),%rax
    6993:	48 d3 f8             	sar    %cl,%rax
	return segs / sbi->segs_per_sec;
    6996:	f7 f6                	div    %esi
    6998:	41 8d 04 47          	lea    (%r15,%rax,2),%eax
	else if (has_not_enough_free_secs(sbi, 0, 0))
    699c:	41 39 c2             	cmp    %eax,%r10d
    699f:	0f 86 ab 01 00 00    	jbe    6b50 <__write_data_page+0x450>
    69a5:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    69ac:	a9 00 00 00 02       	test   $0x2000000,%eax
    69b1:	0f 85 33 02 00 00    	jne    6bea <__write_data_page+0x4ea>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    69b7:	f0 41 80 8e 7b 02 00 	lock orb $0x2,0x27b(%r14)
    69be:	00 02 
	bool need_balance_fs = false;
    69c0:	31 db                	xor    %ebx,%ebx
    69c2:	e9 23 02 00 00       	jmpq   6bea <__write_data_page+0x4ea>
    69c7:	41 0f b7 06          	movzwl (%r14),%eax
    69cb:	89 c1                	mov    %eax,%ecx
    69cd:	66 81 e1 00 f0       	and    $0xf000,%cx
    69d2:	31 db                	xor    %ebx,%ebx
	if (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&
    69d4:	89 c2                	mov    %eax,%edx
    69d6:	66 81 e2 00 d0       	and    $0xd000,%dx
    69db:	66 81 fa 00 80       	cmp    $0x8000,%dx
    69e0:	74 07                	je     69e9 <__write_data_page+0x2e9>
    69e2:	66 81 f9 00 40       	cmp    $0x4000,%cx
    69e7:	75 60                	jne    6a49 <__write_data_page+0x349>
    69e9:	45 31 ff             	xor    %r15d,%r15d
	asm volatile(LOCK_PREFIX "decl %0"
    69ec:	f0 41 ff 8e a8 02 00 	lock decl 0x2a8(%r14)
    69f3:	00 
	dec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?
    69f4:	66 25 00 f0          	and    $0xf000,%ax
	return sb->s_fs_info;
    69f8:	49 8b 56 28          	mov    0x28(%r14),%rdx
	dec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?
    69fc:	66 3d 00 40          	cmp    $0x4000,%ax
    6a00:	0f 95 c0             	setne  %al
	atomic_dec(&sbi->nr_pages[count_type]);
    6a03:	48 8b 92 08 04 00 00 	mov    0x408(%rdx),%rdx
	dec_page_count(F2FS_I_SB(inode), S_ISDIR(inode->i_mode) ?
    6a0a:	0f b6 c0             	movzbl %al,%eax
	atomic_dec(&sbi->nr_pages[count_type]);
    6a0d:	48 05 1d 01 00 00    	add    $0x11d,%rax
    6a13:	f0 ff 0c 82          	lock decl (%rdx,%rax,4)
	if (IS_NOQUOTA(inode))
    6a17:	41 f6 46 0c 20       	testb  $0x20,0xc(%r14)
    6a1c:	74 12                	je     6a30 <__write_data_page+0x330>
	return sb->s_fs_info;
    6a1e:	49 8b 46 28          	mov    0x28(%r14),%rax
	atomic_dec(&sbi->nr_pages[count_type]);
    6a22:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
    6a29:	f0 ff 88 7c 04 00 00 	lock decl 0x47c(%rax)
	if (err)
    6a30:	45 85 ff             	test   %r15d,%r15d
    6a33:	74 14                	je     6a49 <__write_data_page+0x349>
    6a35:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		return (struct page *) (head - 1);
    6a3a:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    6a3e:	83 e2 01             	and    $0x1,%edx
    6a41:	49 0f 44 c4          	cmove  %r12,%rax
		asm volatile(LOCK_PREFIX "andb %1,%0"
    6a45:	f0 80 20 f7          	lock andb $0xf7,(%rax)
	if (wbc->for_reclaim) {
    6a49:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    6a50:	f6 40 24 08          	testb  $0x8,0x24(%rax)
    6a54:	0f 85 10 01 00 00    	jne    6b6a <__write_data_page+0x46a>
	unlock_page(page);
    6a5a:	4c 89 e7             	mov    %r12,%rdi
    6a5d:	e8 00 00 00 00       	callq  6a62 <__write_data_page+0x362>
	if (!S_ISDIR(inode->i_mode))
    6a62:	41 0f b7 06          	movzwl (%r14),%eax
    6a66:	66 25 00 f0          	and    $0xf000,%ax
    6a6a:	66 3d 00 40          	cmp    $0x4000,%ax
    6a6e:	74 0b                	je     6a7b <__write_data_page+0x37b>
		f2fs_balance_fs(sbi, need_balance_fs);
    6a70:	0f b6 f3             	movzbl %bl,%esi
    6a73:	4c 89 ef             	mov    %r13,%rdi
    6a76:	e8 00 00 00 00       	callq  6a7b <__write_data_page+0x37b>
	unsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);
    6a7b:	49 8b 85 78 01 00 00 	mov    0x178(%r13),%rax
	if (unlikely(f2fs_cp_error(sbi))) {
    6a82:	f6 80 84 00 00 00 08 	testb  $0x8,0x84(%rax)
    6a89:	0f 85 46 02 00 00    	jne    6cd5 <__write_data_page+0x5d5>
	if (submitted)
    6a8f:	48 8b 9d 60 ff ff ff 	mov    -0xa0(%rbp),%rbx
	return 0;
    6a96:	45 31 ff             	xor    %r15d,%r15d
	if (submitted)
    6a99:	48 85 db             	test   %rbx,%rbx
    6a9c:	74 06                	je     6aa4 <__write_data_page+0x3a4>
		*submitted = fio.submitted;
    6a9e:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
    6aa2:	88 03                	mov    %al,(%rbx)
}
    6aa4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    6aa8:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    6aaf:	00 00 
    6ab1:	0f 85 69 03 00 00    	jne    6e20 <__write_data_page+0x720>
    6ab7:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    6abe:	44 89 f8             	mov    %r15d,%eax
    6ac1:	5b                   	pop    %rbx
    6ac2:	41 5c                	pop    %r12
    6ac4:	41 5d                	pop    %r13
    6ac6:	41 5e                	pop    %r14
    6ac8:	41 5f                	pop    %r15
    6aca:	5d                   	pop    %rbp
    6acb:	c3                   	retq   
DEFINE_EVENT(f2fs__page, f2fs_writepage,
    6acc:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 6ad3 <__write_data_page+0x3d3>
    6ad3:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    6ad5:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 6add <__write_data_page+0x3dd>
    6adc:	00 
    6add:	0f 83 ea fc ff ff    	jae    67cd <__write_data_page+0xcd>
    6ae3:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 6aea <__write_data_page+0x3ea>
    6aea:	48 85 c0             	test   %rax,%rax
    6aed:	74 20                	je     6b0f <__write_data_page+0x40f>
    6aef:	48 8b 08             	mov    (%rax),%rcx
    6af2:	49 89 c7             	mov    %rax,%r15
    6af5:	49 8b 7f 08          	mov    0x8(%r15),%rdi
    6af9:	49 83 c7 18          	add    $0x18,%r15
    6afd:	31 d2                	xor    %edx,%edx
    6aff:	4c 89 e6             	mov    %r12,%rsi
    6b02:	e8 00 00 00 00       	callq  6b07 <__write_data_page+0x407>
    6b07:	49 8b 0f             	mov    (%r15),%rcx
    6b0a:	48 85 c9             	test   %rcx,%rcx
    6b0d:	75 e6                	jne    6af5 <__write_data_page+0x3f5>
    6b0f:	49 8b 85 78 01 00 00 	mov    0x178(%r13),%rax
	if (unlikely(f2fs_cp_error(sbi))) {
    6b16:	f6 80 84 00 00 00 08 	testb  $0x8,0x84(%rax)
    6b1d:	0f 84 be fc ff ff    	je     67e1 <__write_data_page+0xe1>
		mapping_set_error(page->mapping, -EIO);
    6b23:	49 8b 5c 24 18       	mov    0x18(%r12),%rbx
		__filemap_set_wb_err(mapping, err);
    6b28:	be fb ff ff ff       	mov    $0xfffffffb,%esi
    6b2d:	48 89 df             	mov    %rbx,%rdi
    6b30:	e8 00 00 00 00       	callq  6b35 <__write_data_page+0x435>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    6b35:	f0 80 4b 78 01       	lock orb $0x1,0x78(%rbx)
		if (S_ISDIR(inode->i_mode))
    6b3a:	41 0f b7 06          	movzwl (%r14),%eax
    6b3e:	89 c1                	mov    %eax,%ecx
    6b40:	66 81 e1 00 f0       	and    $0xf000,%cx
    6b45:	66 81 f9 00 40       	cmp    $0x4000,%cx
    6b4a:	0f 85 82 fe ff ff    	jne    69d2 <__write_data_page+0x2d2>
	redirty_page_for_writepage(wbc, page);
    6b50:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
    6b57:	4c 89 e6             	mov    %r12,%rsi
		return AOP_WRITEPAGE_ACTIVATE;
    6b5a:	41 bf 00 00 08 00    	mov    $0x80000,%r15d
	redirty_page_for_writepage(wbc, page);
    6b60:	e8 00 00 00 00       	callq  6b65 <__write_data_page+0x465>
	if (!err || wbc->for_reclaim)
    6b65:	e9 3a ff ff ff       	jmpq   6aa4 <__write_data_page+0x3a4>
	__submit_merged_write_cond(sbi, inode, ino, idx, type, false);
    6b6a:	49 8b 4c 24 20       	mov    0x20(%r12),%rcx
    6b6f:	45 31 c9             	xor    %r9d,%r9d
    6b72:	45 31 c0             	xor    %r8d,%r8d
    6b75:	31 d2                	xor    %edx,%edx
    6b77:	4c 89 f6             	mov    %r14,%rsi
    6b7a:	4c 89 ef             	mov    %r13,%rdi
    6b7d:	e8 6e a1 ff ff       	callq  cf0 <__submit_merged_write_cond>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6b82:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (test_bit(flag, &F2FS_I(inode)->flags))
    6b89:	a9 00 00 00 02       	test   $0x2000000,%eax
    6b8e:	74 09                	je     6b99 <__write_data_page+0x499>
		asm volatile(LOCK_PREFIX "andb %1,%0"
    6b90:	f0 41 80 a6 7b 02 00 	lock andb $0xfd,0x27b(%r14)
    6b97:	00 fd 
		f2fs_remove_dirty_inode(inode);
    6b99:	4c 89 f7             	mov    %r14,%rdi
    6b9c:	e8 00 00 00 00       	callq  6ba1 <__write_data_page+0x4a1>
		submitted = NULL;
    6ba1:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
    6ba8:	00 00 00 00 
    6bac:	e9 a9 fe ff ff       	jmpq   6a5a <__write_data_page+0x35a>
										  f2fs_available_free_memory(sbi, BASE_CHECK))))
    6bb1:	be 06 00 00 00       	mov    $0x6,%esi
    6bb6:	4c 89 ef             	mov    %r13,%rdi
    6bb9:	e8 00 00 00 00       	callq  6bbe <__write_data_page+0x4be>
										 (!wbc->for_reclaim &&
    6bbe:	84 c0                	test   %al,%al
    6bc0:	75 8e                	jne    6b50 <__write_data_page+0x450>
	if (S_ISDIR(inode->i_mode)) {
    6bc2:	41 0f b7 06          	movzwl (%r14),%eax
    6bc6:	66 25 00 f0          	and    $0xf000,%ax
    6bca:	66 3d 00 40          	cmp    $0x4000,%ax
    6bce:	0f 84 03 02 00 00    	je     6dd7 <__write_data_page+0x6d7>
	if (!wbc->for_reclaim)
    6bd4:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    6bdb:	f6 40 24 08          	testb  $0x8,0x24(%rax)
    6bdf:	0f 85 1d fd ff ff    	jne    6902 <__write_data_page+0x202>
		need_balance_fs = true;
    6be5:	bb 01 00 00 00       	mov    $0x1,%ebx
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    6bea:	49 8b 86 78 02 00 00 	mov    0x278(%r14),%rax
	if (f2fs_has_inline_data(inode)) {
    6bf1:	f6 c4 04             	test   $0x4,%ah
    6bf4:	74 66                	je     6c5c <__write_data_page+0x55c>
		err = f2fs_write_inline_data(inode, page);
    6bf6:	4c 89 e6             	mov    %r12,%rsi
    6bf9:	4c 89 f7             	mov    %r14,%rdi
    6bfc:	e8 00 00 00 00       	callq  6c01 <__write_data_page+0x501>
    6c01:	41 89 c7             	mov    %eax,%r15d
		if (!err)
    6c04:	85 c0                	test   %eax,%eax
    6c06:	0f 84 a4 00 00 00    	je     6cb0 <__write_data_page+0x5b0>
	if (err == -EAGAIN) {
    6c0c:	83 f8 f5             	cmp    $0xfffffff5,%eax
    6c0f:	74 4b                	je     6c5c <__write_data_page+0x55c>
	F2FS_I(inode)->i_advise |= type;
    6c11:	41 80 8e 60 02 00 00 	orb    $0x10,0x260(%r14)
    6c18:	10 
	f2fs_mark_inode_dirty_sync(inode, true);
    6c19:	be 01 00 00 00       	mov    $0x1,%esi
    6c1e:	4c 89 f7             	mov    %r14,%rdi
    6c21:	e8 00 00 00 00       	callq  6c26 <__write_data_page+0x526>
	if (err && err != -ENOENT)
    6c26:	41 8d 47 02          	lea    0x2(%r15),%eax
    6c2a:	83 e0 fd             	and    $0xfffffffd,%eax
    6c2d:	0f 84 ca 00 00 00    	je     6cfd <__write_data_page+0x5fd>
    6c33:	f3 0f 1e fa          	endbr64 
	redirty_page_for_writepage(wbc, page);
    6c37:	48 8b 9d 68 ff ff ff 	mov    -0x98(%rbp),%rbx
    6c3e:	4c 89 e6             	mov    %r12,%rsi
    6c41:	48 89 df             	mov    %rbx,%rdi
    6c44:	e8 00 00 00 00       	callq  6c49 <__write_data_page+0x549>
	if (!err || wbc->for_reclaim)
    6c49:	f6 43 24 08          	testb  $0x8,0x24(%rbx)
    6c4d:	75 7b                	jne    6cca <__write_data_page+0x5ca>
	unlock_page(page);
    6c4f:	4c 89 e7             	mov    %r12,%rdi
    6c52:	e8 00 00 00 00       	callq  6c57 <__write_data_page+0x557>
	return err;
    6c57:	e9 48 fe ff ff       	jmpq   6aa4 <__write_data_page+0x3a4>
		err = f2fs_do_write_data_page(&fio);
    6c5c:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
    6c63:	e8 00 00 00 00       	callq  6c68 <__write_data_page+0x568>
    6c68:	41 89 c7             	mov    %eax,%r15d
		if (err == -EAGAIN) {
    6c6b:	83 f8 f5             	cmp    $0xfffffff5,%eax
    6c6e:	0f 84 7e 01 00 00    	je     6df2 <__write_data_page+0x6f2>
	if (err) {
    6c74:	45 85 ff             	test   %r15d,%r15d
    6c77:	75 98                	jne    6c11 <__write_data_page+0x511>
	loff_t psize = (page->index + 1) << PAGE_SHIFT;
    6c79:	4c 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%r15
		down_write(&F2FS_I(inode)->i_sem);
    6c80:	49 8d be 80 02 00 00 	lea    0x280(%r14),%rdi
    6c87:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
    6c8e:	e8 00 00 00 00       	callq  6c93 <__write_data_page+0x593>
	loff_t psize = (page->index + 1) << PAGE_SHIFT;
    6c93:	49 83 c7 01          	add    $0x1,%r15
		if (F2FS_I(inode)->last_disk_size < psize)
    6c97:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
	loff_t psize = (page->index + 1) << PAGE_SHIFT;
    6c9e:	49 c1 e7 0c          	shl    $0xc,%r15
		if (F2FS_I(inode)->last_disk_size < psize)
    6ca2:	4d 39 be d0 02 00 00 	cmp    %r15,0x2d0(%r14)
    6ca9:	7c 49                	jl     6cf4 <__write_data_page+0x5f4>
		up_write(&F2FS_I(inode)->i_sem);
    6cab:	e8 00 00 00 00       	callq  6cb0 <__write_data_page+0x5b0>
	if (err && err != -ENOENT)
    6cb0:	41 0f b7 06          	movzwl (%r14),%eax
    6cb4:	89 c1                	mov    %eax,%ecx
    6cb6:	66 81 e1 00 f0       	and    $0xf000,%cx
    6cbb:	e9 14 fd ff ff       	jmpq   69d4 <__write_data_page+0x2d4>
		return REQ_SYNC;
    6cc0:	b8 00 08 00 00       	mov    $0x800,%eax
    6cc5:	e9 e2 fa ff ff       	jmpq   67ac <__write_data_page+0xac>
		return AOP_WRITEPAGE_ACTIVATE;
    6cca:	41 bf 00 00 08 00    	mov    $0x80000,%r15d
    6cd0:	e9 cf fd ff ff       	jmpq   6aa4 <__write_data_page+0x3a4>
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    6cd5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
    6cdb:	45 31 c0             	xor    %r8d,%r8d
    6cde:	31 c9                	xor    %ecx,%ecx
    6ce0:	31 d2                	xor    %edx,%edx
    6ce2:	31 f6                	xor    %esi,%esi
    6ce4:	4c 89 ef             	mov    %r13,%rdi
	return 0;
    6ce7:	45 31 ff             	xor    %r15d,%r15d
	__submit_merged_write_cond(sbi, NULL, 0, 0, type, true);
    6cea:	e8 01 a0 ff ff       	callq  cf0 <__submit_merged_write_cond>
	if (submitted)
    6cef:	e9 b0 fd ff ff       	jmpq   6aa4 <__write_data_page+0x3a4>
			F2FS_I(inode)->last_disk_size = psize;
    6cf4:	4d 89 be d0 02 00 00 	mov    %r15,0x2d0(%r14)
    6cfb:	eb ae                	jmp    6cab <__write_data_page+0x5ab>
    6cfd:	f3 0f 1e fa          	endbr64 
	if (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode) &&
    6d01:	41 0f b7 06          	movzwl (%r14),%eax
    6d05:	89 c2                	mov    %eax,%edx
    6d07:	66 81 e2 00 d0       	and    $0xd000,%dx
    6d0c:	66 81 fa 00 80       	cmp    $0x8000,%dx
    6d11:	0f 84 d5 fc ff ff    	je     69ec <__write_data_page+0x2ec>
    6d17:	89 c2                	mov    %eax,%edx
    6d19:	66 81 e2 00 f0       	and    $0xf000,%dx
    6d1e:	66 81 fa 00 40       	cmp    $0x4000,%dx
    6d23:	0f 84 c3 fc ff ff    	je     69ec <__write_data_page+0x2ec>
    6d29:	e9 02 fd ff ff       	jmpq   6a30 <__write_data_page+0x330>
    6d2e:	41 8b 95 80 04 00 00 	mov    0x480(%r13),%edx
    6d35:	41 8b 85 74 04 00 00 	mov    0x474(%r13),%eax
	return (struct curseg_info *)(SM_I(sbi)->curseg_array + type);
    6d3c:	4c 8b 47 18          	mov    0x18(%rdi),%r8
	unsigned int node_blocks = get_pages(sbi, F2FS_DIRTY_NODES) +
    6d40:	01 d0                	add    %edx,%eax
    6d42:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
    6d48:	41 8b 85 74 04 00 00 	mov    0x474(%r13),%eax
    6d4f:	49 8d 90 fc 02 00 00 	lea    0x2fc(%r8),%rdx
    6d56:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
    6d5d:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
	return &sit_i->sentries[segno];
    6d63:	48 8b 07             	mov    (%rdi),%rax
    6d66:	4c 89 85 38 ff ff ff 	mov    %r8,-0xc8(%rbp)
    6d6d:	48 8b 78 68          	mov    0x68(%rax),%rdi
    6d71:	49 8d 80 ac 01 00 00 	lea    0x1ac(%r8),%rax
    6d78:	8b 10                	mov    (%rax),%edx
		left_blocks = sbi->blocks_per_seg -
    6d7a:	41 89 c8             	mov    %ecx,%r8d
			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
    6d7d:	48 8d 14 92          	lea    (%rdx,%rdx,4),%rdx
    6d81:	0f b7 54 d7 02       	movzwl 0x2(%rdi,%rdx,8),%edx
    6d86:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
		left_blocks = sbi->blocks_per_seg -
    6d8c:	41 29 d0             	sub    %edx,%r8d
		if (node_blocks > left_blocks)
    6d8f:	44 39 85 4c ff ff ff 	cmp    %r8d,-0xb4(%rbp)
    6d96:	0f 87 b6 fb ff ff    	ja     6952 <__write_data_page+0x252>
	for (i = CURSEG_HOT_NODE; i <= CURSEG_COLD_NODE; i++) {
    6d9c:	48 83 c0 70          	add    $0x70,%rax
    6da0:	48 3b 85 40 ff ff ff 	cmp    -0xc0(%rbp),%rax
    6da7:	75 cf                	jne    6d78 <__write_data_page+0x678>
    6da9:	4c 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%r8
	left_blocks = sbi->blocks_per_seg -
    6db0:	89 ca                	mov    %ecx,%edx
	return &sit_i->sentries[segno];
    6db2:	41 8b 40 5c          	mov    0x5c(%r8),%eax
			get_seg_entry(sbi, segno)->ckpt_valid_blocks;
    6db6:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    6dba:	0f b7 44 c7 02       	movzwl 0x2(%rdi,%rax,8),%eax
    6dbf:	25 ff 03 00 00       	and    $0x3ff,%eax
	left_blocks = sbi->blocks_per_seg -
    6dc4:	29 c2                	sub    %eax,%edx
	if (dent_blocks > left_blocks)
    6dc6:	39 95 48 ff ff ff    	cmp    %edx,-0xb8(%rbp)
    6dcc:	0f 86 d3 fb ff ff    	jbe    69a5 <__write_data_page+0x2a5>
    6dd2:	e9 7b fb ff ff       	jmpq   6952 <__write_data_page+0x252>
		err = f2fs_do_write_data_page(&fio);
    6dd7:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
		fio.need_lock = LOCK_DONE;
    6dde:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%rbp)
		err = f2fs_do_write_data_page(&fio);
    6de5:	e8 00 00 00 00       	callq  6dea <__write_data_page+0x6ea>
    6dea:	41 89 c7             	mov    %eax,%r15d
		goto done;
    6ded:	e9 34 fe ff ff       	jmpq   6c26 <__write_data_page+0x526>
			err = f2fs_do_write_data_page(&fio);
    6df2:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
			fio.need_lock = LOCK_REQ;
    6df9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
			err = f2fs_do_write_data_page(&fio);
    6e00:	e8 00 00 00 00       	callq  6e05 <__write_data_page+0x705>
    6e05:	41 89 c7             	mov    %eax,%r15d
    6e08:	e9 67 fe ff ff       	jmpq   6c74 <__write_data_page+0x574>
    6e0d:	c7 03 00 00 00 00    	movl   $0x0,(%rbx)
    6e13:	c7 44 0b fc 00 00 00 	movl   $0x0,-0x4(%rbx,%rcx,1)
    6e1a:	00 
    6e1b:	e9 7d fa ff ff       	jmpq   689d <__write_data_page+0x19d>
}
    6e20:	e8 00 00 00 00       	callq  6e25 <__write_data_page+0x725>
    6e25:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    6e2c:	00 00 00 00 

0000000000006e30 <f2fs_write_cache_pages>:
								  enum iostat_type io_type) {
    6e30:	e8 00 00 00 00       	callq  6e35 <f2fs_write_cache_pages+0x5>
    6e35:	55                   	push   %rbp
	return pagevec_lookup_range_tag(pvec, mapping, index, (pgoff_t)-1, tag);
}

static inline void pagevec_init(struct pagevec *pvec)
{
	pvec->nr = 0;
    6e36:	45 31 c0             	xor    %r8d,%r8d
    6e39:	48 89 e5             	mov    %rsp,%rbp
    6e3c:	41 57                	push   %r15
    6e3e:	41 56                	push   %r14
    6e40:	41 55                	push   %r13
    6e42:	49 89 fd             	mov    %rdi,%r13
    6e45:	41 54                	push   %r12
    6e47:	49 89 f4             	mov    %rsi,%r12
    6e4a:	53                   	push   %rbx
    6e4b:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    6e52:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%rbp)
    6e58:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    6e5f:	00 00 
    6e61:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6e65:	31 c0                	xor    %eax,%eax
	return F2FS_I_SB(mapping->host);
    6e67:	48 8b 07             	mov    (%rdi),%rax
    6e6a:	66 44 89 85 50 ff ff 	mov    %r8w,-0xb0(%rbp)
    6e71:	ff 
	return sb->s_fs_info;
    6e72:	48 8b 50 28          	mov    0x28(%rax),%rdx
    6e76:	48 8b 8a 08 04 00 00 	mov    0x408(%rdx),%rcx
    6e7d:	48 89 8d 38 ff ff ff 	mov    %rcx,-0xc8(%rbp)
		SM_I(F2FS_M_SB(mapping))->min_hot_blocks)
    6e84:	48 8b 49 68          	mov    0x68(%rcx),%rcx
    6e88:	8b 90 a8 02 00 00    	mov    0x2a8(%rax),%edx
	if (get_dirty_pages(mapping->host) <=
    6e8e:	39 91 8c 00 00 00    	cmp    %edx,0x8c(%rcx)
    6e94:	48 8b 90 78 02 00 00 	mov    0x278(%rax),%rdx
    6e9b:	0f 82 90 03 00 00    	jb     7231 <f2fs_write_cache_pages+0x401>
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    6ea1:	f7 c2 00 00 00 02    	test   $0x2000000,%edx
    6ea7:	0f 84 9d 03 00 00    	je     724a <f2fs_write_cache_pages+0x41a>
	if (wbc->range_cyclic) {
    6ead:	41 0f b6 54 24 24    	movzbl 0x24(%r12),%edx
    6eb3:	f6 c2 10             	test   $0x10,%dl
    6eb6:	0f 84 1f 03 00 00    	je     71db <f2fs_write_cache_pages+0x3ab>
	int range_whole = 0;
    6ebc:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
    6ec3:	00 00 00 
		writeback_index = mapping->writeback_index; /* prev offset */
    6ec6:	4d 8b 75 68          	mov    0x68(%r13),%r14
		if (index == 0)
    6eca:	31 c0                	xor    %eax,%eax
		end = -1;
    6ecc:	48 c7 85 20 ff ff ff 	movq   $0xffffffffffffffff,-0xe0(%rbp)
    6ed3:	ff ff ff ff 
		if (index == 0)
    6ed7:	4d 85 f6             	test   %r14,%r14
		index = writeback_index;
    6eda:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
		if (index == 0)
    6ee1:	0f 94 c0             	sete   %al
    6ee4:	4c 89 b5 00 ff ff ff 	mov    %r14,-0x100(%rbp)
    6eeb:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
		tag = PAGECACHE_TAG_TOWRITE;
    6ef1:	c7 85 14 ff ff ff 02 	movl   $0x2,-0xec(%rbp)
    6ef8:	00 00 00 
	if (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)
    6efb:	41 8b 44 24 20       	mov    0x20(%r12),%eax
    6f00:	83 f8 01             	cmp    $0x1,%eax
    6f03:	74 10                	je     6f15 <f2fs_write_cache_pages+0xe5>
		tag = PAGECACHE_TAG_DIRTY;
    6f05:	31 c9                	xor    %ecx,%ecx
    6f07:	83 e2 04             	and    $0x4,%edx
    6f0a:	0f 95 c1             	setne  %cl
    6f0d:	01 c9                	add    %ecx,%ecx
    6f0f:	89 8d 14 ff ff ff    	mov    %ecx,-0xec(%rbp)
	retry:
    6f15:	48 c7 85 18 ff ff ff 	movq   $0xffffffffffffffff,-0xe8(%rbp)
    6f1c:	ff ff ff ff 
    6f20:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%rbp)
    6f27:	00 00 00 
	if (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)
    6f2a:	83 f8 01             	cmp    $0x1,%eax
    6f2d:	0f 84 b4 01 00 00    	je     70e7 <f2fs_write_cache_pages+0x2b7>
    6f33:	41 f6 44 24 24 04    	testb  $0x4,0x24(%r12)
    6f39:	0f 85 a8 01 00 00    	jne    70e7 <f2fs_write_cache_pages+0x2b7>
	while (!done && (index <= end)) {
    6f3f:	4c 3b b5 20 ff ff ff 	cmp    -0xe0(%rbp),%r14
    6f46:	0f 87 0b 02 00 00    	ja     7157 <f2fs_write_cache_pages+0x327>
		nr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end,
    6f4c:	44 8b 85 14 ff ff ff 	mov    -0xec(%rbp),%r8d
    6f53:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    6f5a:	4c 89 ee             	mov    %r13,%rsi
    6f5d:	48 8d 95 48 ff ff ff 	lea    -0xb8(%rbp),%rdx
    6f64:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
    6f6b:	e8 00 00 00 00       	callq  6f70 <f2fs_write_cache_pages+0x140>
		if (nr_pages == 0)
    6f70:	85 c0                	test   %eax,%eax
    6f72:	0f 84 df 01 00 00    	je     7157 <f2fs_write_cache_pages+0x327>
		for (i = 0; i < nr_pages; i++) {
    6f78:	0f 8e 56 01 00 00    	jle    70d4 <f2fs_write_cache_pages+0x2a4>
    6f7e:	83 e8 01             	sub    $0x1,%eax
    6f81:	48 8d 9d 58 ff ff ff 	lea    -0xa8(%rbp),%rbx
    6f88:	48 8d 84 c5 60 ff ff 	lea    -0xa0(%rbp,%rax,8),%rax
    6f8f:	ff 
    6f90:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
    6f97:	eb 60                	jmp    6ff9 <f2fs_write_cache_pages+0x1c9>
			ret = __write_data_page(page, &submitted, wbc, io_type);
    6f99:	8b 8d 28 ff ff ff    	mov    -0xd8(%rbp),%ecx
    6f9f:	4c 89 e2             	mov    %r12,%rdx
    6fa2:	48 8d b5 47 ff ff ff 	lea    -0xb9(%rbp),%rsi
    6fa9:	4c 89 ff             	mov    %r15,%rdi
    6fac:	e8 4f f7 ff ff       	callq  6700 <__write_data_page>
    6fb1:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
			if (unlikely(ret)) {
    6fb7:	85 c0                	test   %eax,%eax
    6fb9:	0f 85 e9 01 00 00    	jne    71a8 <f2fs_write_cache_pages+0x378>
			} else if (submitted) {
    6fbf:	80 bd 47 ff ff ff 00 	cmpb   $0x0,-0xb9(%rbp)
    6fc6:	74 0b                	je     6fd3 <f2fs_write_cache_pages+0x1a3>
				last_idx = page->index;
    6fc8:	49 8b 47 20          	mov    0x20(%r15),%rax
    6fcc:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
			if (--wbc->nr_to_write <= 0 &&
    6fd3:	49 8b 04 24          	mov    (%r12),%rax
    6fd7:	48 83 e8 01          	sub    $0x1,%rax
    6fdb:	49 89 04 24          	mov    %rax,(%r12)
    6fdf:	48 85 c0             	test   %rax,%rax
    6fe2:	0f 8e 1d 01 00 00    	jle    7105 <f2fs_write_cache_pages+0x2d5>
		for (i = 0; i < nr_pages; i++) {
    6fe8:	48 83 c3 08          	add    $0x8,%rbx
    6fec:	48 3b 9d 30 ff ff ff 	cmp    -0xd0(%rbp),%rbx
    6ff3:	0f 84 db 00 00 00    	je     70d4 <f2fs_write_cache_pages+0x2a4>
    6ff9:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
			struct page *page = pvec.pages[i];
    7000:	4c 8b 3b             	mov    (%rbx),%r15
			bool submitted = false;
    7003:	c6 85 47 ff ff ff 00 	movb   $0x0,-0xb9(%rbp)
    700a:	8b 80 c0 04 00 00    	mov    0x4c0(%rax),%eax
			if (atomic_read(&sbi->wb_sync_req[DATA]) &&
    7010:	85 c0                	test   %eax,%eax
    7012:	74 0d                	je     7021 <f2fs_write_cache_pages+0x1f1>
    7014:	41 8b 7c 24 20       	mov    0x20(%r12),%edi
    7019:	85 ff                	test   %edi,%edi
    701b:	0f 84 f1 00 00 00    	je     7112 <f2fs_write_cache_pages+0x2e2>
			done_index = page->index;
    7021:	4d 8b 77 20          	mov    0x20(%r15),%r14
	might_sleep();
    7025:	e8 00 00 00 00       	callq  702a <f2fs_write_cache_pages+0x1fa>
    702a:	49 8b 57 08          	mov    0x8(%r15),%rdx
    702e:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    7032:	83 e2 01             	and    $0x1,%edx
    7035:	49 0f 44 c7          	cmove  %r15,%rax
	GEN_BINARY_RMWcc(LOCK_PREFIX __ASM_SIZE(bts),
    7039:	f0 48 0f ba 28 00    	lock btsq $0x0,(%rax)
	if (!trylock_page(page))
    703f:	0f 82 54 01 00 00    	jb     7199 <f2fs_write_cache_pages+0x369>
			if (unlikely(page->mapping != mapping)) {
    7045:	4d 39 6f 18          	cmp    %r13,0x18(%r15)
    7049:	75 70                	jne    70bb <f2fs_write_cache_pages+0x28b>
    704b:	49 8b 57 08          	mov    0x8(%r15),%rdx
    704f:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    7053:	83 e2 01             	and    $0x1,%edx
    7056:	49 0f 44 c7          	cmove  %r15,%rax
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    705a:	48 8b 00             	mov    (%rax),%rax
			if (!PageDirty(page)) {
    705d:	a8 10                	test   $0x10,%al
    705f:	74 5a                	je     70bb <f2fs_write_cache_pages+0x28b>
    7061:	49 8b 57 08          	mov    0x8(%r15),%rdx
    7065:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    7069:	83 e2 01             	and    $0x1,%edx
    706c:	49 0f 44 c7          	cmove  %r15,%rax
    7070:	48 8b 00             	mov    (%rax),%rax
			if (PageWriteback(page)) {
    7073:	f6 c4 40             	test   $0x40,%ah
    7076:	74 18                	je     7090 <f2fs_write_cache_pages+0x260>
				if (wbc->sync_mode != WB_SYNC_NONE)
    7078:	41 8b 74 24 20       	mov    0x20(%r12),%esi
    707d:	85 f6                	test   %esi,%esi
    707f:	74 3a                	je     70bb <f2fs_write_cache_pages+0x28b>
					f2fs_wait_on_page_writeback(page,
    7081:	ba 01 00 00 00       	mov    $0x1,%edx
    7086:	31 f6                	xor    %esi,%esi
    7088:	4c 89 ff             	mov    %r15,%rdi
    708b:	e8 00 00 00 00       	callq  7090 <f2fs_write_cache_pages+0x260>
    7090:	49 8b 57 08          	mov    0x8(%r15),%rdx
    7094:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    7098:	83 e2 01             	and    $0x1,%edx
    709b:	49 0f 44 c7          	cmove  %r15,%rax
    709f:	48 8b 00             	mov    (%rax),%rax
			BUG_ON(PageWriteback(page));
    70a2:	f6 c4 40             	test   $0x40,%ah
    70a5:	0f 85 fb 00 00 00    	jne    71a6 <f2fs_write_cache_pages+0x376>
			if (!clear_page_dirty_for_io(page))
    70ab:	4c 89 ff             	mov    %r15,%rdi
    70ae:	e8 00 00 00 00       	callq  70b3 <f2fs_write_cache_pages+0x283>
    70b3:	85 c0                	test   %eax,%eax
    70b5:	0f 85 de fe ff ff    	jne    6f99 <f2fs_write_cache_pages+0x169>
				unlock_page(page);
    70bb:	4c 89 ff             	mov    %r15,%rdi
    70be:	48 83 c3 08          	add    $0x8,%rbx
    70c2:	e8 00 00 00 00       	callq  70c7 <f2fs_write_cache_pages+0x297>
		for (i = 0; i < nr_pages; i++) {
    70c7:	48 3b 9d 30 ff ff ff 	cmp    -0xd0(%rbp),%rbx
    70ce:	0f 85 25 ff ff ff    	jne    6ff9 <f2fs_write_cache_pages+0x1c9>
	pvec->nr = 0;
}

static inline unsigned pagevec_count(struct pagevec *pvec)
{
	return pvec->nr;
    70d4:	45 31 ff             	xor    %r15d,%r15d
	return pagevec_space(pvec);
}

static inline void pagevec_release(struct pagevec *pvec)
{
	if (pagevec_count(pvec))
    70d7:	80 bd 50 ff ff ff 00 	cmpb   $0x0,-0xb0(%rbp)
    70de:	bb 01 00 00 00       	mov    $0x1,%ebx
    70e3:	74 4e                	je     7133 <f2fs_write_cache_pages+0x303>
    70e5:	eb 40                	jmp    7127 <f2fs_write_cache_pages+0x2f7>
		tag_pages_for_writeback(mapping, index, end);
    70e7:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
    70ee:	4c 89 f6             	mov    %r14,%rsi
    70f1:	4c 89 ef             	mov    %r13,%rdi
    70f4:	e8 00 00 00 00       	callq  70f9 <f2fs_write_cache_pages+0x2c9>
    70f9:	4c 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%r14
    7100:	e9 3a fe ff ff       	jmpq   6f3f <f2fs_write_cache_pages+0x10f>
			if (--wbc->nr_to_write <= 0 &&
    7105:	41 8b 4c 24 20       	mov    0x20(%r12),%ecx
    710a:	85 c9                	test   %ecx,%ecx
    710c:	0f 85 d6 fe ff ff    	jne    6fe8 <f2fs_write_cache_pages+0x1b8>
    7112:	80 bd 50 ff ff ff 00 	cmpb   $0x0,-0xb0(%rbp)
    7119:	0f 84 6f 01 00 00    	je     728e <f2fs_write_cache_pages+0x45e>
    711f:	31 db                	xor    %ebx,%ebx
    7121:	41 bf 01 00 00 00    	mov    $0x1,%r15d
		__pagevec_release(pvec);
    7127:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
    712e:	e8 00 00 00 00       	callq  7133 <f2fs_write_cache_pages+0x303>
		cond_resched();
    7133:	e8 00 00 00 00       	callq  7138 <f2fs_write_cache_pages+0x308>
	while (!done && (index <= end)) {
    7138:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    713f:	48 39 85 48 ff ff ff 	cmp    %rax,-0xb8(%rbp)
    7146:	77 08                	ja     7150 <f2fs_write_cache_pages+0x320>
    7148:	84 db                	test   %bl,%bl
    714a:	0f 85 fc fd ff ff    	jne    6f4c <f2fs_write_cache_pages+0x11c>
    7150:	44 09 bd 10 ff ff ff 	or     %r15d,-0xf0(%rbp)
	if (!cycled && !done) {
    7157:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
    715d:	85 d2                	test   %edx,%edx
    715f:	0f 85 2e 01 00 00    	jne    7293 <f2fs_write_cache_pages+0x463>
		end = writeback_index - 1;
    7165:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
		goto retry;
    716c:	45 31 f6             	xor    %r14d,%r14d
		index = 0;
    716f:	48 c7 85 48 ff ff ff 	movq   $0x0,-0xb8(%rbp)
    7176:	00 00 00 00 
		cycled = 1;
    717a:	c7 85 10 ff ff ff 01 	movl   $0x1,-0xf0(%rbp)
    7181:	00 00 00 
		end = writeback_index - 1;
    7184:	48 83 e8 01          	sub    $0x1,%rax
    7188:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
		goto retry;
    718f:	41 8b 44 24 20       	mov    0x20(%r12),%eax
    7194:	e9 91 fd ff ff       	jmpq   6f2a <f2fs_write_cache_pages+0xfa>
		__lock_page(page);
    7199:	4c 89 ff             	mov    %r15,%rdi
    719c:	e8 00 00 00 00       	callq  71a1 <f2fs_write_cache_pages+0x371>
    71a1:	e9 9f fe ff ff       	jmpq   7045 <f2fs_write_cache_pages+0x215>
			BUG_ON(PageWriteback(page));
    71a6:	0f 0b                	ud2    
				if (ret == AOP_WRITEPAGE_ACTIVATE) {
    71a8:	3d 00 00 08 00       	cmp    $0x80000,%eax
    71ad:	0f 84 c4 00 00 00    	je     7277 <f2fs_write_cache_pages+0x447>
				} else if (ret == -EAGAIN) {
    71b3:	83 bd 2c ff ff ff f5 	cmpl   $0xfffffff5,-0xd4(%rbp)
    71ba:	0f 85 40 01 00 00    	jne    7300 <f2fs_write_cache_pages+0x4d0>
					if (wbc->sync_mode == WB_SYNC_ALL) {
    71c0:	41 83 7c 24 20 01    	cmpl   $0x1,0x20(%r12)
    71c6:	0f 84 8b 00 00 00    	je     7257 <f2fs_write_cache_pages+0x427>
					ret = 0;
    71cc:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%rbp)
    71d3:	00 00 00 
    71d6:	e9 0d fe ff ff       	jmpq   6fe8 <f2fs_write_cache_pages+0x1b8>
		end = wbc->range_end >> PAGE_SHIFT;
    71db:	49 8b 44 24 18       	mov    0x18(%r12),%rax
		index = wbc->range_start >> PAGE_SHIFT;
    71e0:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
		cycled = 1; /* ignore range_cyclic tests */
    71e5:	c7 85 10 ff ff ff 01 	movl   $0x1,-0xf0(%rbp)
    71ec:	00 00 00 
		end = wbc->range_end >> PAGE_SHIFT;
    71ef:	48 89 c6             	mov    %rax,%rsi
		index = wbc->range_start >> PAGE_SHIFT;
    71f2:	49 89 ce             	mov    %rcx,%r14
		end = wbc->range_end >> PAGE_SHIFT;
    71f5:	48 c1 fe 0c          	sar    $0xc,%rsi
		index = wbc->range_start >> PAGE_SHIFT;
    71f9:	49 c1 fe 0c          	sar    $0xc,%r14
		if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
    71fd:	48 85 c9             	test   %rcx,%rcx
		end = wbc->range_end >> PAGE_SHIFT;
    7200:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
		if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
    7207:	0f 94 c1             	sete   %cl
    720a:	48 be ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rsi
    7211:	ff ff 7f 
    7214:	48 39 f0             	cmp    %rsi,%rax
		index = wbc->range_start >> PAGE_SHIFT;
    7217:	4c 89 b5 48 ff ff ff 	mov    %r14,-0xb8(%rbp)
		if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
    721e:	0f 94 c0             	sete   %al
    7221:	0f b6 c0             	movzbl %al,%eax
	int range_whole = 0;
    7224:	21 c8                	and    %ecx,%eax
    7226:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    722c:	e9 c0 fc ff ff       	jmpq   6ef1 <f2fs_write_cache_pages+0xc1>
	if (test_bit(flag, &F2FS_I(inode)->flags))
    7231:	f7 c2 00 00 00 02    	test   $0x2000000,%edx
    7237:	0f 84 70 fc ff ff    	je     6ead <f2fs_write_cache_pages+0x7d>
		asm volatile(LOCK_PREFIX "andb %1,%0"
    723d:	f0 80 a0 7b 02 00 00 	lock andb $0xfd,0x27b(%rax)
    7244:	fd 
    7245:	e9 63 fc ff ff       	jmpq   6ead <f2fs_write_cache_pages+0x7d>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    724a:	f0 80 88 7b 02 00 00 	lock orb $0x2,0x27b(%rax)
    7251:	02 
    7252:	e9 56 fc ff ff       	jmpq   6ead <f2fs_write_cache_pages+0x7d>
						cond_resched();
    7257:	e8 00 00 00 00       	callq  725c <f2fs_write_cache_pages+0x42c>
						congestion_wait(BLK_RW_ASYNC,
    725c:	be 05 00 00 00       	mov    $0x5,%esi
    7261:	31 ff                	xor    %edi,%edi
    7263:	e8 00 00 00 00       	callq  7268 <f2fs_write_cache_pages+0x438>
					ret = 0;
    7268:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%rbp)
    726f:	00 00 00 
						goto retry_write;
    7272:	e9 ae fd ff ff       	jmpq   7025 <f2fs_write_cache_pages+0x1f5>
					unlock_page(page);
    7277:	4c 89 ff             	mov    %r15,%rdi
    727a:	e8 00 00 00 00       	callq  727f <f2fs_write_cache_pages+0x44f>
					ret = 0;
    727f:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%rbp)
    7286:	00 00 00 
					continue;
    7289:	e9 5a fd ff ff       	jmpq   6fe8 <f2fs_write_cache_pages+0x1b8>
		cond_resched();
    728e:	e8 00 00 00 00       	callq  7293 <f2fs_write_cache_pages+0x463>
	if (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))
    7293:	41 f6 44 24 24 10    	testb  $0x10,0x24(%r12)
    7299:	75 11                	jne    72ac <f2fs_write_cache_pages+0x47c>
    729b:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
    72a1:	85 c0                	test   %eax,%eax
    72a3:	74 0b                	je     72b0 <f2fs_write_cache_pages+0x480>
    72a5:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
    72aa:	7e 04                	jle    72b0 <f2fs_write_cache_pages+0x480>
		mapping->writeback_index = done_index;
    72ac:	4d 89 75 68          	mov    %r14,0x68(%r13)
	if (last_idx != ULONG_MAX)
    72b0:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
    72b7:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
    72bb:	74 1c                	je     72d9 <f2fs_write_cache_pages+0x4a9>
		f2fs_submit_merged_write_cond(F2FS_M_SB(mapping), mapping->host,
    72bd:	49 8b 75 00          	mov    0x0(%r13),%rsi
	__submit_merged_write_cond(sbi, inode, ino, idx, type, false);
    72c1:	45 31 c9             	xor    %r9d,%r9d
    72c4:	45 31 c0             	xor    %r8d,%r8d
    72c7:	31 d2                	xor    %edx,%edx
	return sb->s_fs_info;
    72c9:	48 8b 46 28          	mov    0x28(%rsi),%rax
    72cd:	48 8b b8 08 04 00 00 	mov    0x408(%rax),%rdi
    72d4:	e8 17 9a ff ff       	callq  cf0 <__submit_merged_write_cond>
}
    72d9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    72dd:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    72e4:	00 00 
    72e6:	75 25                	jne    730d <f2fs_write_cache_pages+0x4dd>
    72e8:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
    72ee:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    72f5:	5b                   	pop    %rbx
    72f6:	41 5c                	pop    %r12
    72f8:	41 5d                	pop    %r13
    72fa:	41 5e                	pop    %r14
    72fc:	41 5f                	pop    %r15
    72fe:	5d                   	pop    %rbp
    72ff:	c3                   	retq   
				done_index = page->index + 1;
    7300:	4d 8b 77 20          	mov    0x20(%r15),%r14
    7304:	49 83 c6 01          	add    $0x1,%r14
				break;
    7308:	e9 05 fe ff ff       	jmpq   7112 <f2fs_write_cache_pages+0x2e2>
}
    730d:	e8 00 00 00 00       	callq  7312 <f2fs_write_cache_pages+0x4e2>
    7312:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
    7319:	00 00 00 00 
    731d:	0f 1f 00             	nopl   (%rax)

0000000000007320 <f2fs_write_data_pages>:
								 struct writeback_control *wbc) {
    7320:	f3 0f 1e fa          	endbr64 
    7324:	e8 00 00 00 00       	callq  7329 <f2fs_write_data_pages+0x9>
    7329:	55                   	push   %rbp
    732a:	48 89 e5             	mov    %rsp,%rbp
    732d:	41 57                	push   %r15
    732f:	41 56                	push   %r14
	return __f2fs_write_data_pages(mapping, wbc,
    7331:	45 31 f6             	xor    %r14d,%r14d
								 struct writeback_control *wbc) {
    7334:	41 55                	push   %r13
    7336:	41 54                	push   %r12
    7338:	53                   	push   %rbx
    7339:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    733d:	48 83 ec 50          	sub    $0x50,%rsp
	struct inode *inode = mapping->host;
    7341:	4c 8b 2f             	mov    (%rdi),%r13
								 struct writeback_control *wbc) {
    7344:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    734b:	00 00 
    734d:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    7352:	31 c0                	xor    %eax,%eax
    7354:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
    735b:	00 00 
	return __f2fs_write_data_pages(mapping, wbc,
    735d:	49 39 85 c0 02 00 00 	cmp    %rax,0x2c0(%r13)
	if (!mapping->a_ops->writepage)
    7364:	48 8b 47 70          	mov    0x70(%rdi),%rax
	return __f2fs_write_data_pages(mapping, wbc,
    7368:	41 0f 94 c6          	sete   %r14b
	if (!mapping->a_ops->writepage)
    736c:	48 83 38 00          	cmpq   $0x0,(%rax)
	return __f2fs_write_data_pages(mapping, wbc,
    7370:	47 8d 74 b6 04       	lea    0x4(%r14,%r14,4),%r14d
	if (!mapping->a_ops->writepage)
    7375:	0f 84 00 01 00 00    	je     747b <f2fs_write_data_pages+0x15b>
    737b:	41 8b 85 a8 02 00 00 	mov    0x2a8(%r13),%eax
    7382:	49 89 fc             	mov    %rdi,%r12
    7385:	48 89 f3             	mov    %rsi,%rbx
	if (!get_dirty_pages(inode) && wbc->sync_mode == WB_SYNC_NONE)
    7388:	85 c0                	test   %eax,%eax
    738a:	0f 84 14 01 00 00    	je     74a4 <f2fs_write_data_pages+0x184>
    7390:	49 8b 45 28          	mov    0x28(%r13),%rax
    7394:	4c 8b b8 08 04 00 00 	mov    0x408(%rax),%r15
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    739b:	49 8b 47 48          	mov    0x48(%r15),%rax
	if (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))
    739f:	a8 08                	test   $0x8,%al
    73a1:	0f 85 c4 00 00 00    	jne    746b <f2fs_write_data_pages+0x14b>
	if (S_ISDIR(inode->i_mode) && wbc->sync_mode == WB_SYNC_NONE &&
    73a7:	41 0f b7 45 00       	movzwl 0x0(%r13),%eax
    73ac:	66 25 00 f0          	and    $0xf000,%ax
    73b0:	66 3d 00 40          	cmp    $0x4000,%ax
    73b4:	74 6d                	je     7423 <f2fs_write_data_pages+0x103>
    73b6:	49 8b 85 78 02 00 00 	mov    0x278(%r13),%rax
	if (is_inode_flag_set(inode, FI_DO_DEFRAG))
    73bd:	a9 00 00 40 00       	test   $0x400000,%eax
    73c2:	0f 85 a3 00 00 00    	jne    746b <f2fs_write_data_pages+0x14b>
    73c8:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	if (wbc->sync_mode == WB_SYNC_ALL)
    73cd:	83 7b 20 01          	cmpl   $0x1,0x20(%rbx)
    73d1:	0f 84 3b 01 00 00    	je     7512 <f2fs_write_data_pages+0x1f2>
    73d7:	41 8b 87 c0 04 00 00 	mov    0x4c0(%r15),%eax
	else if (atomic_read(&sbi->wb_sync_req[DATA]))
    73de:	85 c0                	test   %eax,%eax
    73e0:	0f 85 85 00 00 00    	jne    746b <f2fs_write_data_pages+0x14b>
	blk_start_plug(&plug);
    73e6:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    73eb:	e8 00 00 00 00       	callq  73f0 <f2fs_write_data_pages+0xd0>
	ret = f2fs_write_cache_pages(mapping, wbc, io_type);
    73f0:	4c 89 e7             	mov    %r12,%rdi
    73f3:	44 89 f2             	mov    %r14d,%edx
    73f6:	48 89 de             	mov    %rbx,%rsi
    73f9:	e8 32 fa ff ff       	callq  6e30 <f2fs_write_cache_pages>
	blk_finish_plug(&plug);
    73fe:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
	ret = f2fs_write_cache_pages(mapping, wbc, io_type);
    7403:	41 89 c4             	mov    %eax,%r12d
	blk_finish_plug(&plug);
    7406:	e8 00 00 00 00       	callq  740b <f2fs_write_data_pages+0xeb>
	if (wbc->sync_mode == WB_SYNC_ALL)
    740b:	83 7b 20 01          	cmpl   $0x1,0x20(%rbx)
    740f:	75 08                	jne    7419 <f2fs_write_data_pages+0xf9>
    7411:	f0 41 ff 8f c0 04 00 	lock decl 0x4c0(%r15)
    7418:	00 
	f2fs_remove_dirty_inode(inode);
    7419:	4c 89 ef             	mov    %r13,%rdi
    741c:	e8 00 00 00 00       	callq  7421 <f2fs_write_data_pages+0x101>
	return ret;
    7421:	eb 5b                	jmp    747e <f2fs_write_data_pages+0x15e>
	if (S_ISDIR(inode->i_mode) && wbc->sync_mode == WB_SYNC_NONE &&
    7423:	8b 73 20             	mov    0x20(%rbx),%esi
    7426:	85 f6                	test   %esi,%esi
    7428:	75 8c                	jne    73b6 <f2fs_write_data_pages+0x96>
 * 512 pages (2MB) * 8 for nodes, and
 * 256 pages * 8 for meta are set.
 */
static inline int nr_pages_to_skip(struct f2fs_sb_info *sbi, int type)
{
	if (sbi->sb->s_bdi->wb.dirty_exceeded)
    742a:	49 8b 07             	mov    (%r15),%rax
    742d:	41 8b 95 a8 02 00 00 	mov    0x2a8(%r13),%edx
    7434:	48 8b 88 d8 00 00 00 	mov    0xd8(%rax),%rcx
		return 0;
    743b:	31 c0                	xor    %eax,%eax
	if (sbi->sb->s_bdi->wb.dirty_exceeded)
    743d:	8b 89 c8 01 00 00    	mov    0x1c8(%rcx),%ecx
    7443:	85 c9                	test   %ecx,%ecx
    7445:	75 07                	jne    744e <f2fs_write_data_pages+0x12e>

	if (type == DATA)
		return sbi->blocks_per_seg;
    7447:	41 8b 87 24 04 00 00 	mov    0x424(%r15),%eax
    744e:	39 c2                	cmp    %eax,%edx
    7450:	0f 8d 60 ff ff ff    	jge    73b6 <f2fs_write_data_pages+0x96>
		f2fs_available_free_memory(sbi, DIRTY_DENTS))
    7456:	be 02 00 00 00       	mov    $0x2,%esi
    745b:	4c 89 ff             	mov    %r15,%rdi
    745e:	e8 00 00 00 00       	callq  7463 <f2fs_write_data_pages+0x143>
		get_dirty_pages(inode) < nr_pages_to_skip(sbi, DATA) &&
    7463:	84 c0                	test   %al,%al
    7465:	0f 84 4b ff ff ff    	je     73b6 <f2fs_write_data_pages+0x96>
    746b:	49 63 85 a8 02 00 00 	movslq 0x2a8(%r13),%rax
	wbc->pages_skipped += get_dirty_pages(inode);
    7472:	48 01 43 08          	add    %rax,0x8(%rbx)
    7476:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	return 0;
    747b:	45 31 e4             	xor    %r12d,%r12d
}
    747e:	48 8b 44 24 48       	mov    0x48(%rsp),%rax
    7483:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    748a:	00 00 
    748c:	0f 85 df 00 00 00    	jne    7571 <f2fs_write_data_pages+0x251>
    7492:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    7496:	44 89 e0             	mov    %r12d,%eax
    7499:	5b                   	pop    %rbx
    749a:	41 5c                	pop    %r12
    749c:	41 5d                	pop    %r13
    749e:	41 5e                	pop    %r14
    74a0:	41 5f                	pop    %r15
    74a2:	5d                   	pop    %rbp
    74a3:	c3                   	retq   
	if (!get_dirty_pages(inode) && wbc->sync_mode == WB_SYNC_NONE)
    74a4:	8b 7e 20             	mov    0x20(%rsi),%edi
    74a7:	85 ff                	test   %edi,%edi
    74a9:	0f 85 e1 fe ff ff    	jne    7390 <f2fs_write_data_pages+0x70>
    74af:	eb ca                	jmp    747b <f2fs_write_data_pages+0x15b>
TRACE_EVENT(f2fs_writepages,
    74b1:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 74b8 <f2fs_write_data_pages+0x198>
    74b8:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    74ba:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 74c2 <f2fs_write_data_pages+0x1a2>
    74c1:	00 
    74c2:	0f 83 05 ff ff ff    	jae    73cd <f2fs_write_data_pages+0xad>
	trace_f2fs_writepages(mapping->host, wbc, DATA);
    74c8:	49 8b 04 24          	mov    (%r12),%rax
    74cc:	48 89 04 24          	mov    %rax,(%rsp)
    74d0:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 74d7 <f2fs_write_data_pages+0x1b7>
    74d7:	48 85 c0             	test   %rax,%rax
    74da:	74 2c                	je     7508 <f2fs_write_data_pages+0x1e8>
    74dc:	4c 8b 08             	mov    (%rax),%r9
    74df:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
    74e4:	48 8b 78 08          	mov    0x8(%rax),%rdi
    74e8:	31 c9                	xor    %ecx,%ecx
    74ea:	48 89 da             	mov    %rbx,%rdx
    74ed:	48 8b 34 24          	mov    (%rsp),%rsi
    74f1:	e8 00 00 00 00       	callq  74f6 <f2fs_write_data_pages+0x1d6>
    74f6:	48 8b 44 24 08       	mov    0x8(%rsp),%rax
    74fb:	4c 8b 48 18          	mov    0x18(%rax),%r9
    74ff:	48 83 c0 18          	add    $0x18,%rax
    7503:	4d 85 c9             	test   %r9,%r9
    7506:	75 d7                	jne    74df <f2fs_write_data_pages+0x1bf>
	if (wbc->sync_mode == WB_SYNC_ALL)
    7508:	83 7b 20 01          	cmpl   $0x1,0x20(%rbx)
    750c:	0f 85 c5 fe ff ff    	jne    73d7 <f2fs_write_data_pages+0xb7>
	asm volatile(LOCK_PREFIX "incl %0"
    7512:	f0 41 ff 87 c0 04 00 	lock incl 0x4c0(%r15)
    7519:	00 

static __always_inline void atomic_inc(atomic_t *v)
{
	kasan_check_write(v, sizeof(*v));
	arch_atomic_inc(v);
}
    751a:	e9 c7 fe ff ff       	jmpq   73e6 <f2fs_write_data_pages+0xc6>
    751f:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 7526 <f2fs_write_data_pages+0x206>
    7526:	89 c0                	mov    %eax,%eax
    7528:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 7530 <f2fs_write_data_pages+0x210>
    752f:	00 
    7530:	0f 83 45 ff ff ff    	jae    747b <f2fs_write_data_pages+0x15b>
	trace_f2fs_writepages(mapping->host, wbc, DATA);
    7536:	4d 8b 2c 24          	mov    (%r12),%r13
    753a:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 7541 <f2fs_write_data_pages+0x221>
    7541:	4d 85 e4             	test   %r12,%r12
    7544:	74 23                	je     7569 <f2fs_write_data_pages+0x249>
    7546:	49 8b 04 24          	mov    (%r12),%rax
    754a:	49 8b 7c 24 08       	mov    0x8(%r12),%rdi
    754f:	49 83 c4 18          	add    $0x18,%r12
    7553:	31 c9                	xor    %ecx,%ecx
    7555:	48 89 da             	mov    %rbx,%rdx
    7558:	4c 89 ee             	mov    %r13,%rsi
    755b:	e8 00 00 00 00       	callq  7560 <f2fs_write_data_pages+0x240>
    7560:	49 8b 04 24          	mov    (%r12),%rax
    7564:	48 85 c0             	test   %rax,%rax
    7567:	75 e1                	jne    754a <f2fs_write_data_pages+0x22a>
	return 0;
    7569:	45 31 e4             	xor    %r12d,%r12d
    756c:	e9 0d ff ff ff       	jmpq   747e <f2fs_write_data_pages+0x15e>
}
    7571:	e8 00 00 00 00       	callq  7576 <f2fs_write_data_pages+0x256>
    7576:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    757d:	00 00 00 

0000000000007580 <f2fs_write_data_page>:
								struct writeback_control *wbc) {
    7580:	f3 0f 1e fa          	endbr64 
    7584:	e8 00 00 00 00       	callq  7589 <f2fs_write_data_page+0x9>
    7589:	55                   	push   %rbp
    758a:	48 89 f2             	mov    %rsi,%rdx
	return __write_data_page(page, NULL, wbc, FS_DATA_IO);
    758d:	b9 04 00 00 00       	mov    $0x4,%ecx
    7592:	31 f6                	xor    %esi,%esi
								struct writeback_control *wbc) {
    7594:	48 89 e5             	mov    %rsp,%rbp
	return __write_data_page(page, NULL, wbc, FS_DATA_IO);
    7597:	e8 64 f1 ff ff       	callq  6700 <__write_data_page>
}
    759c:	5d                   	pop    %rbp
    759d:	c3                   	retq   
    759e:	66 90                	xchg   %ax,%ax

00000000000075a0 <f2fs_clear_radix_tree_dirty_tag>:
#ifdef CONFIG_MIGRATION
		.migratepage    = f2fs_migrate_page,
#endif
};

void f2fs_clear_radix_tree_dirty_tag(struct page *page) {
    75a0:	f3 0f 1e fa          	endbr64 
    75a4:	e8 00 00 00 00       	callq  75a9 <f2fs_clear_radix_tree_dirty_tag+0x9>
    75a9:	55                   	push   %rbp
    75aa:	48 89 e5             	mov    %rsp,%rbp
    75ad:	41 56                	push   %r14
    75af:	41 55                	push   %r13
    75b1:	41 54                	push   %r12
    75b3:	49 89 fc             	mov    %rdi,%r12
	struct address_space *mapping = page_mapping(page);
    75b6:	e8 00 00 00 00       	callq  75bb <f2fs_clear_radix_tree_dirty_tag+0x1b>
	return &lock->rlock;
    75bb:	4c 8d 68 08          	lea    0x8(%rax),%r13
	unsigned long flags;

	xa_lock_irqsave(&mapping->i_pages, flags);
    75bf:	4c 89 ef             	mov    %r13,%rdi
    75c2:	e8 00 00 00 00       	callq  75c7 <f2fs_clear_radix_tree_dirty_tag+0x27>
    75c7:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    75cc:	49 89 c6             	mov    %rax,%r14
    75cf:	48 8d 42 ff          	lea    -0x1(%rdx),%rax
    75d3:	83 e2 01             	and    $0x1,%edx
    75d6:	49 0f 44 c4          	cmove  %r12,%rax
    75da:	48 8b 48 08          	mov    0x8(%rax),%rcx
    75de:	48 8d 51 ff          	lea    -0x1(%rcx),%rdx
    75e2:	83 e1 01             	and    $0x1,%ecx
    75e5:	48 0f 44 d0          	cmove  %rax,%rdx
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    75e9:	48 8b 12             	mov    (%rdx),%rdx
	return PageSwapBacked(page) && test_bit(PG_swapcache, &page->flags);
    75ec:	f7 c2 00 00 04 00    	test   $0x40000,%edx
    75f2:	74 08                	je     75fc <f2fs_clear_radix_tree_dirty_tag+0x5c>
    75f4:	48 8b 00             	mov    (%rax),%rax
    75f7:	f6 c4 02             	test   $0x2,%ah
    75fa:	75 22                	jne    761e <f2fs_clear_radix_tree_dirty_tag+0x7e>
 */
static inline pgoff_t page_index(struct page *page)
{
	if (unlikely(PageSwapCache(page)))
		return __page_file_index(page);
	return page->index;
    75fc:	49 8b 74 24 20       	mov    0x20(%r12),%rsi
	radix_tree_tag_clear(&mapping->i_pages, page_index(page),
    7601:	4c 89 ef             	mov    %r13,%rdi
    7604:	31 d2                	xor    %edx,%edx
    7606:	e8 00 00 00 00       	callq  760b <f2fs_clear_radix_tree_dirty_tag+0x6b>
	raw_spin_unlock_irq(&lock->rlock);
}

static __always_inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
    760b:	4c 89 f6             	mov    %r14,%rsi
    760e:	4c 89 ef             	mov    %r13,%rdi
    7611:	e8 00 00 00 00       	callq  7616 <f2fs_clear_radix_tree_dirty_tag+0x76>
						 PAGECACHE_TAG_DIRTY);
	xa_unlock_irqrestore(&mapping->i_pages, flags);
}
    7616:	41 5c                	pop    %r12
    7618:	41 5d                	pop    %r13
    761a:	41 5e                	pop    %r14
    761c:	5d                   	pop    %rbp
    761d:	c3                   	retq   
		return __page_file_index(page);
    761e:	4c 89 e7             	mov    %r12,%rdi
    7621:	e8 00 00 00 00       	callq  7626 <f2fs_clear_radix_tree_dirty_tag+0x86>
    7626:	48 89 c6             	mov    %rax,%rsi
    7629:	eb d6                	jmp    7601 <f2fs_clear_radix_tree_dirty_tag+0x61>

Disassembly of section .text.unlikely:

0000000000000000 <f2fs_map_blocks.cold>:
	pgofs = (pgoff_t) map->m_lblk;// 映射区域内第一个块的文件内部逻辑块偏移量，文件内写起始位置
       0:	8b 46 04             	mov    0x4(%rsi),%eax
       3:	49 89 fc             	mov    %rdi,%r12
	printk(KERN_INFO"ZN trap: 2");
       6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
       d:	49 89 f6             	mov    %rsi,%r14
	map->m_len = 0;
      10:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
      17:	00 
	pgofs = (pgoff_t) map->m_lblk;// 映射区域内第一个块的文件内部逻辑块偏移量，文件内写起始位置
      18:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
      1f:	49 89 c5             	mov    %rax,%r13
	end = pgofs + maxblocks;// 映射区域的最后一个文件内部逻辑块偏移量
      22:	48 01 d8             	add    %rbx,%rax
      25:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
      2b:	89 95 78 ff ff ff    	mov    %edx,-0x88(%rbp)
      31:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	printk(KERN_INFO"ZN trap: 2");
      38:	e8 00 00 00 00       	callq  3d <f2fs_map_blocks.cold+0x3d>
	if (!create && f2fs_lookup_extent_cache(inode, pgofs, &ei)) {
      3d:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
      44:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
      4b:	45 85 d2             	test   %r10d,%r10d
      4e:	75 74                	jne    c4 <f2fs_map_blocks.cold+0xc4>
      50:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
      57:	48 8d 55 84          	lea    -0x7c(%rbp),%rdx
      5b:	4c 89 e7             	mov    %r12,%rdi
      5e:	e8 00 00 00 00       	callq  63 <f2fs_map_blocks.cold+0x63>
      63:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
      6a:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
      71:	84 c0                	test   %al,%al
      73:	74 4f                	je     c4 <f2fs_map_blocks.cold+0xc4>
		map->m_pblk = ei.blk + pgofs - ei.fofs;
      75:	8b 55 8c             	mov    -0x74(%rbp),%edx
      78:	8b 45 84             	mov    -0x7c(%rbp),%eax
		map->m_flags = F2FS_MAP_MAPPED;
      7b:	41 c7 46 0c 20 00 00 	movl   $0x20,0xc(%r14)
      82:	00 
		map->m_pblk = ei.blk + pgofs - ei.fofs;
      83:	44 01 ea             	add    %r13d,%edx
      86:	29 c2                	sub    %eax,%edx
		map->m_len = min((pgoff_t) maxblocks, ei.fofs + ei.len - pgofs);
      88:	03 45 88             	add    -0x78(%rbp),%eax
      8b:	48 2b 85 58 ff ff ff 	sub    -0xa8(%rbp),%rax
      92:	48 39 d8             	cmp    %rbx,%rax
		map->m_pblk = ei.blk + pgofs - ei.fofs;
      95:	41 89 16             	mov    %edx,(%r14)
		map->m_len = min((pgoff_t) maxblocks, ei.fofs + ei.len - pgofs);
      98:	48 0f 46 d8          	cmovbe %rax,%rbx
		if (map->m_next_extent)
      9c:	49 8b 46 18          	mov    0x18(%r14),%rax
		map->m_len = min((pgoff_t) maxblocks, ei.fofs + ei.len - pgofs);
      a0:	41 89 5e 08          	mov    %ebx,0x8(%r14)
		if (map->m_next_extent)
      a4:	48 85 c0             	test   %rax,%rax
      a7:	0f 84 ee 01 00 00    	je     29b <f2fs_map_blocks.cold+0x29b>
			*map->m_next_extent = pgofs + map->m_len;
      ad:	48 03 9d 58 ff ff ff 	add    -0xa8(%rbp),%rbx
	int err = 0, ofs = 1;
      b4:	45 31 ed             	xor    %r13d,%r13d
			*map->m_next_extent = pgofs + map->m_len;
      b7:	48 89 18             	mov    %rbx,(%rax)
      ba:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
      bf:	e9 00 00 00 00       	jmpq   c4 <f2fs_map_blocks.cold+0xc4>
	int mode = create ? ALLOC_NODE : LOOKUP_NODE;
      c4:	45 85 d2             	test   %r10d,%r10d
	printk(KERN_INFO"ZN trap: 3");
      c7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
      ce:	44 89 9d 50 ff ff ff 	mov    %r11d,-0xb0(%rbp)
	int mode = create ? ALLOC_NODE : LOOKUP_NODE;
      d5:	0f 94 c0             	sete   %al
      d8:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
      df:	0f b6 c0             	movzbl %al,%eax
      e2:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
	printk(KERN_INFO"ZN trap: 3");
      e8:	e8 00 00 00 00       	callq  ed <f2fs_map_blocks.cold+0xed>
      ed:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
	down_read(&sbi->cp_rwsem);
      f4:	49 8d 87 b0 01 00 00 	lea    0x1b0(%r15),%rax
      fb:	44 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%r11d
     102:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
	int err = 0, ofs = 1;
     109:	c7 85 34 ff ff ff 01 	movl   $0x1,-0xcc(%rbp)
     110:	00 00 00 
     113:	65 48 8b 04 25 00 00 	mov    %gs:0x0,%rax
     11a:	00 00 
     11c:	4c 89 bd 70 ff ff ff 	mov    %r15,-0x90(%rbp)
     123:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
     12a:	44 89 95 64 ff ff ff 	mov    %r10d,-0x9c(%rbp)
     131:	4c 89 a5 68 ff ff ff 	mov    %r12,-0x98(%rbp)
     138:	45 89 dc             	mov    %r11d,%r12d
	if (create)
     13b:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%rbp)
     142:	74 1d                	je     161 <f2fs_map_blocks.cold+0x161>
	if (flag == F2FS_GET_BLOCK_PRE_AIO) {
     144:	41 83 fc 04          	cmp    $0x4,%r12d
     148:	0f 85 5c 04 00 00    	jne    5aa <f2fs_map_blocks.cold+0x5aa>
			down_read(&sbi->node_change);
     14e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
     155:	48 8d b8 00 02 00 00 	lea    0x200(%rax),%rdi
     15c:	e8 00 00 00 00       	callq  161 <f2fs_map_blocks.cold+0x161>
     161:	31 c0                	xor    %eax,%eax
     163:	b9 04 00 00 00       	mov    $0x4,%ecx
     168:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
	printk(KERN_INFO"ZN trap: index/pgofs = %d",pgofs);
     16c:	48 8b 9d 58 ff ff ff 	mov    -0xa8(%rbp),%rbx
     173:	f3 ab                	rep stos %eax,%es:(%rdi)
	dn->inode = inode;
     175:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     17c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	dn->inode_page = ipage;
     183:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     18a:	00 
     18b:	48 89 de             	mov    %rbx,%rsi
	dn->node_page = npage;
     18e:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
     195:	00 
	dn->inode = inode;
     196:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	dn->nid = nid;
     19a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     1a1:	e8 00 00 00 00       	callq  1a6 <f2fs_map_blocks.cold+0x1a6>
	err = f2fs_get_dnode_of_data(&dn, pgofs, mode);// 获取映射区域第一个块所属的dnode
     1a6:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
     1ac:	48 89 de             	mov    %rbx,%rsi
     1af:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
     1b3:	e8 00 00 00 00       	callq  1b8 <f2fs_map_blocks.cold+0x1b8>
     1b8:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
	if (err) {
     1be:	85 c0                	test   %eax,%eax
     1c0:	0f 84 dd 00 00 00    	je     2a3 <f2fs_map_blocks.cold+0x2a3>
     1c6:	45 89 e3             	mov    %r12d,%r11d
     1c9:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     1d0:	41 89 c5             	mov    %eax,%r13d
     1d3:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     1da:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
		if (flag == F2FS_GET_BLOCK_BMAP)
     1e1:	41 83 fb 02          	cmp    $0x2,%r11d
     1e5:	75 07                	jne    1ee <f2fs_map_blocks.cold+0x1ee>
			map->m_pblk = 0;
     1e7:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
		if (err == -ENOENT) {
     1ee:	41 83 fd fe          	cmp    $0xfffffffe,%r13d
     1f2:	75 77                	jne    26b <f2fs_map_blocks.cold+0x26b>
			if (map->m_next_pgofs)
     1f4:	49 8b 5e 10          	mov    0x10(%r14),%rbx
     1f8:	48 85 db             	test   %rbx,%rbx
     1fb:	74 2f                	je     22c <f2fs_map_blocks.cold+0x22c>
						f2fs_get_next_page_offset(&dn, pgofs);
     1fd:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
     204:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
     208:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     20f:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
     216:	e8 00 00 00 00       	callq  21b <f2fs_map_blocks.cold+0x21b>
				*map->m_next_pgofs =
     21b:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     222:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
     229:	48 89 03             	mov    %rax,(%rbx)
			if (map->m_next_extent)
     22c:	49 8b 5e 18          	mov    0x18(%r14),%rbx
     230:	48 85 db             	test   %rbx,%rbx
     233:	0f 84 51 03 00 00    	je     58a <f2fs_map_blocks.cold+0x58a>
						f2fs_get_next_page_offset(&dn, pgofs);
     239:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
     240:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
			err = 0;
     244:	45 31 ed             	xor    %r13d,%r13d
     247:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     24e:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
						f2fs_get_next_page_offset(&dn, pgofs);
     255:	e8 00 00 00 00       	callq  25a <f2fs_map_blocks.cold+0x25a>
     25a:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
     261:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
				*map->m_next_extent =
     268:	48 89 03             	mov    %rax,(%rbx)
	if (create) {
     26b:	45 85 d2             	test   %r10d,%r10d
     26e:	0f 84 46 fe ff ff    	je     ba <f2fs_map_blocks.cold+0xba>
	if (flag == F2FS_GET_BLOCK_PRE_AIO) {
     274:	41 83 fb 04          	cmp    $0x4,%r11d
     278:	0f 84 9c 03 00 00    	je     61a <f2fs_map_blocks.cold+0x61a>
	up_read(&sbi->cp_rwsem);
     27e:	49 8d bf b0 01 00 00 	lea    0x1b0(%r15),%rdi
     285:	e8 00 00 00 00       	callq  28a <f2fs_map_blocks.cold+0x28a>
		f2fs_balance_fs(sbi, dn.node_changed);
     28a:	0f b6 75 c1          	movzbl -0x3f(%rbp),%esi
     28e:	4c 89 ff             	mov    %r15,%rdi
     291:	e8 00 00 00 00       	callq  296 <f2fs_map_blocks.cold+0x296>
     296:	e9 1f fe ff ff       	jmpq   ba <f2fs_map_blocks.cold+0xba>
	int err = 0, ofs = 1;
     29b:	45 31 ed             	xor    %r13d,%r13d
     29e:	e9 17 fe ff ff       	jmpq   ba <f2fs_map_blocks.cold+0xba>
	return page_to_virt(page);
     2a3:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
	start_pgofs = pgofs;// 文件内部逻辑块偏移量
     2a7:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
	last_ofs_in_node = ofs_in_node = dn.ofs_in_node;// 映射区域内第一个块，在dnode内的偏移量
     2ad:	8b 4d bc             	mov    -0x44(%rbp),%ecx
     2b0:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2b7 <f2fs_map_blocks.cold+0x2b7>
     2b7:	4c 89 ca             	mov    %r9,%rdx
     2ba:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # 2c1 <f2fs_map_blocks.cold+0x2c1>
	start_pgofs = pgofs;// 文件内部逻辑块偏移量
     2c1:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
     2c7:	48 c1 fa 06          	sar    $0x6,%rdx
	last_ofs_in_node = ofs_in_node = dn.ofs_in_node;// 映射区域内第一个块，在dnode内的偏移量
     2cb:	89 8d 20 ff ff ff    	mov    %ecx,-0xe0(%rbp)
     2d1:	48 c1 e2 0c          	shl    $0xc,%rdx
	end_offset = ADDRS_PER_PAGE(dn.node_page, inode);// 映射区域内第一个dnode的最后一个块的逻辑块偏移量
     2d5:	8b 84 32 ec 0f 00 00 	mov    0xfec(%rdx,%rsi,1),%eax
     2dc:	39 84 32 e8 0f 00 00 	cmp    %eax,0xfe8(%rdx,%rsi,1)
     2e3:	0f 85 91 02 00 00    	jne    57a <f2fs_map_blocks.cold+0x57a>
	return CUR_ADDRS_PER_INODE(inode) - get_inline_xattr_addrs(inode);
     2e9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     2f0:	ba 9b 03 00 00       	mov    $0x39b,%edx
     2f5:	2b 90 10 04 00 00    	sub    0x410(%rax),%edx
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
     2fb:	48 63 80 08 04 00 00 	movslq 0x408(%rax),%rax
     302:	89 d3                	mov    %edx,%ebx
     304:	48 c1 e8 02          	shr    $0x2,%rax
     308:	29 c3                	sub    %eax,%ebx
     30a:	48 89 9d 48 ff ff ff 	mov    %rbx,-0xb8(%rbp)
     311:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
	last_ofs_in_node = ofs_in_node = dn.ofs_in_node;// 映射区域内第一个块，在dnode内的偏移量
     318:	89 8d 30 ff ff ff    	mov    %ecx,-0xd0(%rbp)
	prealloc = 0;
     31e:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
     325:	00 00 00 00 
     329:	48 83 c0 01          	add    $0x1,%rax
     32d:	44 89 a5 78 ff ff ff 	mov    %r12d,-0x88(%rbp)
     334:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
     33b:	4c 89 ca             	mov    %r9,%rdx
     33e:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # 345 <f2fs_map_blocks.cold+0x345>
     345:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
     34c:	48 c1 fa 06          	sar    $0x6,%rdx
	blkaddr = datablock_addr(dn.inode, dn.node_page, dn.ofs_in_node);// 映射区域内dnode的第一个块的磁盘块地址
     350:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
     354:	48 c1 e2 0c          	shl    $0xc,%rdx
     358:	48 83 e8 01          	sub    $0x1,%rax
     35c:	48 01 f2             	add    %rsi,%rdx
     35f:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
	return RAW_IS_INODE(p);
     366:	8b b2 e8 0f 00 00    	mov    0xfe8(%rdx),%esi
     36c:	8b ba ec 0f 00 00    	mov    0xfec(%rdx),%edi
	if (is_inode) {
     372:	39 fe                	cmp    %edi,%esi
     374:	0f 85 71 02 00 00    	jne    5eb <f2fs_map_blocks.cold+0x5eb>
		if (!inode)
     37a:	4d 85 ff             	test   %r15,%r15
     37d:	0f 85 72 02 00 00    	jne    5f5 <f2fs_map_blocks.cold+0x5f5>
			(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;
     383:	f6 42 03 20          	testb  $0x20,0x3(%rdx)
     387:	0f 84 86 02 00 00    	je     613 <f2fs_map_blocks.cold+0x613>
     38d:	0f b7 82 68 01 00 00 	movzwl 0x168(%rdx),%eax
     394:	66 c1 e8 02          	shr    $0x2,%ax
     398:	0f b7 c0             	movzwl %ax,%eax
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
     39b:	4c 8d 9a 68 01 00 00 	lea    0x168(%rdx),%r11
	return le32_to_cpu(addr_array[base + offset]);
     3a2:	01 c8                	add    %ecx,%eax
     3a4:	41 8b 04 83          	mov    (%r11,%rax,4),%eax
	if (blkaddr == NEW_ADDR || blkaddr == NULL_ADDR)
     3a8:	44 8d 50 ff          	lea    -0x1(%rax),%r10d
     3ac:	41 83 fa fd          	cmp    $0xfffffffd,%r10d
     3b0:	0f 86 9c 02 00 00    	jbe    652 <f2fs_map_blocks.cold+0x652>
		if (create) {// 需要分配数据块，增加文件长度
     3b6:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%rbp)
     3bd:	0f 84 02 03 00 00    	je     6c5 <f2fs_map_blocks.cold+0x6c5>
	unsigned int ckpt_flags = le32_to_cpu(cp->ckpt_flags);
     3c3:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
     3ca:	4c 8b 8b 78 01 00 00 	mov    0x178(%rbx),%r9
			if (unlikely(f2fs_cp_error(sbi))) {
     3d1:	41 f6 81 84 00 00 00 	testb  $0x8,0x84(%r9)
     3d8:	08 
     3d9:	0f 84 4c 02 00 00    	je     62b <f2fs_map_blocks.cold+0x62b>
     3df:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     3e6:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
				err = -EIO;
     3ed:	41 bd fb ff ff ff    	mov    $0xfffffffb,%r13d
     3f3:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     3fa:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
	if (flag == F2FS_GET_BLOCK_PRECACHE) {
     401:	41 83 fb 05          	cmp    $0x5,%r11d
     405:	0f 85 18 04 00 00    	jne    823 <f2fs_map_blocks.cold+0x823>
		if (map->m_flags & F2FS_MAP_MAPPED) {
     40b:	41 f6 46 0c 20       	testb  $0x20,0xc(%r14)
     410:	74 44                	je     456 <f2fs_map_blocks.cold+0x456>
			unsigned int ofs = start_pgofs - map->m_lblk;
     412:	41 8b 46 04          	mov    0x4(%r14),%eax
			f2fs_update_extent_cache_range(&dn,
     416:	41 8b 4e 08          	mov    0x8(%r14),%ecx
     41a:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
     41e:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     425:	41 8b 16             	mov    (%r14),%edx
     428:	8b 9d 24 ff ff ff    	mov    -0xdc(%rbp),%ebx
     42e:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
     435:	01 c1                	add    %eax,%ecx
     437:	8b b5 58 ff ff ff    	mov    -0xa8(%rbp),%esi
     43d:	29 c2                	sub    %eax,%edx
     43f:	29 d9                	sub    %ebx,%ecx
     441:	01 da                	add    %ebx,%edx
     443:	e8 00 00 00 00       	callq  448 <f2fs_map_blocks.cold+0x448>
     448:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     44f:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
		if (map->m_next_extent)
     456:	49 8b 46 18          	mov    0x18(%r14),%rax
     45a:	48 85 c0             	test   %rax,%rax
     45d:	0f 84 c0 03 00 00    	je     823 <f2fs_map_blocks.cold+0x823>
			*map->m_next_extent = pgofs + 1;
     463:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
     46a:	48 83 c2 01          	add    $0x1,%rdx
     46e:	48 89 10             	mov    %rdx,(%rax)
     471:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
	if (dn->node_page)
     475:	4c 89 cb             	mov    %r9,%rbx
     478:	4d 85 c9             	test   %r9,%r9
     47b:	0f 84 ab 03 00 00    	je     82c <f2fs_map_blocks.cold+0x82c>
     481:	49 8b 41 08          	mov    0x8(%r9),%rax
	if (unlikely(head & 1))
     485:	a8 01                	test   $0x1,%al
     487:	0f 84 b1 03 00 00    	je     83e <f2fs_map_blocks.cold+0x83e>
		return (struct page *) (head - 1);
     48d:	48 83 e8 01          	sub    $0x1,%rax
     491:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     494:	a8 01                	test   $0x1,%al
     496:	75 19                	jne    4b1 <f2fs_map_blocks.cold+0x4b1>
     498:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     49a:	49 8b 41 18          	mov    0x18(%r9),%rax
	return F2FS_SB(inode->i_sb);
     49e:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     4a1:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     4a5:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     4ac:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
		unlock_page(page);
     4b1:	4c 89 cf             	mov    %r9,%rdi
     4b4:	44 89 9d 68 ff ff ff 	mov    %r11d,-0x98(%rbp)
     4bb:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
     4c2:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
     4c9:	e8 00 00 00 00       	callq  4ce <f2fs_map_blocks.cold+0x4ce>
     4ce:	4c 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%r9
	if (unlikely(head & 1))
     4d5:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
     4dc:	44 8b 9d 68 ff ff ff 	mov    -0x98(%rbp),%r11d
     4e3:	49 8b 41 08          	mov    0x8(%r9),%rax
     4e7:	a8 01                	test   $0x1,%al
     4e9:	74 04                	je     4ef <f2fs_map_blocks.cold+0x4ef>
		return (struct page *) (head - 1);
     4eb:	48 8d 58 ff          	lea    -0x1(%rax),%rbx
     4ef:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", e);
     4f4:	f0 ff 4b 34          	lock decl 0x34(%rbx)
	if (put_page_testzero(page))
     4f8:	75 24                	jne    51e <f2fs_map_blocks.cold+0x51e>
		__put_page(page);
     4fa:	48 89 df             	mov    %rbx,%rdi
     4fd:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     504:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
     50b:	e8 00 00 00 00       	callq  510 <f2fs_map_blocks.cold+0x510>
     510:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     517:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
	if (dn->inode_page && dn->node_page != dn->inode_page)
     51e:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
     522:	48 85 ff             	test   %rdi,%rdi
     525:	74 3e                	je     565 <f2fs_map_blocks.cold+0x565>
     527:	48 3b 7d b0          	cmp    -0x50(%rbp),%rdi
     52b:	74 38                	je     565 <f2fs_map_blocks.cold+0x565>
     52d:	48 8b 47 08          	mov    0x8(%rdi),%rax
	if (unlikely(head & 1))
     531:	a8 01                	test   $0x1,%al
     533:	74 04                	je     539 <f2fs_map_blocks.cold+0x539>
		return (struct page *) (head - 1);
     535:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
     539:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     53e:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
     542:	75 21                	jne    565 <f2fs_map_blocks.cold+0x565>
     544:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     54b:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
		__put_page(page);
     552:	e8 00 00 00 00       	callq  557 <f2fs_map_blocks.cold+0x557>
     557:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     55e:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
	dn->node_page = NULL;
     565:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
     56c:	00 
	dn->inode_page = NULL;
     56d:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     574:	00 
}
     575:	e9 f1 fc ff ff       	jmpq   26b <f2fs_map_blocks.cold+0x26b>
	end_offset = ADDRS_PER_PAGE(dn.node_page, inode);// 映射区域内第一个dnode的最后一个块的逻辑块偏移量
     57a:	48 c7 85 48 ff ff ff 	movq   $0x3fa,-0xb8(%rbp)
     581:	fa 03 00 00 
     585:	e9 87 fd ff ff       	jmpq   311 <f2fs_map_blocks.cold+0x311>
			err = 0;
     58a:	45 31 ed             	xor    %r13d,%r13d
     58d:	e9 d9 fc ff ff       	jmpq   26b <f2fs_map_blocks.cold+0x26b>
TRACE_EVENT(f2fs_map_blocks,
     592:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 599 <f2fs_map_blocks.cold+0x599>
     599:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
     59b:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 5a3 <f2fs_map_blocks.cold+0x5a3>
     5a2:	00 
     5a3:	72 16                	jb     5bb <f2fs_map_blocks.cold+0x5bb>
     5a5:	e9 00 00 00 00       	jmpq   5aa <f2fs_map_blocks.cold+0x5aa>
	down_read(&sbi->cp_rwsem);
     5aa:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
     5b1:	e8 00 00 00 00       	callq  5b6 <f2fs_map_blocks.cold+0x5b6>
}
     5b6:	e9 a6 fb ff ff       	jmpq   161 <f2fs_map_blocks.cold+0x161>
     5bb:	48 8b 1d 00 00 00 00 	mov    0x0(%rip),%rbx        # 5c2 <f2fs_map_blocks.cold+0x5c2>
     5c2:	48 85 db             	test   %rbx,%rbx
     5c5:	74 1f                	je     5e6 <f2fs_map_blocks.cold+0x5e6>
     5c7:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
     5cb:	48 8b 03             	mov    (%rbx),%rax
     5ce:	48 83 c3 18          	add    $0x18,%rbx
     5d2:	44 89 e9             	mov    %r13d,%ecx
     5d5:	4c 89 f2             	mov    %r14,%rdx
     5d8:	4c 89 e6             	mov    %r12,%rsi
     5db:	e8 00 00 00 00       	callq  5e0 <f2fs_map_blocks.cold+0x5e0>
     5e0:	48 83 3b 00          	cmpq   $0x0,(%rbx)
     5e4:	75 e1                	jne    5c7 <f2fs_map_blocks.cold+0x5c7>
	preempt_enable_notrace();
     5e6:	e9 00 00 00 00       	jmpq   5eb <f2fs_map_blocks.cold+0x5eb>
	return RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;
     5eb:	49 89 d3             	mov    %rdx,%r11
	int base = 0;
     5ee:	31 c0                	xor    %eax,%eax
     5f0:	e9 ad fd ff ff       	jmpq   3a2 <f2fs_map_blocks.cold+0x3a2>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     5f5:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
		else if (f2fs_has_extra_attr(inode))
     5fc:	a9 00 00 00 04       	test   $0x4000000,%eax
     601:	74 10                	je     613 <f2fs_map_blocks.cold+0x613>
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
     603:	49 63 87 08 04 00 00 	movslq 0x408(%r15),%rax
     60a:	48 c1 e8 02          	shr    $0x2,%rax
     60e:	e9 88 fd ff ff       	jmpq   39b <f2fs_map_blocks.cold+0x39b>
			(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;
     613:	31 c0                	xor    %eax,%eax
     615:	e9 81 fd ff ff       	jmpq   39b <f2fs_map_blocks.cold+0x39b>
			up_read(&sbi->node_change);
     61a:	49 8d bf 00 02 00 00 	lea    0x200(%r15),%rdi
     621:	e8 00 00 00 00       	callq  626 <f2fs_map_blocks.cold+0x626>
     626:	e9 5f fc ff ff       	jmpq   28a <f2fs_map_blocks.cold+0x28a>
			if (flag == F2FS_GET_BLOCK_PRE_AIO) {
     62b:	83 bd 78 ff ff ff 04 	cmpl   $0x4,-0x88(%rbp)
     632:	0f 85 fd 04 00 00    	jne    b35 <f2fs_map_blocks.cold+0xb35>
				if (blkaddr == NULL_ADDR) {
     638:	85 c0                	test   %eax,%eax
     63a:	75 0e                	jne    64a <f2fs_map_blocks.cold+0x64a>
					prealloc++;
     63c:	48 83 85 40 ff ff ff 	addq   $0x1,-0xc0(%rbp)
     643:	01 
					last_ofs_in_node = dn.ofs_in_node;
     644:	89 8d 30 ff ff ff    	mov    %ecx,-0xd0(%rbp)
			map->m_flags |= F2FS_MAP_NEW;
     64a:	41 83 4e 0c 40       	orl    $0x40,0xc(%r14)
			blkaddr = dn.data_blkaddr;// node的块地址赋给blkaddr,???。猜测：记录由于建立映射，导致新分配的数据块的位置
     64f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
	if (flag == F2FS_GET_BLOCK_PRE_AIO)
     652:	83 bd 78 ff ff ff 04 	cmpl   $0x4,-0x88(%rbp)
     659:	0f 85 a6 00 00 00    	jne    705 <f2fs_map_blocks.cold+0x705>
	dn.ofs_in_node++;// 处理dnode中的下一个数据块
     65f:	8b 45 bc             	mov    -0x44(%rbp),%eax
	if (flag == F2FS_GET_BLOCK_PRE_AIO &&
     662:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
	dn.ofs_in_node++;// 处理dnode中的下一个数据块
     669:	83 c0 01             	add    $0x1,%eax
     66c:	89 45 bc             	mov    %eax,-0x44(%rbp)
	if (flag == F2FS_GET_BLOCK_PRE_AIO &&
     66f:	48 39 b5 28 ff ff ff 	cmp    %rsi,-0xd8(%rbp)
     676:	0f 85 70 04 00 00    	jne    aec <f2fs_map_blocks.cold+0xaec>
		dn.ofs_in_node = ofs_in_node;
     67c:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
		err = f2fs_reserve_new_blocks(&dn, prealloc);// 预定 prealloc 个数据块
     682:	48 8b b5 40 ff ff ff 	mov    -0xc0(%rbp),%rsi
     689:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
		dn.ofs_in_node = ofs_in_node;
     68d:	89 45 bc             	mov    %eax,-0x44(%rbp)
		err = f2fs_reserve_new_blocks(&dn, prealloc);// 预定 prealloc 个数据块
     690:	e8 00 00 00 00       	callq  695 <f2fs_map_blocks.cold+0x695>
		if (err)
     695:	85 c0                	test   %eax,%eax
     697:	0f 84 36 01 00 00    	je     7d3 <f2fs_map_blocks.cold+0x7d3>
     69d:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     6a4:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
		err = f2fs_reserve_new_blocks(&dn, prealloc);// 预定 prealloc 个数据块
     6a8:	41 89 c5             	mov    %eax,%r13d
     6ab:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     6b2:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     6b9:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     6c0:	e9 b0 fd ff ff       	jmpq   475 <f2fs_map_blocks.cold+0x475>
			if (flag == F2FS_GET_BLOCK_BMAP) {
     6c5:	83 bd 78 ff ff ff 02 	cmpl   $0x2,-0x88(%rbp)
     6cc:	0f 84 15 02 00 00    	je     8e7 <f2fs_map_blocks.cold+0x8e7>
			if (flag == F2FS_GET_BLOCK_PRECACHE)
     6d2:	83 bd 78 ff ff ff 05 	cmpl   $0x5,-0x88(%rbp)
     6d9:	0f 84 33 02 00 00    	je     912 <f2fs_map_blocks.cold+0x912>
			if (flag == F2FS_GET_BLOCK_FIEMAP &&
     6df:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     6e6:	41 83 fb 01          	cmp    $0x1,%r11d
     6ea:	0f 85 46 02 00 00    	jne    936 <f2fs_map_blocks.cold+0x936>
     6f0:	85 c0                	test   %eax,%eax
     6f2:	0f 84 79 02 00 00    	je     971 <f2fs_map_blocks.cold+0x971>
			if (flag != F2FS_GET_BLOCK_FIEMAP) {
     6f8:	83 bd 78 ff ff ff 01 	cmpl   $0x1,-0x88(%rbp)
     6ff:	0f 85 31 02 00 00    	jne    936 <f2fs_map_blocks.cold+0x936>
	if (map->m_len == 0) {
     705:	41 8b 56 08          	mov    0x8(%r14),%edx
     709:	85 d2                	test   %edx,%edx
     70b:	75 6e                	jne    77b <f2fs_map_blocks.cold+0x77b>
		if (blkaddr == NEW_ADDR)
     70d:	41 8b 56 0c          	mov    0xc(%r14),%edx
     711:	83 f8 ff             	cmp    $0xffffffff,%eax
     714:	75 07                	jne    71d <f2fs_map_blocks.cold+0x71d>
			map->m_flags |= F2FS_MAP_UNWRITTEN;
     716:	80 ce 10             	or     $0x10,%dh
     719:	41 89 56 0c          	mov    %edx,0xc(%r14)
		map->m_flags |= F2FS_MAP_MAPPED;
     71d:	41 83 4e 0c 20       	orl    $0x20,0xc(%r14)
		map->m_pblk = blkaddr;// 记录映射区域内第一个数据块的磁盘块地址
     722:	41 89 06             	mov    %eax,(%r14)
		map->m_len = 1;// 记录当前映射区域的长度
     725:	41 c7 46 08 01 00 00 	movl   $0x1,0x8(%r14)
     72c:	00 
	dn.ofs_in_node++;// 处理dnode中的下一个数据块
     72d:	83 45 bc 01          	addl   $0x1,-0x44(%rbp)
	if (pgofs >= end)// 映射区域建立完成
     731:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
     738:	48 39 9d 28 ff ff ff 	cmp    %rbx,-0xd8(%rbp)
     73f:	0f 87 4c 02 00 00    	ja     991 <f2fs_map_blocks.cold+0x991>
     745:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
     74c:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     753:	44 8b ad 60 ff ff ff 	mov    -0xa0(%rbp),%r13d
     75a:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     761:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
     768:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     76f:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     776:	e9 86 fc ff ff       	jmpq   401 <f2fs_map_blocks.cold+0x401>
	} else if ((map->m_pblk != NEW_ADDR && blkaddr == (map->m_pblk + ofs)) ||
     77b:	41 8b 0e             	mov    (%r14),%ecx
     77e:	83 f9 ff             	cmp    $0xffffffff,%ecx
     781:	74 1a                	je     79d <f2fs_map_blocks.cold+0x79d>
     783:	03 8d 34 ff ff ff    	add    -0xcc(%rbp),%ecx
     789:	39 c1                	cmp    %eax,%ecx
     78b:	75 15                	jne    7a2 <f2fs_map_blocks.cold+0x7a2>
		map->m_len++;// 逐块检查，并加入到映射区域
     78d:	83 c2 01             	add    $0x1,%edx
		ofs++;
     790:	83 85 34 ff ff ff 01 	addl   $0x1,-0xcc(%rbp)
		map->m_len++;// 逐块检查，并加入到映射区域
     797:	41 89 56 08          	mov    %edx,0x8(%r14)
     79b:	eb 90                	jmp    72d <f2fs_map_blocks.cold+0x72d>
			   (map->m_pblk == NEW_ADDR && blkaddr == NEW_ADDR) ||
     79d:	83 c0 01             	add    $0x1,%eax
     7a0:	74 eb                	je     78d <f2fs_map_blocks.cold+0x78d>
     7a2:	83 bd 78 ff ff ff 03 	cmpl   $0x3,-0x88(%rbp)
     7a9:	74 e2                	je     78d <f2fs_map_blocks.cold+0x78d>
     7ab:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     7b2:	44 8b ad 60 ff ff ff 	mov    -0xa0(%rbp),%r13d
     7b9:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     7c0:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     7c7:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     7ce:	e9 2e fc ff ff       	jmpq   401 <f2fs_map_blocks.cold+0x401>
		map->m_len += dn.ofs_in_node - ofs_in_node;// 将预定成功的 prealloc 个数据块加入到映射区域
     7d3:	8b 45 bc             	mov    -0x44(%rbp),%eax
     7d6:	89 c2                	mov    %eax,%edx
     7d8:	2b 95 20 ff ff ff    	sub    -0xe0(%rbp),%edx
     7de:	41 01 56 08          	add    %edx,0x8(%r14)
		if (prealloc && dn.ofs_in_node != last_ofs_in_node + 1) {
     7e2:	48 83 bd 40 ff ff ff 	cmpq   $0x0,-0xc0(%rbp)
     7e9:	00 
     7ea:	0f 84 5f 07 00 00    	je     f4f <f2fs_map_blocks.cold+0xf4f>
     7f0:	8b 9d 30 ff ff ff    	mov    -0xd0(%rbp),%ebx
     7f6:	8d 53 01             	lea    0x1(%rbx),%edx
     7f9:	39 d0                	cmp    %edx,%eax
     7fb:	0f 84 4e 07 00 00    	je     f4f <f2fs_map_blocks.cold+0xf4f>
     801:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     808:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
			err = -ENOSPC;
     80f:	41 bd e4 ff ff ff    	mov    $0xffffffe4,%r13d
     815:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     81c:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     823:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
     827:	e9 49 fc ff ff       	jmpq   475 <f2fs_map_blocks.cold+0x475>
	if (dn->inode_page && dn->node_page != dn->inode_page)
     82c:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
     830:	48 85 ff             	test   %rdi,%rdi
     833:	0f 85 f4 fc ff ff    	jne    52d <f2fs_map_blocks.cold+0x52d>
     839:	e9 27 fd ff ff       	jmpq   565 <f2fs_map_blocks.cold+0x565>
     83e:	4c 89 c8             	mov    %r9,%rax
     841:	e9 4b fc ff ff       	jmpq   491 <f2fs_map_blocks.cold+0x491>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     846:	48 8b 07             	mov    (%rdi),%rax
     849:	48 c1 e8 33          	shr    $0x33,%rax
     84d:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     850:	83 f8 04             	cmp    $0x4,%eax
     853:	0f 85 e5 fc ff ff    	jne    53e <f2fs_map_blocks.cold+0x53e>
	switch (page->pgmap->type) {
     859:	48 8b 47 08          	mov    0x8(%rdi),%rax
     85d:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     863:	83 e8 01             	sub    $0x1,%eax
     866:	83 f8 02             	cmp    $0x2,%eax
     869:	0f 87 cf fc ff ff    	ja     53e <f2fs_map_blocks.cold+0x53e>
     86f:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     876:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
		__put_devmap_managed_page(page);
     87d:	e8 00 00 00 00       	callq  882 <f2fs_map_blocks.cold+0x882>
		return;
     882:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
     889:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     890:	e9 d0 fc ff ff       	jmpq   565 <f2fs_map_blocks.cold+0x565>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     895:	48 8b 03             	mov    (%rbx),%rax
     898:	48 c1 e8 33          	shr    $0x33,%rax
     89c:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     89f:	83 f8 04             	cmp    $0x4,%eax
     8a2:	0f 85 4c fc ff ff    	jne    4f4 <f2fs_map_blocks.cold+0x4f4>
	switch (page->pgmap->type) {
     8a8:	48 8b 43 08          	mov    0x8(%rbx),%rax
     8ac:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     8b2:	83 e8 01             	sub    $0x1,%eax
     8b5:	83 f8 02             	cmp    $0x2,%eax
     8b8:	0f 87 36 fc ff ff    	ja     4f4 <f2fs_map_blocks.cold+0x4f4>
		__put_devmap_managed_page(page);
     8be:	48 89 df             	mov    %rbx,%rdi
     8c1:	44 89 9d 70 ff ff ff 	mov    %r11d,-0x90(%rbp)
     8c8:	44 89 95 78 ff ff ff 	mov    %r10d,-0x88(%rbp)
     8cf:	e8 00 00 00 00       	callq  8d4 <f2fs_map_blocks.cold+0x8d4>
		return;
     8d4:	44 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%r10d
     8db:	44 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%r11d
     8e2:	e9 37 fc ff ff       	jmpq   51e <f2fs_map_blocks.cold+0x51e>
				map->m_pblk = 0;
     8e7:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
     8ee:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
				goto sync_out;
     8f5:	45 31 ed             	xor    %r13d,%r13d
     8f8:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     8ff:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     906:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     90d:	e9 63 fb ff ff       	jmpq   475 <f2fs_map_blocks.cold+0x475>
     912:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     919:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     920:	45 31 ed             	xor    %r13d,%r13d
     923:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     92a:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     931:	e9 d5 fa ff ff       	jmpq   40b <f2fs_map_blocks.cold+0x40b>
				if (map->m_next_pgofs)
     936:	49 8b 46 10          	mov    0x10(%r14),%rax
     93a:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     941:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     948:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     94f:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     956:	48 85 c0             	test   %rax,%rax
     959:	74 0e                	je     969 <f2fs_map_blocks.cold+0x969>
					*map->m_next_pgofs = pgofs + 1;// 指向下一个可能的（不含“洞”）的文件逻辑块偏移量
     95b:	48 8b 9d 50 ff ff ff 	mov    -0xb0(%rbp),%rbx
     962:	48 89 18             	mov    %rbx,(%rax)
     965:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
				goto sync_out;
     969:	45 31 ed             	xor    %r13d,%r13d
     96c:	e9 04 fb ff ff       	jmpq   475 <f2fs_map_blocks.cold+0x475>
				if (map->m_next_pgofs)
     971:	49 8b 46 10          	mov    0x10(%r14),%rax
     975:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     97c:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     983:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     98a:	48 85 c0             	test   %rax,%rax
     98d:	75 cc                	jne    95b <f2fs_map_blocks.cold+0x95b>
     98f:	eb d8                	jmp    969 <f2fs_map_blocks.cold+0x969>
	else if (dn.ofs_in_node < end_offset)
     991:	8b 45 bc             	mov    -0x44(%rbp),%eax
     994:	48 8d 53 01          	lea    0x1(%rbx),%rdx
     998:	48 3b 85 48 ff ff ff 	cmp    -0xb8(%rbp),%rax
     99f:	73 1a                	jae    9bb <f2fs_map_blocks.cold+0x9bb>
     9a1:	8b 4d bc             	mov    -0x44(%rbp),%ecx
     9a4:	48 89 95 50 ff ff ff 	mov    %rdx,-0xb0(%rbp)
     9ab:	4c 8b 4d b0          	mov    -0x50(%rbp),%r9
     9af:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 9b6 <f2fs_map_blocks.cold+0x9b6>
     9b6:	e9 80 f9 ff ff       	jmpq   33b <f2fs_map_blocks.cold+0x33b>
     9bb:	44 8b a5 78 ff ff ff 	mov    -0x88(%rbp),%r12d
	if (flag == F2FS_GET_BLOCK_PRECACHE) {// 处理预缓存数据块的情况
     9c2:	41 83 fc 05          	cmp    $0x5,%r12d
     9c6:	75 2f                	jne    9f7 <f2fs_map_blocks.cold+0x9f7>
		if (map->m_flags & F2FS_MAP_MAPPED) {
     9c8:	41 f6 46 0c 20       	testb  $0x20,0xc(%r14)
     9cd:	74 28                	je     9f7 <f2fs_map_blocks.cold+0x9f7>
			unsigned int ofs = start_pgofs - map->m_lblk;
     9cf:	41 8b 46 04          	mov    0x4(%r14),%eax
			f2fs_update_extent_cache_range(&dn,
     9d3:	41 8b 4e 08          	mov    0x8(%r14),%ecx
     9d7:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
     9db:	41 8b 16             	mov    (%r14),%edx
     9de:	8b 9d 24 ff ff ff    	mov    -0xdc(%rbp),%ebx
     9e4:	01 c1                	add    %eax,%ecx
     9e6:	8b b5 58 ff ff ff    	mov    -0xa8(%rbp),%esi
     9ec:	29 c2                	sub    %eax,%edx
     9ee:	29 d9                	sub    %ebx,%ecx
     9f0:	01 da                	add    %ebx,%edx
     9f2:	e8 00 00 00 00       	callq  9f7 <f2fs_map_blocks.cold+0x9f7>
	if (dn->node_page)
     9f7:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
     9fb:	4d 85 ed             	test   %r13,%r13
     9fe:	0f 84 d5 00 00 00    	je     ad9 <f2fs_map_blocks.cold+0xad9>
     a04:	49 8b 45 08          	mov    0x8(%r13),%rax
	if (unlikely(head & 1))
     a08:	a8 01                	test   $0x1,%al
     a0a:	0f 84 d4 00 00 00    	je     ae4 <f2fs_map_blocks.cold+0xae4>
		return (struct page *) (head - 1);
     a10:	48 83 e8 01          	sub    $0x1,%rax
     a14:	48 8b 00             	mov    (%rax),%rax
		f2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));
     a17:	a8 01                	test   $0x1,%al
     a19:	75 19                	jne    a34 <f2fs_map_blocks.cold+0xa34>
     a1b:	0f 0b                	ud2    
	return F2FS_I_SB(mapping->host);
     a1d:	49 8b 45 18          	mov    0x18(%r13),%rax
	return F2FS_SB(inode->i_sb);
     a21:	48 8b 00             	mov    (%rax),%rax
	return sb->s_fs_info;
     a24:	48 8b 40 28          	mov    0x28(%rax),%rax
	set_bit(type, &sbi->s_flag);
     a28:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
		asm volatile(LOCK_PREFIX "orb %1,%0"
     a2f:	f0 80 48 48 04       	lock orb $0x4,0x48(%rax)
		unlock_page(page);
     a34:	4c 89 ef             	mov    %r13,%rdi
     a37:	e8 00 00 00 00       	callq  a3c <f2fs_map_blocks.cold+0xa3c>
     a3c:	49 8b 45 08          	mov    0x8(%r13),%rax
	if (unlikely(head & 1))
     a40:	a8 01                	test   $0x1,%al
     a42:	74 04                	je     a48 <f2fs_map_blocks.cold+0xa48>
		return (struct page *) (head - 1);
     a44:	4c 8d 68 ff          	lea    -0x1(%rax),%r13
     a48:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     a4d:	f0 41 ff 4d 34       	lock decl 0x34(%r13)
	if (put_page_testzero(page))
     a52:	75 08                	jne    a5c <f2fs_map_blocks.cold+0xa5c>
		__put_page(page);
     a54:	4c 89 ef             	mov    %r13,%rdi
     a57:	e8 00 00 00 00       	callq  a5c <f2fs_map_blocks.cold+0xa5c>
	if (dn->inode_page && dn->node_page != dn->inode_page)
     a5c:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
     a60:	48 85 ff             	test   %rdi,%rdi
     a63:	74 22                	je     a87 <f2fs_map_blocks.cold+0xa87>
     a65:	48 3b 7d b0          	cmp    -0x50(%rbp),%rdi
     a69:	74 1c                	je     a87 <f2fs_map_blocks.cold+0xa87>
     a6b:	48 8b 47 08          	mov    0x8(%rdi),%rax
	if (unlikely(head & 1))
     a6f:	a8 01                	test   $0x1,%al
     a71:	74 04                	je     a77 <f2fs_map_blocks.cold+0xa77>
		return (struct page *) (head - 1);
     a73:	48 8d 78 ff          	lea    -0x1(%rax),%rdi
     a77:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     a7c:	f0 ff 4f 34          	lock decl 0x34(%rdi)
	if (put_page_testzero(page))
     a80:	75 05                	jne    a87 <f2fs_map_blocks.cold+0xa87>
		__put_page(page);
     a82:	e8 00 00 00 00       	callq  a87 <f2fs_map_blocks.cold+0xa87>
	if (create) {
     a87:	83 bd 64 ff ff ff 00 	cmpl   $0x0,-0x9c(%rbp)
	dn->node_page = NULL;
     a8e:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
     a95:	00 
	dn->inode_page = NULL;
     a96:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     a9d:	00 
     a9e:	74 26                	je     ac6 <f2fs_map_blocks.cold+0xac6>
	if (flag == F2FS_GET_BLOCK_PRE_AIO) {
     aa0:	41 83 fc 04          	cmp    $0x4,%r12d
     aa4:	0f 84 b3 04 00 00    	je     f5d <f2fs_map_blocks.cold+0xf5d>
	up_read(&sbi->cp_rwsem);
     aaa:	48 8b bd 18 ff ff ff 	mov    -0xe8(%rbp),%rdi
     ab1:	e8 00 00 00 00       	callq  ab6 <f2fs_map_blocks.cold+0xab6>
		f2fs_balance_fs(sbi, dn.node_changed);
     ab6:	0f b6 75 c1          	movzbl -0x3f(%rbp),%esi
     aba:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
     ac1:	e8 00 00 00 00       	callq  ac6 <f2fs_map_blocks.cold+0xac6>
					int create, int flag) {
     ac6:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
     acd:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
     ad4:	e9 62 f6 ff ff       	jmpq   13b <f2fs_map_blocks.cold+0x13b>
	if (dn->inode_page && dn->node_page != dn->inode_page)
     ad9:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
     add:	48 85 ff             	test   %rdi,%rdi
     ae0:	75 89                	jne    a6b <f2fs_map_blocks.cold+0xa6b>
     ae2:	eb a3                	jmp    a87 <f2fs_map_blocks.cold+0xa87>
     ae4:	4c 89 e8             	mov    %r13,%rax
     ae7:	e9 28 ff ff ff       	jmpq   a14 <f2fs_map_blocks.cold+0xa14>
		(pgofs == end || dn.ofs_in_node == end_offset)) {
     aec:	48 3b 85 48 ff ff ff 	cmp    -0xb8(%rbp),%rax
     af3:	0f 84 83 fb ff ff    	je     67c <f2fs_map_blocks.cold+0x67c>
     af9:	e9 33 fc ff ff       	jmpq   731 <f2fs_map_blocks.cold+0x731>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     afe:	49 8b 45 00          	mov    0x0(%r13),%rax
     b02:	48 c1 e8 33          	shr    $0x33,%rax
     b06:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     b09:	83 f8 04             	cmp    $0x4,%eax
     b0c:	0f 85 3b ff ff ff    	jne    a4d <f2fs_map_blocks.cold+0xa4d>
	switch (page->pgmap->type) {
     b12:	49 8b 45 08          	mov    0x8(%r13),%rax
     b16:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     b1c:	83 e8 01             	sub    $0x1,%eax
     b1f:	83 f8 02             	cmp    $0x2,%eax
     b22:	0f 87 25 ff ff ff    	ja     a4d <f2fs_map_blocks.cold+0xa4d>
		__put_devmap_managed_page(page);
     b28:	4c 89 ef             	mov    %r13,%rdi
     b2b:	e8 00 00 00 00       	callq  b30 <f2fs_map_blocks.cold+0xb30>
		return;
     b30:	e9 27 ff ff ff       	jmpq   a5c <f2fs_map_blocks.cold+0xa5c>
				err = __allocate_data_block(&dn, map->m_seg_type);// 分配磁盘块
     b35:	41 8b 46 20          	mov    0x20(%r14),%eax
     b39:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
	return sb->s_fs_info;
     b3f:	49 8b 47 28          	mov    0x28(%r15),%rax
     b43:	4c 8b a0 08 04 00 00 	mov    0x408(%rax),%r12
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     b4a:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
	if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))
     b51:	a8 40                	test   $0x40,%al
     b53:	74 25                	je     b7a <f2fs_map_blocks.cold+0xb7a>
     b55:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     b5c:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
		return -EPERM;
     b63:	41 83 cd ff          	or     $0xffffffff,%r13d
     b67:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     b6e:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
				if (!err)
     b75:	e9 87 f8 ff ff       	jmpq   401 <f2fs_map_blocks.cold+0x401>
	if (is_inode) {
     b7a:	39 fe                	cmp    %edi,%esi
     b7c:	0f 85 39 01 00 00    	jne    cbb <f2fs_map_blocks.cold+0xcbb>
		if (!inode)
     b82:	4d 85 ff             	test   %r15,%r15
     b85:	0f 85 22 01 00 00    	jne    cad <f2fs_map_blocks.cold+0xcad>
			(le16_to_cpu(i->i_extra_isize) / sizeof(__le32)) : 0;
     b8b:	f6 42 03 20          	testb  $0x20,0x3(%rdx)
     b8f:	0f 84 26 01 00 00    	je     cbb <f2fs_map_blocks.cold+0xcbb>
     b95:	0f b7 82 68 01 00 00 	movzwl 0x168(%rdx),%eax
     b9c:	66 c1 e8 02          	shr    $0x2,%ax
     ba0:	0f b7 c0             	movzwl %ax,%eax
	return le32_to_cpu(addr_array[base + offset]);
     ba3:	01 c8                	add    %ecx,%eax
     ba5:	41 8b 04 83          	mov    (%r11,%rax,4),%eax
	dn->data_blkaddr = datablock_addr(dn->inode,
     ba9:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	if (dn->data_blkaddr == NEW_ADDR)
     bac:	83 c0 01             	add    $0x1,%eax
     baf:	0f 85 1d 01 00 00    	jne    cd2 <f2fs_map_blocks.cold+0xcd2>
	f2fs_get_node_info(sbi, dn->nid, &ni);
     bb5:	8b 75 b8             	mov    -0x48(%rbp),%esi
     bb8:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
     bbc:	4c 89 e7             	mov    %r12,%rdi
     bbf:	e8 00 00 00 00       	callq  bc4 <f2fs_map_blocks.cold+0xbc4>
	sum->nid = cpu_to_le32(nid);
     bc4:	8b 45 b8             	mov    -0x48(%rbp),%eax
	f2fs_allocate_data_block(sbi, NULL, dn->data_blkaddr, &dn->data_blkaddr,
     bc7:	8b 55 c4             	mov    -0x3c(%rbp),%edx
     bca:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
     bce:	4c 8d 45 c9          	lea    -0x37(%rbp),%r8
     bd2:	31 f6                	xor    %esi,%esi
     bd4:	4c 89 e7             	mov    %r12,%rdi
     bd7:	89 45 c9             	mov    %eax,-0x37(%rbp)
	sum->ofs_in_node = cpu_to_le16(ofs_in_node);
     bda:	8b 45 bc             	mov    -0x44(%rbp),%eax
     bdd:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
	sum->version = version;
     be1:	0f b6 45 9c          	movzbl -0x64(%rbp),%eax
     be5:	88 45 cd             	mov    %al,-0x33(%rbp)
     be8:	6a 00                	pushq  $0x0
     bea:	6a 00                	pushq  $0x0
     bec:	44 8b 8d 14 ff ff ff 	mov    -0xec(%rbp),%r9d
     bf3:	e8 00 00 00 00       	callq  bf8 <f2fs_map_blocks.cold+0xbf8>
	f2fs_set_data_blkaddr(dn);
     bf8:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
     bfc:	e8 00 00 00 00       	callq  c01 <f2fs_map_blocks.cold+0xc01>
	return page_to_virt(page);
     c01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
     c05:	48 2b 05 00 00 00 00 	sub    0x0(%rip),%rax        # c0c <f2fs_map_blocks.cold+0xc0c>
	unsigned flag = le32_to_cpu(rn->footer.flag);
     c0c:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # c13 <f2fs_map_blocks.cold+0xc13>
     c13:	48 c1 f8 06          	sar    $0x6,%rax
	fofs = f2fs_start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +
     c17:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
     c1b:	48 c1 e0 0c          	shl    $0xc,%rax
	return flag >> OFFSET_BIT_SHIFT;
     c1f:	8b bc 10 f0 0f 00 00 	mov    0xff0(%rax,%rdx,1),%edi
     c26:	c1 ef 03             	shr    $0x3,%edi
     c29:	e8 00 00 00 00       	callq  c2e <f2fs_map_blocks.cold+0xc2e>
	if (i_size_read(dn->inode) < ((loff_t) (fofs + 1) << PAGE_SHIFT))
     c2e:	4c 8b 7d a0          	mov    -0x60(%rbp),%r15
	fofs = f2fs_start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +
     c32:	03 45 bc             	add    -0x44(%rbp),%eax
	if (i_size_read(dn->inode) < ((loff_t) (fofs + 1) << PAGE_SHIFT))
     c35:	48 83 c0 01          	add    $0x1,%rax
     c39:	5a                   	pop    %rdx
     c3a:	59                   	pop    %rcx
     c3b:	48 c1 e0 0c          	shl    $0xc,%rax
     c3f:	49 39 47 50          	cmp    %rax,0x50(%r15)
     c43:	7d 3d                	jge    c82 <f2fs_map_blocks.cold+0xc82>
	inode->i_size = i_size;
     c45:	49 89 47 50          	mov    %rax,0x50(%r15)
     c49:	4d 8b af 78 02 00 00 	mov    0x278(%r15),%r13
	f2fs_mark_inode_dirty_sync(inode, true);
     c50:	be 01 00 00 00       	mov    $0x1,%esi
     c55:	4c 89 ff             	mov    %r15,%rdi
     c58:	49 8b 9f 78 02 00 00 	mov    0x278(%r15),%rbx
     c5f:	e8 00 00 00 00       	callq  c64 <f2fs_map_blocks.cold+0xc64>
	if (clean || recover)
     c64:	41 80 e5 02          	and    $0x2,%r13b
     c68:	0f 85 b6 01 00 00    	jne    e24 <f2fs_map_blocks.cold+0xe24>
     c6e:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
     c75:	a8 04                	test   $0x4,%al
     c77:	75 09                	jne    c82 <f2fs_map_blocks.cold+0xc82>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     c79:	f0 41 80 8f 78 02 00 	lock orb $0x4,0x278(%r15)
     c80:	00 04 
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     c82:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     c89:	48 8b 80 78 02 00 00 	mov    0x278(%rax),%rax
     c90:	f6 c4 10             	test   $0x10,%ah
     c93:	0f 85 b1 f9 ff ff    	jne    64a <f2fs_map_blocks.cold+0x64a>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     c99:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
     ca0:	f0 80 88 79 02 00 00 	lock orb $0x10,0x279(%rax)
     ca7:	10 
     ca8:	e9 9d f9 ff ff       	jmpq   64a <f2fs_map_blocks.cold+0x64a>
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     cad:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
		else if (f2fs_has_extra_attr(inode))
     cb4:	a9 00 00 00 04       	test   $0x4000000,%eax
     cb9:	75 07                	jne    cc2 <f2fs_map_blocks.cold+0xcc2>
	int base = 0;
     cbb:	31 c0                	xor    %eax,%eax
     cbd:	e9 e1 fe ff ff       	jmpq   ba3 <f2fs_map_blocks.cold+0xba3>
	return F2FS_I(inode)->i_extra_isize / sizeof(__le32);
     cc2:	49 63 87 08 04 00 00 	movslq 0x408(%r15),%rax
     cc9:	48 c1 e8 02          	shr    $0x2,%rax
     ccd:	e9 d1 fe ff ff       	jmpq   ba3 <f2fs_map_blocks.cold+0xba3>
	return __dquot_alloc_space(inode, nr << inode->i_blkbits,
     cd2:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
     cd9:	be 01 00 00 00       	mov    $0x1,%esi
     cde:	ba 03 00 00 00       	mov    $0x3,%edx
     ce3:	4c 89 ff             	mov    %r15,%rdi
     ce6:	48 d3 e6             	shl    %cl,%rsi
     ce9:	e8 00 00 00 00       	callq  cee <f2fs_map_blocks.cold+0xcee>
	if (ret)
     cee:	85 c0                	test   %eax,%eax
     cf0:	74 24                	je     d16 <f2fs_map_blocks.cold+0xd16>
     cf2:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     cf9:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     d00:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     d07:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
				if (!err)
     d0e:	41 89 c5             	mov    %eax,%r13d
     d11:	e9 eb f6 ff ff       	jmpq   401 <f2fs_map_blocks.cold+0x401>
	percpu_counter_add(&sbi->alloc_valid_block_count, (*count));
     d16:	49 8d 84 24 98 04 00 	lea    0x498(%r12),%rax
     d1d:	00 
     d1e:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # d24 <f2fs_map_blocks.cold+0xd24>
     d24:	be 01 00 00 00       	mov    $0x1,%esi
	raw_spin_lock(&lock->rlock);
     d29:	4d 8d ac 24 00 06 00 	lea    0x600(%r12),%r13
     d30:	00 
     d31:	48 89 c7             	mov    %rax,%rdi
     d34:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
     d3b:	e8 00 00 00 00       	callq  d40 <f2fs_map_blocks.cold+0xd40>
     d40:	4c 89 ef             	mov    %r13,%rdi
     d43:	e8 00 00 00 00       	callq  d48 <f2fs_map_blocks.cold+0xd48>
	avail_user_block_count = sbi->user_block_count -
     d48:	41 8b 94 24 54 04 00 	mov    0x454(%r12),%edx
     d4f:	00 
	sbi->total_valid_block_count += (block_t)(*count);
     d50:	41 83 84 24 58 04 00 	addl   $0x1,0x458(%r12)
     d57:	00 01 
	avail_user_block_count = sbi->user_block_count -
     d59:	89 d3                	mov    %edx,%ebx
     d5b:	41 2b 9c 24 68 04 00 	sub    0x468(%r12),%ebx
     d62:	00 
	if (!inode)
     d63:	4d 85 ff             	test   %r15,%r15
     d66:	0f 85 a0 00 00 00    	jne    e0c <f2fs_map_blocks.cold+0xe0c>
	if (unlikely(sbi->total_valid_block_count > avail_user_block_count)) {
     d6c:	41 8b 84 24 58 04 00 	mov    0x458(%r12),%eax
     d73:	00 
     d74:	39 d8                	cmp    %ebx,%eax
     d76:	0f 86 14 01 00 00    	jbe    e90 <f2fs_map_blocks.cold+0xe90>
		sbi->total_valid_block_count -= diff;
     d7c:	89 c1                	mov    %eax,%ecx
     d7e:	ba 01 00 00 00       	mov    $0x1,%edx
     d83:	29 d9                	sub    %ebx,%ecx
     d85:	0f 44 d1             	cmove  %ecx,%edx
     d88:	29 d0                	sub    %edx,%eax
     d8a:	41 89 84 24 58 04 00 	mov    %eax,0x458(%r12)
     d91:	00 
		if (!*count) {
     d92:	85 c9                	test   %ecx,%ecx
     d94:	0f 84 f6 00 00 00    	je     e90 <f2fs_map_blocks.cold+0xe90>
     d9a:	44 8b 95 64 ff ff ff 	mov    -0x9c(%rbp),%r10d
     da1:	4c 89 fb             	mov    %r15,%rbx
     da4:	4c 8b a5 68 ff ff ff 	mov    -0x98(%rbp),%r12
     dab:	4c 89 ef             	mov    %r13,%rdi
     dae:	4c 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%r15
     db5:	44 89 95 70 ff ff ff 	mov    %r10d,-0x90(%rbp)
     dbc:	ff 14 25 00 00 00 00 	callq  *0x0
     dc3:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # dc9 <f2fs_map_blocks.cold+0xdc9>
     dc9:	48 8b bd 08 ff ff ff 	mov    -0xf8(%rbp),%rdi
     dd0:	48 83 ce ff          	or     $0xffffffffffffffff,%rsi
     dd4:	e8 00 00 00 00       	callq  dd9 <f2fs_map_blocks.cold+0xdd9>
	__dquot_free_space(inode, nr << inode->i_blkbits, DQUOT_SPACE_RESERVE);
     dd9:	8b 8b 90 00 00 00    	mov    0x90(%rbx),%ecx
     ddf:	be 01 00 00 00       	mov    $0x1,%esi
     de4:	48 89 df             	mov    %rbx,%rdi
     de7:	ba 02 00 00 00       	mov    $0x2,%edx
     dec:	48 d3 e6             	shl    %cl,%rsi
     def:	e8 00 00 00 00       	callq  df4 <f2fs_map_blocks.cold+0xdf4>
	return -ENOSPC;
     df4:	44 8b 9d 78 ff ff ff 	mov    -0x88(%rbp),%r11d
     dfb:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
     e00:	44 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10d
     e07:	e9 02 ff ff ff       	jmpq   d0e <f2fs_map_blocks.cold+0xd0e>
	if (!test_opt(sbi, RESERVE_ROOT))
     e0c:	41 f6 84 24 f3 04 00 	testb  $0x1,0x4f3(%r12)
     e13:	00 01 
     e15:	75 1b                	jne    e32 <f2fs_map_blocks.cold+0xe32>
		avail_user_block_count -= F2FS_OPTION(sbi).root_reserved_blocks;
     e17:	41 2b 9c 24 f8 04 00 	sub    0x4f8(%r12),%ebx
     e1e:	00 
     e1f:	e9 48 ff ff ff       	jmpq   d6c <f2fs_map_blocks.cold+0xd6c>
	if (clean || recover)
     e24:	80 e3 04             	and    $0x4,%bl
     e27:	0f 85 41 fe ff ff    	jne    c6e <f2fs_map_blocks.cold+0xc6e>
     e2d:	e9 50 fe ff ff       	jmpq   c82 <f2fs_map_blocks.cold+0xc82>
	if (IS_NOQUOTA(inode))
     e32:	41 f6 47 0c 20       	testb  $0x20,0xc(%r15)
     e37:	0f 85 2f ff ff ff    	jne    d6c <f2fs_map_blocks.cold+0xd6c>
	if (uid_eq(F2FS_OPTION(sbi).s_resuid, current_fsuid()))
     e3d:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
     e44:	48 8b 80 28 0a 00 00 	mov    0xa28(%rax),%rax
     e4b:	8b 40 1c             	mov    0x1c(%rax),%eax
     e4e:	41 39 84 24 fc 04 00 	cmp    %eax,0x4fc(%r12)
     e55:	00 
     e56:	0f 84 10 ff ff ff    	je     d6c <f2fs_map_blocks.cold+0xd6c>
	if (!gid_eq(F2FS_OPTION(sbi).s_resgid, GLOBAL_ROOT_GID) &&
     e5c:	41 83 bc 24 00 05 00 	cmpl   $0x0,0x500(%r12)
     e63:	00 00 
     e65:	74 15                	je     e7c <f2fs_map_blocks.cold+0xe7c>
					in_group_p(F2FS_OPTION(sbi).s_resgid))
     e67:	41 8b bc 24 00 05 00 	mov    0x500(%r12),%edi
     e6e:	00 
     e6f:	e8 00 00 00 00       	callq  e74 <f2fs_map_blocks.cold+0xe74>
	if (!gid_eq(F2FS_OPTION(sbi).s_resgid, GLOBAL_ROOT_GID) &&
     e74:	85 c0                	test   %eax,%eax
     e76:	0f 85 f0 fe ff ff    	jne    d6c <f2fs_map_blocks.cold+0xd6c>
	if (cap && capable(CAP_SYS_RESOURCE))
     e7c:	bf 18 00 00 00       	mov    $0x18,%edi
     e81:	e8 00 00 00 00       	callq  e86 <f2fs_map_blocks.cold+0xe86>
     e86:	84 c0                	test   %al,%al
     e88:	0f 85 de fe ff ff    	jne    d6c <f2fs_map_blocks.cold+0xd6c>
     e8e:	eb 87                	jmp    e17 <f2fs_map_blocks.cold+0xe17>
     e90:	4c 89 ef             	mov    %r13,%rdi
     e93:	ff 14 25 00 00 00 00 	callq  *0x0
     e9a:	49 8b 9f 78 02 00 00 	mov    0x278(%r15),%rbx
	ret = dquot_claim_space_nodirty(inode, nr << inode->i_blkbits);
     ea1:	41 8b 8f 90 00 00 00 	mov    0x90(%r15),%ecx
     ea8:	b8 01 00 00 00       	mov    $0x1,%eax
     ead:	4c 89 ff             	mov    %r15,%rdi
     eb0:	4d 8b af 78 02 00 00 	mov    0x278(%r15),%r13
     eb7:	48 d1 eb             	shr    %rbx
     eba:	48 d3 e0             	shl    %cl,%rax
     ebd:	83 e3 01             	and    $0x1,%ebx
     ec0:	49 c1 ed 02          	shr    $0x2,%r13
     ec4:	48 89 c6             	mov    %rax,%rsi
	bool clean = !is_inode_flag_set(inode, FI_DIRTY_INODE);
     ec7:	83 f3 01             	xor    $0x1,%ebx
     eca:	41 83 e5 01          	and    $0x1,%r13d
     ece:	e8 00 00 00 00       	callq  ed3 <f2fs_map_blocks.cold+0xed3>
	if (!ret)
     ed3:	85 c0                	test   %eax,%eax
     ed5:	75 0d                	jne    ee4 <f2fs_map_blocks.cold+0xee4>
	__mark_inode_dirty(inode, I_DIRTY_SYNC);
     ed7:	be 01 00 00 00       	mov    $0x1,%esi
     edc:	4c 89 ff             	mov    %r15,%rdi
     edf:	e8 00 00 00 00       	callq  ee4 <f2fs_map_blocks.cold+0xee4>
	f2fs_mark_inode_dirty_sync(inode, true);
     ee4:	be 01 00 00 00       	mov    $0x1,%esi
     ee9:	4c 89 ff             	mov    %r15,%rdi
     eec:	e8 00 00 00 00       	callq  ef1 <f2fs_map_blocks.cold+0xef1>
	if (clean || recover)
     ef1:	84 db                	test   %bl,%bl
     ef3:	74 1d                	je     f12 <f2fs_map_blocks.cold+0xf12>
     ef5:	49 8b 87 78 02 00 00 	mov    0x278(%r15),%rax
	if (!test_bit(flag, &F2FS_I(inode)->flags))
     efc:	a8 04                	test   $0x4,%al
     efe:	0f 85 b1 fc ff ff    	jne    bb5 <f2fs_map_blocks.cold+0xbb5>
		asm volatile(LOCK_PREFIX "orb %1,%0"
     f04:	f0 41 80 8f 78 02 00 	lock orb $0x4,0x278(%r15)
     f0b:	00 04 
     f0d:	e9 a3 fc ff ff       	jmpq   bb5 <f2fs_map_blocks.cold+0xbb5>
	if (clean || recover)
     f12:	45 84 ed             	test   %r13b,%r13b
     f15:	75 de                	jne    ef5 <f2fs_map_blocks.cold+0xef5>
     f17:	e9 99 fc ff ff       	jmpq   bb5 <f2fs_map_blocks.cold+0xbb5>
	return (page->flags >> ZONES_PGSHIFT) & ZONES_MASK;
     f1c:	48 8b 07             	mov    (%rdi),%rax
     f1f:	48 c1 e8 33          	shr    $0x33,%rax
     f23:	83 e0 07             	and    $0x7,%eax
	if (!is_zone_device_page(page))
     f26:	83 f8 04             	cmp    $0x4,%eax
     f29:	0f 85 4d fb ff ff    	jne    a7c <f2fs_map_blocks.cold+0xa7c>
	switch (page->pgmap->type) {
     f2f:	48 8b 47 08          	mov    0x8(%rdi),%rax
     f33:	8b 80 98 00 00 00    	mov    0x98(%rax),%eax
     f39:	83 e8 01             	sub    $0x1,%eax
     f3c:	83 f8 02             	cmp    $0x2,%eax
     f3f:	0f 87 37 fb ff ff    	ja     a7c <f2fs_map_blocks.cold+0xa7c>
		__put_devmap_managed_page(page);
     f45:	e8 00 00 00 00       	callq  f4a <f2fs_map_blocks.cold+0xf4a>
		return;
     f4a:	e9 38 fb ff ff       	jmpq   a87 <f2fs_map_blocks.cold+0xa87>
		dn.ofs_in_node = end_offset;// 处理完一个dnode, 数据块指针移到dnode的最后一个位置
     f4f:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
     f55:	89 45 bc             	mov    %eax,-0x44(%rbp)
     f58:	e9 d4 f7 ff ff       	jmpq   731 <f2fs_map_blocks.cold+0x731>
			up_read(&sbi->node_change);
     f5d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
     f64:	48 8d b8 00 02 00 00 	lea    0x200(%rax),%rdi
     f6b:	e8 00 00 00 00       	callq  f70 <f2fs_map_blocks.cold+0xf70>
     f70:	e9 41 fb ff ff       	jmpq   ab6 <f2fs_map_blocks.cold+0xab6>

0000000000000f75 <f2fs_preallocate_blocks.cold>:
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     f75:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
     f7c:	00 
	if (f2fs_has_inline_data(inode)){
     f7d:	f6 c4 04             	test   $0x4,%ah
     f80:	0f 84 85 00 00 00    	je     100b <f2fs_preallocate_blocks.cold+0x96>
		printk(KERN_INFO"ZN trap: f2fs_has_inline_data");
     f86:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     f8d:	e8 00 00 00 00       	callq  f92 <f2fs_preallocate_blocks.cold+0x1d>
		return err;
     f92:	31 c0                	xor    %eax,%eax
     f94:	e9 00 00 00 00       	jmpq   f99 <f2fs_preallocate_blocks.cold+0x24>
	return f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode);
     f99:	41 0f b7 04 24       	movzwl (%r12),%eax
     f9e:	66 25 00 f0          	and    $0xf000,%ax
     fa2:	66 3d 00 80          	cmp    $0x8000,%ax
     fa6:	74 15                	je     fbd <f2fs_preallocate_blocks.cold+0x48>
	return sb->s_fs_info;
     fa8:	49 8b 44 24 28       	mov    0x28(%r12),%rax
     fad:	48 8b 80 08 04 00 00 	mov    0x408(%rax),%rax
			(rw == WRITE && test_opt(F2FS_I_SB(inode), LFS)) ||
     fb4:	f6 80 f2 04 00 00 04 	testb  $0x4,0x4f2(%rax)
     fbb:	74 3e                	je     ffb <f2fs_preallocate_blocks.cold+0x86>
			   F2FS_GET_BLOCK_PRE_AIO :
     fbd:	41 bd 04 00 00 00    	mov    $0x4,%r13d
	printk(KERN_INFO"ZN trap: f2fs_map_blocks");
     fc3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     fca:	e8 00 00 00 00       	callq  fcf <f2fs_preallocate_blocks.cold+0x5a>
	err = f2fs_map_blocks(inode, &map, 1, flag);
     fcf:	44 89 e9             	mov    %r13d,%ecx
     fd2:	ba 01 00 00 00       	mov    $0x1,%edx
     fd7:	4c 89 e7             	mov    %r12,%rdi
     fda:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
     fde:	e8 00 00 00 00       	callq  fe3 <f2fs_preallocate_blocks.cold+0x6e>
	if (map.m_len > 0 && err == -ENOSPC) {
     fe3:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
     fe7:	0f 84 00 00 00 00    	je     fed <f2fs_preallocate_blocks.cold+0x78>
     fed:	83 f8 e4             	cmp    $0xffffffe4,%eax
     ff0:	0f 85 00 00 00 00    	jne    ff6 <f2fs_preallocate_blocks.cold+0x81>
     ff6:	e9 00 00 00 00       	jmpq   ffb <f2fs_preallocate_blocks.cold+0x86>
			   F2FS_GET_BLOCK_PRE_AIO :
     ffb:	83 b8 e8 06 00 00 01 	cmpl   $0x1,0x6e8(%rax)
    1002:	45 19 ed             	sbb    %r13d,%r13d
    1005:	41 83 c5 04          	add    $0x4,%r13d
    1009:	eb b8                	jmp    fc3 <f2fs_preallocate_blocks.cold+0x4e>
	printk(KERN_INFO"ZN trap: f2fs_map_blocks");
    100b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1012:	e8 00 00 00 00       	callq  1017 <f2fs_preallocate_blocks.cold+0xa2>
	err = f2fs_map_blocks(inode, &map, 1, flag);
    1017:	b9 04 00 00 00       	mov    $0x4,%ecx
    101c:	ba 01 00 00 00       	mov    $0x1,%edx
    1021:	4c 89 e7             	mov    %r12,%rdi
    1024:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
    1028:	e8 00 00 00 00       	callq  102d <f2fs_preallocate_blocks.cold+0xb8>
	if (map.m_len > 0 && err == -ENOSPC) {
    102d:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
    1031:	0f 84 00 00 00 00    	je     1037 <f2fs_preallocate_blocks.cold+0xc2>
    1037:	83 f8 e4             	cmp    $0xffffffe4,%eax
    103a:	0f 85 00 00 00 00    	jne    1040 <f2fs_preallocate_blocks.cold+0xcb>
    1040:	49 8b 84 24 78 02 00 	mov    0x278(%r12),%rax
    1047:	00 
	if (!test_bit(flag, &F2FS_I(inode)->flags))
    1048:	a9 00 00 00 01       	test   $0x1000000,%eax
    104d:	0f 85 00 00 00 00    	jne    1053 <f2fs_preallocate_blocks.cold+0xde>
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1053:	f0 41 80 8c 24 7b 02 	lock orb $0x1,0x27b(%r12)
    105a:	00 00 01 
		err = 0;
    105d:	31 c0                	xor    %eax,%eax
    105f:	e9 00 00 00 00       	jmpq   1064 <f2fs_direct_IO+0x54>

Disassembly of section .altinstr_replacement:

0000000000000000 <.altinstr_replacement>:
   0:	0f 0d 48 f8          	prefetchw -0x8(%rax)

Disassembly of section .init.text:

0000000000000000 <f2fs_init_post_read_processing>:

int __init f2fs_init_post_read_processing(void) {
   0:	f3 0f 1e fa          	endbr64 
   4:	e8 00 00 00 00       	callq  9 <f2fs_init_post_read_processing+0x9>
   9:	55                   	push   %rbp
	bio_post_read_ctx_cache = KMEM_CACHE(bio_post_read_ctx, 0);
   a:	45 31 c0             	xor    %r8d,%r8d
   d:	31 c9                	xor    %ecx,%ecx
   f:	ba 08 00 00 00       	mov    $0x8,%edx
  14:	be 30 00 00 00       	mov    $0x30,%esi
  19:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
int __init f2fs_init_post_read_processing(void) {
  20:	48 89 e5             	mov    %rsp,%rbp
	bio_post_read_ctx_cache = KMEM_CACHE(bio_post_read_ctx, 0);
  23:	e8 00 00 00 00       	callq  28 <f2fs_init_post_read_processing+0x28>
	return 0;

	fail_free_cache:
	kmem_cache_destroy(bio_post_read_ctx_cache);
	fail:
	return -ENOMEM;
  28:	41 b8 f4 ff ff ff    	mov    $0xfffffff4,%r8d
	bio_post_read_ctx_cache = KMEM_CACHE(bio_post_read_ctx, 0);
  2e:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 35 <f2fs_init_post_read_processing+0x35>
	if (!bio_post_read_ctx_cache)
  35:	48 85 c0             	test   %rax,%rax
  38:	74 3c                	je     76 <f2fs_init_post_read_processing+0x76>
  3a:	48 89 c1             	mov    %rax,%rcx
}

static inline mempool_t *
mempool_create_slab_pool(int min_nr, struct kmem_cache *kc)
{
	return mempool_create(min_nr, mempool_alloc_slab, mempool_free_slab,
  3d:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
  44:	bf 80 00 00 00       	mov    $0x80,%edi
  49:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
  50:	e8 00 00 00 00       	callq  55 <f2fs_init_post_read_processing+0x55>
	return 0;
  55:	45 31 c0             	xor    %r8d,%r8d
	bio_post_read_ctx_pool =
  58:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 5f <f2fs_init_post_read_processing+0x5f>
	if (!bio_post_read_ctx_pool)
  5f:	48 85 c0             	test   %rax,%rax
  62:	75 12                	jne    76 <f2fs_init_post_read_processing+0x76>
	kmem_cache_destroy(bio_post_read_ctx_cache);
  64:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 6b <f2fs_init_post_read_processing+0x6b>
  6b:	e8 00 00 00 00       	callq  70 <f2fs_init_post_read_processing+0x70>
	return -ENOMEM;
  70:	41 b8 f4 ff ff ff    	mov    $0xfffffff4,%r8d
}
  76:	44 89 c0             	mov    %r8d,%eax
  79:	5d                   	pop    %rbp
  7a:	c3                   	retq   

Disassembly of section .exit.text:

0000000000000000 <f2fs_destroy_post_read_processing>:

void __exit f2fs_destroy_post_read_processing(void) {
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
	mempool_destroy(bio_post_read_ctx_pool);
   5:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # c <f2fs_destroy_post_read_processing+0xc>
void __exit f2fs_destroy_post_read_processing(void) {
   c:	48 89 e5             	mov    %rsp,%rbp
	mempool_destroy(bio_post_read_ctx_pool);
   f:	e8 00 00 00 00       	callq  14 <f2fs_destroy_post_read_processing+0x14>
	kmem_cache_destroy(bio_post_read_ctx_cache);
  14:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1b <f2fs_destroy_post_read_processing+0x1b>
  1b:	e8 00 00 00 00       	callq  20 <f2fs_destroy_post_read_processing+0x20>
}
  20:	5d                   	pop    %rbp
  21:	c3                   	retq   
